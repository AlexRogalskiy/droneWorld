{"version":3,"sources":["textures/Rock_08_UV_H_CM_1.jpg","textures/Rock_08_UV_H_CM_1_normal.jpg","textures/GrassGreenTexture_1024.jpg","textures/GrassGreenTexture_1024_normal.jpg","textures/Water_1_M_Normal.jpg","textures/Water_2_M_Normal.jpg","terrain/terrain.worker.js","materials/meshphysical_vert.glsl","materials/meshphysical_frag.glsl","materials/terrain_tile_raw.vert.glsl","materials/terrain_tile_raw.frag.glsl","materials/terrain_voxel_vert.glsl","materials/terrain_voxel_frag.glsl","voxel/voxel.worker.js","ocean/water_frag.glsl","ocean/water_vert.glsl","ocean/underwater_frag.glsl","ocean/underwater_vert.glsl","textures/GrassGreenTexture0003.jpg","textures/GrassGreenTexture0003_normal.jpg","textures/lensflare/lensflare3.png","particles/three.js","textures/Explosion_002_Tile_8x8_256x256.png","textures/smokeparticle.png","textures/spark.png","textures/bullet.png","sound/impact1.ogg","sound/impact2.ogg","sound/impact3.ogg","sound/impact4.ogg","sound/gatling.ogg","sound/missile.ogg","sound/explosion1.ogg","sound/explosion2.ogg","events/index.js","modules/Sky.js","lights.js","materials/terrainPhysical.js","materials/terrainTileRaw.js","terrain/index.js","loops/tileBuilder.js","materials/terrainVoxel.js","voxel/constants.js","voxel/index.js","loops/voxelsLoop.js","loops/terrainLoop.js","postprocessing/lensflares.js","postprocessing/MotionBlur.js","postprocessing/Clouds.js","utils/index.js","hud/index.js","hud/crosshair.js","particles/index.js","drones/loader.js","drones/init.js","drones/index.js","modules/FlyControls.js","controls/autopilot.js","controls/index.js","utils/isMobile.js","sound/index.js","ocean/index.js","index.js","sky/index.js","modules/WindowResize.js"],"names":["module","exports","__webpack_require__","p","Worker","r","__webpack_exports__","three__WEBPACK_IMPORTED_MODULE_0__","d","PubSub","Sky","shader","SkyShader","material","ShaderMaterial","fragmentShader","vertexShader","uniforms","UniformsUtils","clone","side","BackSide","Mesh","call","this","SphereBufferGeometry","prototype","Object","create","luminance","value","turbidity","rayleigh","mieCoefficient","mieDirectionalG","sunPosition","Vector3","dirLight","DirectionalLight","window","hemishpereLight","HemisphereLight","position","set","up","needsUpdate","ambientLight","AmbientLight","updateDirLightPosition","copy","normalize","multiplyScalar","add","drone","textureLoader","TextureLoader","setCrossOrigin","rockTexture","load","require","rockTextureNormal","grassTexture","grassTextureNormal","wrapS","wrapT","RepeatWrapping","offset","repeat","lon","zoom","materialBasic","options","RawShaderMaterial","objectSpread","roughness","metalness","UniformsLib","common","lights","normalmap","fog","map","normalMap","uvTransform","Matrix3","MaterialBasic","chamonix","x","Math","pow","y","lat","log","tan","PI","cos","lat2tile","setTilePosition","geometry","key","zxyijs","split","parseInt","z","size","offsetAtZ","opacity","clearCoat","clearCoatRoughness","specularMap","envmap","aomap","lightmap","emissivemap","bumpmap","displacementmap","roughnessmap","metalnessmap","gradientmap","points","defines","PHYSICAL","USE_MAP","USE_NORMALMAP","USE_ENVMAP","ENVMAP_TYPE_CUBE","ENVMAP_BLENDING_MULTIPLY","TONE_MAPPING","extensions","derivatives","wireframe","toneMappingExposure","toneMappingWhitePoint","lightMapIntensity","aoMapIntensity","emissiveIntensity","envMapIntensity","refractionRatio","bumpscale","normalScale","Vector2","reflectivity","isShaderMaterial","isMeshStandardMaterial","isMeshPhysicalMaterial","Material","buildTileFromWorker","event","BufferGeometry","positions","Float32Array","data","normals","index","IndexArrayClass","2","Uint16Array","4","Uint32Array","bpe","indices","uv","length","n","sqrt","_","floor","addAttribute","BufferAttribute","setIndex","computeBoundingSphere","computeBoundingBox","terrainMaterial","PBR","plane","name","castShadow","receiveShadow","scene","renderer","shadowMap","workerPool","workerPoolSize","navigator","hardwareConcurrency","i","worker","onmessage","push","currentWorker","postMessage","args","lastCameraPosition","currentKeysArray","tiles","pngs","deleteTile","tile","remove","dispose","camVec","tileBuilder","timestamp","cameraPosition","camera","applyQuaternion","quaternion","targetPosition","max","abs","updatePosition","distanceTo","distance","zoomDelta","min","currentTileSize","x0","round","y0","segments0","segments1","cutOffDistance","distanceVector","cameraXY","objectXY","visibleKeysArray","visibleKeysString","k","toString","currentKeysString","potentialUnderKeys","slice","potentialUnderTiles","children","filter","child","includes","tileToCamera","subVectors","sort","a","b","userData","terrainKeysUnder","terrainTileUnder","newKeys","indexOf","existingKeys","forEach","newKey","segments","j","apply","toConsumableArray","distanceToCamera","visible","setTimeout","markedForDeletion","clean","MirroredRepeatWrapping","voxelOffset","STANDARD","emptyKeys","Set","buildVoxelsFromWorker","hasGeometry","pos1","normals1","index1","mesh","box","BoxHelper","keyString","currentKeys","voxelBuilder","i0","j0","console","visibleKeys","Frustum","setFromMatrix","Matrix4","multiplyMatrices","projectionMatrix","matrixWorldInverse","has","sub","voxelBlock","ceil","voxelNumber","terrainLoops","activeTerrainIndex","keyboardJS","bind","e","textureFlare3","lensFlare","Lensflare","addElement","LensflareElement","motionBlurShader","tDepth","type","tColor","velocityFactor","delta","clipToWorldMatrix","previousWorldToClipMatrix","cameraMove","pilotDrone","horizonStyle","focalStyle","screenXYclamped","vec3","screenPosition","centered","arguments","undefined","vector","widthHalf","innerWidth","heightHalf","innerHeight","project","screenXY","clamp","Crosshair","preact_compat_es","createElement","props","viewBox","width","height","cx","cy","PureComponent","screenCenter","subscribe","msg","rendererSize","hudData","targets","targetsInSight","targetsInFront","gunTarget","HUD","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","state","time","gunHeat","lockLevel","pilot","publish","gunClock","running","getDelta","stop","_this2","times","target","lockClock","newState","setState","lock","_this3","Array","from","targetsData","assign","id","style","altitude","toFixed","speed","className","crosshair","fill","stroke","strokeWidth","strokeDasharray","transform","concat","strokeLinecap","gunHud","hudPosition","direction","fillOpacity","strokeOpacity","hud","element","life","arrow","innerHTML","Component","targetDistance2D","targetDistance3D","targetVector2D","targetVector3D","targetDirection","targetLoop","hudElement","mounted","borderColor","borderBottomColor","hudPositionCentered","color","angle","destroyed","start","delete","ZONE","velocity","ready","targetToDestroy","forceUpdate","localX","localY","rollAngle","pitch","rollAngleDegree","hudLoop","angleTo","sign","dot","boxShadow","selectNearestGunTarget","update","distances","ReactDOM","render","hud_HUD","document","getElementById","fireGroupOptions","texture","frames","loop","depthTest","depthWrite","blending","AdditiveBlending","scale","maxParticleCount","pointsGroupOptions","NormalBlending","debrisGroupOptions","bulletGroupOptions","shockwaveOptions","particleCount","SPE","distributions","DISC","radius","spread","maxAge","duration","activeMultiplier","rotation","axis","static","Color","debrisOptions","SPHERE","acceleration","distribution","BOX","wiggle","drag","fireOptions","mistOptions","flashOptions","smokeOptions","smokeLightOptions","bulletOptions","sparkOptions","flashGroup","Group","fireGroup","debrisGroup","shockGroup","mistGroup","smokeGroup","smokeLightGroup","bulletGroup","sparkGroup","addPool","groups","group","renderOrder","frustumCulled","triggerSingleEmitter","follow","velocityFunction","emitter","getFromPool","initialPositions","params","velocities","collisions","bulletLine","targetVec3","chunkReducer","chunkSize","ar","it","ix","attributes","typedArray","array","attributeOffset","activationEnd","reduce","paramsArray","param","construct","pos","Line3","closestPointToPoint","triggerSmallExplosion","alive","disable","releaseIntoPool","enable","triggerExplosion","smoking","missile","smokeEmitter","triggerLightSmoke","tmpVec1","targetVector","gunEmitter","droneMesh","loader","GLTFLoader","loadDroneAssets","gltf","droneFactory","initDroneFactory","targetPositionFinal","Clock","NaN","lastPosition","terrainTiles","raycaster","Raycaster","downVector","offsetVector","lastTimestamp","loops","lookAt","intersectObjects","groundNormal","face","normal","spawnDrone","circle","phase","droneLoop","sin","deadDrone","random","FlyControls","object","domElement","nipple","pointer","setAttribute","movementSpeed","rollSpeed","dragToLook","autoForward","on","nipplemove","updateMovementVector","pointerElement","zone","movements","dims","getContainerDimensions","left","top","pointerVector","move","dx","dy","mousemove","pageX","pageY","scope","fn","contextmenu","preventDefault","mockEvent","radian","tmpQuaternion","Quaternion","moveState","down","right","forward","back","pitchUp","pitchDown","yawLeft","yawRight","rollLeft","rollRight","moveVector","rotationVector","keydown","altKey","keyCode","movementSpeedMultiplier","updateRotationVector","keyup","container","halfWidth","halfHeight","deltaVelocity","deltaPosition","rotMult","multiply","setFromQuaternion","order","offsetWidth","offsetHeight","offsetLeft","offsetTop","removeEventListener","_keydown","_keyup","addEventListener","AutoPilot","ship","controls","active","uturnX","setAcceleration","isMobile","check","userAgent","vendor","opera","test","substr","mobileAndTabletcheck","display","touchPaneLeft","getElementsByClassName","nippleLook","nipplejs","mode","el","buttonX","pressX","fireBullet","button","autoPilot","toggle","constructor","autoRotate","bullet","MeshPhongMaterial","selectNearestTargetInSight","fire","callback","vec","newDir","tmpVec","terrainNormal","reflect","worldToLocal","audioLoader","AudioLoader","impacts","url","weapons","explosions","audioMapper","sound","buffer","setupSound","listener","AudioListener","PositionalAudio","setBuffer","setRefDistance","play","playExplosion","gatlingSound","Audio","setLoop","missileSound","WaterShader","surface","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1","textureMatrix","config","Vector4","waterVertexShader","waterFragmentShader","UnderwaterShader","waterLevel","tDiffuse","tReflectionDepth","worldToClipMatrix","underwaterVertexShader","underwaterFragmentShader","src_renderer","src_scene","src_camera","src_drone","src_sunPosition","src_gui","src_options","queryStringOptions","queryString","parse","location","search","shadows","postprocessing","Scene","PerspectiveCamera","updateMatrixWorld","updateProjectionMatrix","WebGLRenderer","antialias","alpha","logarithmicDepthBuffer","gammaInput","gammaOutput","enabled","bias","PCFSoftShadowMap","autoUpdate","physicallyCorrectLights","toneMapping","Uncharted2ToneMapping","setSize","body","appendChild","gui","dat","GUI","autoPlace","closed","rendererFolder","addFolder","rendererController","low","href","pathname","stringify","lowShadow","lowShadowDoF","high","background","FogExp2","MeshBasicMaterial","sky","setScalar","skyGeo","SphereGeometry","faces","temp","c","skyDome","effectController","inclination","azimuth","sun","guiChanged","theta","phi","folder","onChange","initSky","shadow","mapSize","bottom","far","initLights","waterParameters","waterGeometry","PlaneBufferGeometry","water","Water","textureWidth","textureHeight","flowDirection","normalMap0","normalMap1","clipBias","flowSpeed","waterTarget","WebGLRenderTarget","depthMaterial","MeshDepthMaterial","depthBuffer","depthTexture","DepthTexture","__folders","isWater","underwaterReflector","Reflector","getRenderTarget","ref","setupDrones","particleGroups","shakeCamera","tick","glitch","motionPass","renderToScreen","LOD","underwaterPass","wigglePass","onBeforeRender","item","removeLoop","unshift","setPixelRatio","stats","Stats","dom","composer","EffectComposer","renderPass","RenderPass","addPass","ShaderPass","upass","previousMatrixWorldInverse","previousProjectionMatrix","previousCameraPosition","tmpMatrix","GlitchPass","mainLoop","requestAnimationFrame","getInverse","overrideMaterial","setRenderTarget","dimension","aspect","WindowResize"],"mappings":"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","file":"static/js/main.bb6113d3.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/Rock_08_UV_H_CM_1.da494a88.jpg\";","module.exports = __webpack_public_path__ + \"static/media/Rock_08_UV_H_CM_1_normal.6085c2f7.jpg\";","module.exports = __webpack_public_path__ + \"static/media/GrassGreenTexture_1024.3f1df3f0.jpg\";","module.exports = __webpack_public_path__ + \"static/media/GrassGreenTexture_1024_normal.ce43156e.jpg\";","module.exports = __webpack_public_path__ + \"static/media/Water_1_M_Normal.a33d50da.jpg\";","module.exports = __webpack_public_path__ + \"static/media/Water_2_M_Normal.639428cf.jpg\";","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"static/js/terrain.worker.f5d6880c.js\");\n};","module.exports = \"#define PHYSICAL\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n\\n\\tvarying vec3 vNormal;\\n\\tvarying vec3 vNormal2;\\n\\n#endif\\n\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n#include <envmap_pars_vertex>\\n\\nvoid main() {\\n\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\\n\\n\\tvNormal = normalize( transformedNormal );\\n\\n#endif\\n\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\n\\tvViewPosition = - mvPosition.xyz;\\n\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n\\t#include <envmap_vertex>\\n\\n\\tvNormal2 = normal;\\n}\\n\"","module.exports = \"#define PHYSICAL\\n\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n\\n// ####### custom uniforms #########\\nuniform sampler2D rockTexture;\\nuniform sampler2D rockTextureNormal;\\n// #################################\\n\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\n\\nvarying vec3 vViewPosition;\\nvarying vec3 vWorldPosition;\\nvarying vec3 vNormal2;\\n\\n#ifndef FLAT_SHADED\\n\\n\\tvarying vec3 vNormal;\\n\\n#endif\\n\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars_begin>\\n#include <envmap_physical_pars_fragment>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\nvec4 physicalColor(sampler2D map, sampler2D normalMap, float roughness, float metalness) {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\n\\t// accumulation\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\n\\t// modulation\\n\\t#include <aomap_fragment>\\n\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t// #include <specularmap_fragment>\\n\\t// #include <envmap_fragment>\\n\\t// return vec4(envColor.rgb, 1.0);\\n\\treturn vec4(outgoingLight, diffuseColor.a);\\n}\\n\\nvoid main() {\\n\\n\\t#include <clipping_planes_fragment>\\n\\n\\tvec4 grassColor = physicalColor(map, normalMap, roughness, metalness);\\n\\tvec4 rockColor = physicalColor(rockTexture, rockTextureNormal, 0.4, 0.15);\\n\\tvec3 normal = normalize( vNormal2 );\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\tfloat flatness = dot(normal, vec3(0.0, 0.0, 1.0));\\n\\tvec4 colorTerrain = mix(\\n\\t\\trockColor,\\n\\t\\t// rockColor,\\n\\t\\tgrassColor,\\n\\t\\tsmoothstep(0.6, 0.7, flatness)\\n\\t);\\n\\tgl_FragColor = colorTerrain;\\n\\t// gl_FragColor = vec4(vec3(vWorldPosition.z/100.0), 1.0);\\n\\tvec3 outgoingLight = gl_FragColor.rgb;\\n\\t#include <specularmap_fragment>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4(outgoingLight.rgb, gl_FragColor.a);\\n\\n\\n\\t// gl_FragColor = vec4(material.specularColor, 1.0);\\n\\t// gl_FragColor = vec4(reflectedLight.indirectDiffuse, 1.0);\\n\\t// gl_FragColor = vec4(directLight.direction, 1.0);\\n\\t// // gl_FragColor = texture2D(map, vUv);\\n\\t// gl_FragColor = vec4(normal, 1.0);\\n\\t// gl_FragColor = vec4(material.diffuseColor, 1.0);\\n\\t// gl_FragColor = vec4(metalness, metalness, metalness, 1.0);\\n\\t// gl_FragColor = vec4(diffuseColor.rgb * ( 1.0 - metalnessFactor ), 1.0);\\n\\t// gl_FragColor = vec4(outgoingLight, diffuseColor.a);\\n\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\n\\t//  FOG\\n\\t// #include <fog_fragment>\\n\\treflectVec = refract( cameraToVertex, worldNormal, 1.0 );\\n\\tvec4 fogColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\tfogFactor = mix(fogFactor, fogFactor / 10.0, smoothstep(100.0, 300.0, vWorldPosition.z));\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor.rgb, fogFactor );\\n\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n\\n}\\n\"","module.exports = \"precision highp float;\\nprecision highp int;\\n#define USE_FOG\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 cameraPosition;\\nuniform mat3 uvTransform;\\n\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec2 uv;\\nattribute vec2 uv2;\\n\\nvarying vec3 vViewPosition;\\nvarying vec3 vNormal;\\nvarying vec3 vNormal2;\\nvarying float flatness;\\nvarying vec3 vWorldPosition;\\nvarying vec2 vUv;\\nvarying vec2 vUv2;\\nvarying float fogDepth;\\n\\nvoid main() {\\n\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tvUv2 = uv2;\\n\\n\\tvec3 objectNormal = vec3( normal );\\n\\n\\tvec3 transformedNormal = normalMatrix * objectNormal;\\n\\n\\n\\tvNormal = normalize( transformedNormal );\\n\\n\\tvec3 transformed = vec3( position );\\n\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\n\\tvViewPosition = - mvPosition.xyz;\\n\\n\\t// #include <worldpos_vertex>\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\n\\tfogDepth = -mvPosition.z;\\n\\n\\tvNormal2 = normalize(normal);\\n\\tflatness = dot(normal, vec3(0.0, 0.0, 1.0));\\n  \\tvWorldPosition = position;\\n}\\n\"","module.exports = \"#extension GL_OES_standard_derivatives : enable\\nprecision highp float;\\nprecision highp int;\\n#define SHADER_NAME ShaderMaterial\\n#define STANDARD \\n#define USE_MAP \\n#define USE_NORMALMAP \\n#define GAMMA_FACTOR 2\\n#define USE_FOG\\n#define FOG_EXP2\\n#define PHYSICALLY_CORRECT_LIGHTS\\nuniform mat4 viewMatrix;\\nuniform vec3 cameraPosition;\\n#define TONE_MAPPING\\n#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\\n}\\nvec3 toneMapping( vec3 color ) { return Uncharted2ToneMapping( color ); }\\n\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\\nvec4 mapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }\\nvec4 matcapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }\\nvec4 envMapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }\\nvec4 emissiveMapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }\\nvec4 linearToOutputTexel( vec4 value ) { return LinearToGamma( value, float( GAMMA_FACTOR ) ); }\\n\\n#define STANDARD\\n\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n\\n// ####### custom uniforms #########\\nuniform sampler2D rockTexture;\\nuniform sampler2D rockTextureNormal;\\n// #################################\\n\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\n\\nvarying vec3 vViewPosition;\\nvarying vec3 vWorldPosition;\\nvarying vec3 vNormal2;\\nvarying float flatness;\\n\\n#ifndef FLAT_SHADED\\n\\n\\tvarying vec3 vNormal;\\n\\n#endif\\n\\n#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\n\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\nvec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\\n#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\n\\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\n\\treturn Fr * fresnel + F0;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\n\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if 1 > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ 1 ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if 0 > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ 0 ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if 0 > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ 0 ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if 0 > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ 0 ];\\n#endif\\n#if 1 > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ 1 ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\nstruct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if 0 > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#endif\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearCoatInv = 1.0 - clearCoatDHR;\\n\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec3 singleScattering = vec3( 0.0 );\\n\\t\\tvec3 multiScattering = vec3( 0.0 );\\n\\t\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\t\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\\n\\t\\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\\n\\t\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n\\t#else\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n#ifdef USE_SHADOWMAP\\n\\t#if 1 > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ 1 ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ 1 ];\\n\\t#endif\\n\\t#if 0 > 0\\n\\t\\tuniform sampler2D spotShadowMap[ 0 ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ 0 ];\\n\\t#endif\\n\\t#if 0 > 0\\n\\t\\tuniform sampler2D pointShadowMap[ 0 ];\\n\\t\\tvarying vec4 vPointShadowCoord[ 0 ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\\n// #include <normalmap_pars_fragment>\\n#ifdef USE_NORMALMAP\\n\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\n\\t// Per-Pixel Tangent Space Normal Mapping\\n\\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, sampler2D normalMap) {\\n\\n\\t\\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\\n\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\n\\t}\\n\\n#endif\\n\\n#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n#endif\\n#if 0 > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ 0 ];\\n#endif\\n\\nvec4 physicalColor(sampler2D map, sampler2D normalMap, float roughness, float metalness) {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\n\\tvec2 vUvXY = vec2(mod(vWorldPosition.x, 100.0) / 100.0, mod(vWorldPosition.y, 100.0) / 100.0 );\\n\\tvec2 vUvXZ = vec2(mod(vWorldPosition.x, 100.0) / 100.0 , mod(vWorldPosition.z, 100.0) / 100.0 );\\n\\tvec2 vUvYZ = vec2(mod(vWorldPosition.y, 100.0) / 100.0 , mod(vWorldPosition.z, 100.0) / 100.0 );\\n\\n\\tvec3 mixer = clamp(abs(vNormal2), 0.0, 1.0);\\n\\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\\n\\n\\t// #include <map_fragment>\\n\\tvec4 texelColorXY = texture2D( map, vUvXY );\\n\\tvec4 texelColorXZ = texture2D( map, vUvXZ );\\n\\tvec4 texelColorYZ = texture2D( map, vUvYZ );\\n\\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\n\\tvec4 texelColor = (\\n\\t\\tmix(black, texelColorXY, pow(mixer.z, 2.5)) +\\n\\t\\tmix(black, texelColorXZ, pow(mixer.y, 2.5)) +\\n\\t\\tmix(black, texelColorYZ, pow(mixer.x, 2.5))\\n\\t);\\n\\t// texelColor = texelColorXY;\\n\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n\\t// return diffuseColor;\\n\\n\\nvec3 normal = normalize( vNormal );\\nnormal = perturbNormal2Arb( -vViewPosition, normal, normalMap);\\n\\n\\t// accumulation\\nPhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalness );\\nmaterial.specularRoughness = clamp( roughness, 0.04, 1.0 );\\nmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalness );\\n\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n\\n#if ( 1 > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t\\n\\t\\tdirectionalLight = directionalLights[ 0 ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ 0 ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\\t#if ( 1 > 0 )\\n\\t\\t\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry );\\n\\t\\t\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n#endif\\n\\n#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t// #include <specularmap_fragment>\\n\\t// #include <envmap_fragment>\\n\\t// return vec4(envColor.rgb, 1.0);\\n\\treturn vec4(outgoingLight, diffuseColor.a);\\n}\\n\\nvoid main() {\\n\\n\\tvec4 grassColor = physicalColor(map, normalMap, roughness, metalness);\\n\\tvec4 rockColor = physicalColor(rockTexture, rockTextureNormal, 0.4, 0.15);\\n\\tvec4 colorTerrain = mix(\\n\\t\\trockColor,\\n\\t\\tgrassColor,\\n\\t\\tsmoothstep(0.6, 0.7, flatness)\\n\\t);\\n\\tgl_FragColor = colorTerrain;\\n\\t// gl_FragColor = vec4(vec3(vWorldPosition.z/100.0), 1.0);\\n\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n\\tgl_FragColor = linearToOutputTexel( gl_FragColor );\\n\\n\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n\\n\\t// gl_FragColor = vec4(normal, 1.0);\\n\\n}\\n\"","module.exports = \"#define STANDARD\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n\\n\\tvarying vec3 vNormal;\\n\\n#endif\\n\\nvarying vec3 vNormal2;\\nvarying float flatness;\\nvarying vec3 vWorldPosition;\\nvarying vec2 vNoise;\\n\\n\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\n\\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\\n\\nfloat noise(vec3 p){\\n    vec3 a = floor(p);\\n    vec3 d = p - a;\\n    d = d * d * (3.0 - 2.0 * d);\\n\\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\\n    vec4 k1 = perm(b.xyxy);\\n    vec4 k2 = perm(k1.xyxy + b.zzww);\\n\\n    vec4 c = k2 + a.zzzz;\\n    vec4 k3 = perm(c);\\n    vec4 k4 = perm(c + 1.0);\\n\\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\\n\\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\\n\\n    return o4.y * d.y + o4.x * (1.0 - d.y);\\n}\\n\\n\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\nvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\\n\\nfloat cnoise(vec4 P){\\n  vec4 Pi0 = floor(P); // Integer part for indexing\\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\\n  Pi0 = mod(Pi0, 289.0);\\n  Pi1 = mod(Pi1, 289.0);\\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = vec4(Pi0.zzzz);\\n  vec4 iz1 = vec4(Pi1.zzzz);\\n  vec4 iw0 = vec4(Pi0.wwww);\\n  vec4 iw1 = vec4(Pi1.wwww);\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n  vec4 ixy00 = permute(ixy0 + iw0);\\n  vec4 ixy01 = permute(ixy0 + iw1);\\n  vec4 ixy10 = permute(ixy1 + iw0);\\n  vec4 ixy11 = permute(ixy1 + iw1);\\n\\n  vec4 gx00 = ixy00 / 7.0;\\n  vec4 gy00 = floor(gx00) / 7.0;\\n  vec4 gz00 = floor(gy00) / 6.0;\\n  gx00 = fract(gx00) - 0.5;\\n  gy00 = fract(gy00) - 0.5;\\n  gz00 = fract(gz00) - 0.5;\\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\\n  vec4 sw00 = step(gw00, vec4(0.0));\\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\\n\\n  vec4 gx01 = ixy01 / 7.0;\\n  vec4 gy01 = floor(gx01) / 7.0;\\n  vec4 gz01 = floor(gy01) / 6.0;\\n  gx01 = fract(gx01) - 0.5;\\n  gy01 = fract(gy01) - 0.5;\\n  gz01 = fract(gz01) - 0.5;\\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\\n  vec4 sw01 = step(gw01, vec4(0.0));\\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\\n\\n  vec4 gx10 = ixy10 / 7.0;\\n  vec4 gy10 = floor(gx10) / 7.0;\\n  vec4 gz10 = floor(gy10) / 6.0;\\n  gx10 = fract(gx10) - 0.5;\\n  gy10 = fract(gy10) - 0.5;\\n  gz10 = fract(gz10) - 0.5;\\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\\n  vec4 sw10 = step(gw10, vec4(0.0));\\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\\n\\n  vec4 gx11 = ixy11 / 7.0;\\n  vec4 gy11 = floor(gx11) / 7.0;\\n  vec4 gz11 = floor(gy11) / 6.0;\\n  gx11 = fract(gx11) - 0.5;\\n  gy11 = fract(gy11) - 0.5;\\n  gz11 = fract(gz11) - 0.5;\\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\\n  vec4 sw11 = step(gw11, vec4(0.0));\\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\\n\\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\\n\\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\\n  g0000 *= norm00.x;\\n  g0100 *= norm00.y;\\n  g1000 *= norm00.z;\\n  g1100 *= norm00.w;\\n\\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\\n  g0001 *= norm01.x;\\n  g0101 *= norm01.y;\\n  g1001 *= norm01.z;\\n  g1101 *= norm01.w;\\n\\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\\n  g0010 *= norm10.x;\\n  g0110 *= norm10.y;\\n  g1010 *= norm10.z;\\n  g1110 *= norm10.w;\\n\\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\\n  g0011 *= norm11.x;\\n  g0111 *= norm11.y;\\n  g1011 *= norm11.z;\\n  g1111 *= norm11.w;\\n\\n  float n0000 = dot(g0000, Pf0);\\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\\n  float n1111 = dot(g1111, Pf1);\\n\\n  vec4 fade_xyzw = fade(Pf0);\\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\\n  return 2.2 * n_xyzw;\\n}\\n\\n\\nvoid main() {\\n\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\\n\\n\\tvNormal = normalize( transformedNormal );\\n\\n#endif\\n\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\n\\tvViewPosition = - mvPosition.xyz;\\n\\n\\t// transformed = floor(transformed);\\n\\n\\t// #include <worldpos_vertex>\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n\\n\\tvNormal2 = normalize(normal);\\n\\tflatness = dot(normal, vec3(0.0, 0.0, 1.0));\\n\\tvWorldPosition = position;\\n\\t// uvnoise = vec2(\\n\\t// \\t// (sin((position.x + position.y + position.z) + / 30.0)) * 0.3333332,\\n\\n\\t// \\t// (sin(position.x / 10.0) + sin(position.y / 10.0) + sin(1.5 + position.z / 10.0)) * 0.3333332,\\n\\t// \\t// (sin(position.x / 10.0) + sin(position.y / 10.0) + sin(1.5 + position.z / 10.0)) * 0.3333332\\n\\n\\t// \\t// mod((position.x + position.y + position.z), 10.0) / 10.0,\\n\\t// \\t// mod((position.x + position.y + position.z), 10.0) / 10.0\\n\\n\\t// \\t// mod(mod(position.x, 1.0) + position.z, 1.0),\\n\\t// \\t// mod(mod(position.y, 1.0) + position.z, 1.0)\\n\\n\\t// \\t// mod(position.x + 0.5 * cnoise(vec4(position, 1.0)), 10.0) / 10.0,\\n\\t// \\t// mod(position.y + 0.5 * cnoise(vec4(position.zyx, 1.0)), 10.0) / 10.0\\n\\n  vNoise = vec2(\\n    noise(position / 50.0),\\n    noise(position.zyx / 50.0)\\n  );\\n\\n\\t// \\t// cos(position / 5.0) * 0.5 + 0.5,\\n\\t// \\t// cos(position.zyx / 5.0) * 0.5 + 0.5\\n\\n\\t// \\t// noise(position.xyz) * mod(position.z, 10.0) / 10.0,\\n\\t// \\t// noise(position.zyx) * mod(position.z, 10.0) / 10.0\\n\\t// );\\n\\t// vUv = uvnoise;\\n\\n\\t// vec2 vUvXY = vec2(mod(position.x, 100.0) / 100.0, mod(position.y, 100.0) / 100.0 );\\n\\t// vec2 vUvXZ = vec2(mod(position.x, 100.0) / 100.0 , mod(position.z, 100.0) / 100.0 );\\n\\t// vec2 vUvYZ = vec2(mod(position.y, 100.0) / 100.0 , mod(position.z, 100.0) / 100.0 );\\n\\n\\t// vec3 mixer = clamp(abs(normal), 0.0000001, 1.0);\\n\\t// vec2 zero2 = vec2(0.0, 0.0);\\n\\t// vUv = (\\n\\t// \\tmix(zero2, vUvXY, pow(mixer.z, 2.5)) +\\n\\t// \\tmix(zero2, vUvXZ, pow(mixer.y, 2.5)) +\\n\\t// \\tmix(zero2, vUvYZ, pow(mixer.x, 2.5))\\n\\t// );\\n}\\n\"","module.exports = \"#define STANDARD\\n\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n\\n// ####### custom uniforms #########\\nuniform sampler2D rockTexture;\\nuniform sampler2D rockTextureNormal;\\n// #################################\\n\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\n\\nvarying vec3 vViewPosition;\\nvarying vec3 vWorldPosition;\\nvarying vec2 vNoise;\\nvarying vec3 vNormal2;\\nvarying float flatness;\\n\\n#ifndef FLAT_SHADED\\n\\n\\tvarying vec3 vNormal;\\n\\n#endif\\n\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars_begin>\\n#include <envmap_physical_pars_fragment>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n\\n// #include <normalmap_pars_fragment>\\n#ifdef USE_NORMALMAP\\n\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\n\\t// Per-Pixel Tangent Space Normal Mapping\\n\\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 vUv1, vec2 vUv2, vec2 vUv3) {\\n\\n\\t\\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\\n\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\n\\t\\tvec3 mapN1 = texture2D( normalMap, vUv1 ).xyz;\\n\\t\\tvec3 mapN2 = texture2D( normalMap, vUv2 ).xyz;\\n\\t\\tvec3 mapN3 = texture2D( normalMap, vUv3 ).xyz;\\n\\t\\tvec3 black = vec3(0.0, 0.0, 0.0);\\n\\t\\tvec3 mapN = (\\n\\t\\t\\tmix(black, mapN1, pow(N.z, 2.5)) +\\n\\t\\t\\tmix(black, mapN2, pow(N.y, 2.5)) +\\n\\t\\t\\tmix(black, mapN3, pow(N.x, 2.5))\\n\\t\\t);\\n\\t\\t// return mapN;\\n\\t\\tmapN = mapN * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\n\\t}\\n\\n#endif\\n\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\nvec4 physicalColor(sampler2D map, sampler2D normalMap, float roughness, float metalness) {\\n\\n\\t// return vec4(vUv, 0.0, 1.0);\\n\\t// return vec4(clamp(vNormal2.z, 0.0, 1.0), 0.0, 0.0, 1.0);\\n\\t// return vec4(cos(vWorldPosition.xyz / 5.0) * 0.5 + 0.5, 1.0);\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\n\\tvec2 vUvXY = vec2(mod(vWorldPosition.x, 100.0) / 100.0, mod(vWorldPosition.y, 100.0) / 100.0 );\\n\\tvec2 vUvXZ = vec2(mod(vWorldPosition.x, 100.0) / 100.0 , mod(vWorldPosition.z, 100.0) / 100.0 );\\n\\tvec2 vUvYZ = vec2(mod(vWorldPosition.y, 100.0) / 100.0 , mod(vWorldPosition.z, 100.0) / 100.0 );\\n\\n\\tvec3 mixer = clamp(abs(vNormal2), 0.0, 1.0);\\n\\n\\t#include <logdepthbuf_fragment>\\n\\n\\t// #include <map_fragment>\\n\\tvec4 texelColorXY = texture2D( map, vUvXY );\\n\\tvec4 texelColorXZ = texture2D( map, vUvXZ );\\n\\tvec4 texelColorYZ = texture2D( map, vUvYZ );\\n\\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\n\\tvec4 texelColor = (\\n\\t\\tmix(black, texelColorXY, pow(mixer.z, 2.5)) +\\n\\t\\tmix(black, texelColorXZ, pow(mixer.y, 2.5)) +\\n\\t\\tmix(black, texelColorYZ, pow(mixer.x, 2.5))\\n\\t);\\n\\t// texelColor = texelColorXY;\\n\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n\\t// return diffuseColor;\\n\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t// #include <normal_fragment_maps>\\n\\t// normal = perturbNormal2Arb( -vViewPosition, normal , vUvXY, vUvXZ, vUvYZ);\\n\\t// return vec4(normal, 1.0);\\n\\t// #include <emissivemap_fragment>\\n\\n\\t// accumulation\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\n\\t// modulation\\n\\t// #include <aomap_fragment>\\n\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t// #include <specularmap_fragment>\\n\\t// #include <envmap_fragment>\\n\\t// return vec4(envColor.rgb, 1.0);\\n\\treturn vec4(outgoingLight, diffuseColor.a);\\n}\\n\\nvoid main() {\\n\\n\\t#include <clipping_planes_fragment>\\n\\n\\tvec4 grassColor = physicalColor(map, normalMap, roughness, metalness);\\n\\tvec4 rockColor = physicalColor(rockTexture, rockTextureNormal, 0.4, 0.15);\\n\\tvec4 colorTerrain = mix(\\n\\t\\trockColor,\\n\\t\\tgrassColor,\\n\\t\\tsmoothstep(0.15, 0.3, flatness * vNoise.x + flatness * vNoise.y)\\n\\t\\t// smoothstep(vNoise.x, vNoise.y, flatness)\\n\\t);\\n\\tgl_FragColor = colorTerrain;\\n\\t// gl_FragColor = vec4(vec3(vWorldPosition.z/100.0), 1.0);\\n\\tvec3 outgoingLight = gl_FragColor.rgb;\\n\\t#include <specularmap_fragment>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4(outgoingLight.rgb, gl_FragColor.a);\\n\\n\\n\\t// gl_FragColor = vec4(material.specularColor, 1.0);\\n\\t// gl_FragColor = vec4(reflectedLight.indirectDiffuse, 1.0);\\n\\t// gl_FragColor = vec4(directLight.direction, 1.0);\\n\\t// // gl_FragColor = texture2D(map, vUv);\\n\\t// gl_FragColor = vec4(normal, 1.0);\\n\\t// gl_FragColor = vec4(material.diffuseColor, 1.0);\\n\\t// gl_FragColor = vec4(metalness, metalness, metalness, 1.0);\\n\\t// gl_FragColor = vec4(diffuseColor.rgb * ( 1.0 - metalnessFactor ), 1.0);\\n\\t// gl_FragColor = vec4(outgoingLight, diffuseColor.a);\\n\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\n\\t#include <fog_fragment>\\n\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n\\n\\t// gl_FragColor = vec4(flatness, flatness, flatness, 1.0);\\n\\n}\\n\"","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"static/js/voxel.worker.626df7dc.js\");\n};","module.exports = \"#include <common>\\n#include <fog_pars_fragment>\\n\\nuniform sampler2D tReflectionMap;\\nuniform sampler2D tRefractionMap;\\nuniform sampler2D tNormalMap0;\\nuniform sampler2D tNormalMap1;\\nuniform sampler2D tDepth;\\n\\n#ifdef USE_FLOWMAP\\nuniform sampler2D tFlowMap;\\n#else\\nuniform vec2 flowDirection;\\n#endif\\n\\nuniform vec3 color;\\nuniform float reflectivity;\\nuniform float surface;\\nuniform vec4 config;\\nuniform mat4 clipToWorldMatrix;\\n\\nvarying vec4 vCoord;\\nvarying vec2 vUv;\\nvarying vec3 vToEye;\\n\\nvec3 surfaceColor = vec3(0.0078, 0.5176, 0.7);\\nvec3 shoreColor = vec3(0.0078, 0.5176, 0.7);\\nvec3 depthColor = vec3(0.0039, 0.00196, 0.145);\\n// Description : Water color based on water depth and color extinction\\n//\\n// based on Rendering Water as a Post-process Effect by Wojciech Toman\\n//\\n\\n// waterTransparency - x = , y = water visibility along eye vector,\\n// waterDepthValues - x = water depth in world space, y = view/accumulated water depth in world space\\nvec3 DepthRefraction(float waterDepth, float viewWaterDepth, vec3 refractionColor)\\n{\\n  float waterClarity = 0.75;\\n  float visibility = 200.;\\n  float shoreRange = 50.;\\n  float horizontalExtinction = 200.;\\n\\n  float accDepth = viewWaterDepth * waterClarity; // accumulated water depth\\n  float accDepthExp = saturate(accDepth / (2.5 * visibility));\\n  accDepthExp *= (1.0 - accDepthExp) * accDepthExp * accDepthExp + 1.0; // out cubic\\n\\n  surfaceColor = mix(shoreColor, surfaceColor, saturate(waterDepth / shoreRange));\\n  vec3 waterColor = mix(surfaceColor, depthColor, saturate(waterDepth / horizontalExtinction));\\n\\n  refractionColor = mix(refractionColor, surfaceColor * waterColor, saturate(accDepth / visibility));\\n  refractionColor = mix(refractionColor, depthColor, accDepthExp);\\n  refractionColor = mix(refractionColor, depthColor * waterColor, saturate(waterDepth / horizontalExtinction));\\n  return refractionColor;\\n}\\n\\nvoid main() {\\n\\n  float flowMapOffset0 = config.x;\\n  float flowMapOffset1 = config.y;\\n  float halfCycle = config.z;\\n  float scale = config.w;\\n\\n  vec3 toEye = normalize( vToEye );\\n  vec3 surfacePosition = cameraPosition - vToEye;\\n\\n  // determine flow direction\\n  vec2 flow;\\n  #ifdef USE_FLOWMAP\\n  flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\\n  #else\\n  flow = flowDirection;\\n  #endif\\n  flow.x *= - 1.0;\\n\\n  // sample normal maps (distort uvs with flowdata)\\n  vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\\n  vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\\n\\n  // linear interpolate to get the final normal color\\n  float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\\n  vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\\n\\n  // calculate normal vector\\n  //  vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\\n  vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0,  normalColor.g * 2.0 - 1.0, normalColor.b ));\\n\\n  // calculate the fresnel term to blend reflection and refraction maps\\n  float theta = max( dot( toEye, normal ), 0.0 );\\n  float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\\n\\n  // calculate final uv coords\\n  vec3 coord = vCoord.xyz / vCoord.w;\\n  vec2 uv = coord.xy + coord.z * normal.xy * 0.1;\\n\\n  vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\\n  vec4 refractColor = texture2D( tRefractionMap, uv );\\n\\n  // water depth\\n\\n  float zOverW = texture2D(tDepth, coord.xy).x;\\n  // clipPosition is the viewport position at this pixel in the range -1 to 1.\\n  vec4 clipPosition = vec4(coord.xy * 2. - 1., zOverW * 2. - 1., 1.);\\n  vec4 worldPosition = clipToWorldMatrix * clipPosition;\\n  worldPosition /= worldPosition.w;\\n\\n  float waterDepth = surfacePosition.z - worldPosition.z;\\n  float viewWaterDepth = length(surfacePosition - worldPosition.xyz);\\n\\n  float depthDensity = 0.01;\\n  float depthFactor = whiteCompliment( exp2( - depthDensity * depthDensity * viewWaterDepth * viewWaterDepth * LOG2 ) );\\n  refractColor.rgb = mix( refractColor.rgb, depthColor, depthFactor );\\n  // refractColor.rgb = DepthRefraction(waterDepth, viewWaterDepth, refractColor.rgb);\\n\\n  // multiply water color with the mix of both textures\\n  gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\\n  // gl_FragColor = refractColor;\\n  // gl_FragColor = vec4(vec3(waterDepth/500.), 1.0);\\n\\n  // #include <tonemapping_fragment>\\n  // #include <encodings_fragment>\\n  // #include <fog_fragment>\\n\\n}\"","module.exports = \"#include <fog_pars_vertex>\\n\\nuniform mat4 textureMatrix;\\n\\nvarying vec4 vCoord;\\nvarying vec2 vUv;\\nvarying vec3 vToEye;\\n\\nvoid main() {\\n\\n  vUv = uv;\\n  vCoord = textureMatrix * vec4( position, 1.0 );\\n\\n  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n  vToEye = cameraPosition - worldPosition.xyz;\\n\\n  vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\\n  gl_Position = projectionMatrix * mvPosition;\\n\\n  #include <fog_vertex>\\n\\n}\"","module.exports = \"#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n\\nuniform sampler2D tDiffuse;\\nuniform sampler2D tDepth;\\nuniform sampler2D tReflectionMap;\\nuniform sampler2D tReflectionDepth;\\nuniform sampler2D tNormalMap0;\\nuniform sampler2D tNormalMap1;\\n\\n#ifdef USE_FLOWMAP\\nuniform sampler2D tFlowMap;\\n#else\\nuniform vec2 flowDirection;\\n#endif\\n\\nuniform vec3 color;\\nuniform float reflectivity;\\nuniform float time;\\nuniform float waterLevel;\\nuniform vec4 config;\\nuniform vec3 sunPosition;\\nuniform mat4 clipToWorldMatrix;\\nuniform mat4 worldToClipMatrix;\\n\\nvarying vec4 vCoord;\\nvarying vec2 vUv;\\nvarying vec3 vToEye;\\n\\n// vec3 depthColor = vec3(0.0039, 0.00196, 0.145);\\nvec3 depthColor = vec3(0.0117, 0.0117, 0.325);\\n\\n#define TAU 6.28318530718\\n#define MAX_ITER 5\\nvec3 caustic(vec2 uv) {\\n  vec2 p = mod(uv*TAU, TAU)-250.0;\\n\\n  vec2 i = vec2(p);\\n  float c = 1.0;\\n  float inten = .005;\\n\\n  for (int n = 0; n < MAX_ITER; n++) {\\n    float t = time * (1.0 - (3.5 / float(n+1)));\\n    i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\\n    c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\\n  }\\n\\n  c /= float(MAX_ITER);\\n  c = 1.17-pow(c, 1.4);\\n  vec3 color = vec3(pow(abs(c), 8.0));\\n  // color = clamp(color + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\\n  color = mix(color, vec3(1.0,1.0,1.0),0.5);\\n\\n  return color;\\n}\\n\\nfloat causticX(float x, float power, float gtime) {\\n  float p = mod(x*TAU, TAU)-250.0;\\n\\n  float i = p;;\\n  float c = 1.0;\\n  float inten = .005;\\n\\n  for (int n = 0; n < MAX_ITER/2; n++) {\\n    float t = gtime * (1.0 - (3.5 / float(n+1)));\\n    i = p + cos(t - i) + sin(t + i);\\n    c += 1.0/length(p / (sin(i+t)/inten));\\n  }\\n  c /= float(MAX_ITER);\\n  c = 1.17-pow(c, power);\\n\\n  return c;\\n}\\n\\nfloat GodRays(vec2 uv) {\\n  float light = 0.0;\\n  vec4 uvSun = worldToClipMatrix * vec4(sunPosition, 1.);\\n  uvSun /= uvSun.w;\\n  uvSun = uvSun / 2. + 0.5;\\n  vec2 uv2 = vec2(\\n    dot(normalize(uv - uvSun.xy), vec2(1., 0.)),\\n    length(uv - uvSun.xy)\\n  );\\n\\n  light += pow(causticX((uv2.x + 0.08 * uv2.y) / 1.7 + 0.5, 1.8, time * 0.65), 10.0) * 0.05;\\n  light += pow(causticX(sin(uv2.x), 0.3, time * 0.7), 9.0) * 0.4;\\n  light += pow(causticX(cos(uv2.x * 2.3), 0.3, time * 1.3), 4.0) * 0.1;\\n\\n  light *= smoothstep(0., .3, uv2.y) * smoothstep(0., .3, uv2.y);\\n  light = clamp(light, 0.0, 1.0);\\n\\n  return light;\\n}\\n\\n#define HASHSCALE1 .1031\\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\\nfloat hash11(float p)\\n{\\n  vec3 p3  = fract(vec3(p) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\nvec3 hash33(vec3 p3)\\n{\\n  p3 = fract(p3 * HASHSCALE3);\\n    p3 += dot(p3, p3.yxz+19.19);\\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\\n}\\n\\nconst int   STAR_VOXEL_STEPS = 8;\\nconst float STAR_VOXEL_STEP_SIZE = 3.;\\n\\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\\n    h = dot(p - ro, rd);\\n    return length(p - ro - rd * h);\\n}\\nvec3 getDotColour(float t)\\n{\\n  return vec3(t*.57,t*.3,t*.05);\\n  return vec3(t*.9,t*.9,t*.9);\\n  return vec3(t*.3,t*.6,t*.5);\\n}\\n\\n// This code is the starfield stuff from iapafoto\\n// https://www.shadertoy.com/view/Xl2BRR\\nvec4 detritus(in vec3 ro, in vec3 rd, in float tmax) {\\n\\n  float d =  0.;\\n\\n  vec3 ros = ro + rd*d;\\n  ros /= STAR_VOXEL_STEP_SIZE;\\n  vec3 pos = floor(ros),\\n       mm, ri = 1./rd,\\n       rs = sign(rd),\\n       dis = (pos - ros + 0.5 + rs * 0.5) * ri;\\n\\n  float dint;\\n  vec3 offset, id;\\n  vec4 col = vec4(0);\\n  vec4 sum = vec4(0);\\n\\n  for(int i = 0; i < STAR_VOXEL_STEPS; i++) {\\n    id = hash33(pos);\\n    float size  = hash11(float(i))*.02 + .005;\\n    offset = clamp(id + .2 * cos(id + id.x * time), size, 1. - size);\\n    d = distanceRayPoint(ros, rd, pos + offset, dint);\\n\\n    if (dint > 0. && dint * STAR_VOXEL_STEP_SIZE < tmax) {\\n      col = vec4(getDotColour(id.x), .8) * smoothstep(size, 0.0, d);\\n      col.a *= smoothstep(float(STAR_VOXEL_STEPS), 0., dint);\\n      col.rgb *= col.a / dint;\\n      sum += (1. - sum.a) * col;\\n      if (sum.a>.99) break;\\n    }\\n\\n    mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\\n    dis += mm * rs * ri;\\n    pos += mm * rs;\\n  }\\n\\n  return sum * .75;\\n}\\n\\n\\nvoid main() {\\n\\n  float flowMapOffset0 = config.x;\\n  float flowMapOffset1 = config.y;\\n  float halfCycle = config.z;\\n  float scale = config.w;\\n\\n  float depth = texture2D(tDepth, vUv).x;\\n  float w;\\n  // float logDepthBufFC = 2.0 / log2( 1000000. + 1.0 );\\n  // float w = pow(2.0, (2. * depth / logDepthBufFC)) - 1.0;\\n  // depth = viewZToPerspectiveDepth(-w, 1., 1000000.);\\n\\n  vec4 world = clipToWorldMatrix * vec4(vUv * 2. - 1., depth * 2. - 1., 1.0);\\n  world /= world.w;\\n  float worldDistance = length(world.xyz - cameraPosition);\\n\\n  vec3 dir = normalize(world.xyz - cameraPosition);\\n  vec3 hitPoint = linePlaneIntersect(cameraPosition, dir, vec3(0., 0., waterLevel), vec3(0., 0., -1.));\\n  float hitDirection = dot(hitPoint - cameraPosition, dir);\\n  float hitDistance = hitDirection > 0. ? length(hitPoint - cameraPosition) : 1e7;\\n\\n  float dist = min(hitDistance, worldDistance);\\n  float fogDensity = 0.007;\\n  float fogFactor;\\n  vec3 nearestPoint = dist == hitDistance ? hitPoint : world.xyz;\\n  float waterDepth = waterLevel - nearestPoint.z;\\n\\n  // sample normal maps (distort uvs with flowdata)\\n  vec2 nUV = fract(hitPoint.xy / 15.);\\n  vec2 flow = vec2(1., 1.);\\n  vec4 normalColor0 = texture2D( tNormalMap0, nUV + flow * time / 10.);\\n  vec4 normalColor1 = texture2D( tNormalMap1, nUV + flow * time / 10.);\\n\\n  // linear interpolate to get the final normal color\\n  float flowLerp = sin(time) / 2. + 0.5;\\n  vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\\n\\n  // calculate normal vector\\n  vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0,  normalColor.g * 2.0 - 1.0, -normalColor.b ));\\n  vec3 waterNormal = normalize(normal);\\n  vec4 coord = worldToClipMatrix * vec4(hitPoint.xy + waterNormal.xy * waterNormal.z * 3., hitPoint.z, 1.0);\\n  coord /= coord.w;\\n  coord = coord / 2.0 + 0.5;\\n  // coord.xy = vUv;\\n\\n  if (worldDistance < hitDistance) {\\n    gl_FragColor = texture2D(tDiffuse, vUv);\\n    gl_FragColor.rgb *= caustic(nearestPoint.xy / 10.);\\n  } else {\\n\\n    // calculate the fresnel term to blend reflection and refraction maps\\n    float theta = max( dot( -dir, waterNormal ), 0.0 );\\n    float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\\n    reflectance = (1. - length(refract(dir, waterNormal, 1.33))) * reflectance;\\n    reflectance = clamp(reflectance, 0.15, 0.85);\\n\\n    vec4 reflectColor = texture2D( tReflectionMap, vec2(1. - coord.x, coord.y) );\\n    vec4 reflectDepth = texture2D( tReflectionDepth, vec2(1.0 - coord.x, coord.y) );\\n    vec4 refractColor = texture2D( tDiffuse, coord.xy );\\n\\n    // w = pow(2.0, (2. * reflectDepth.x / logDepthBufFC)) - 1.0;\\n    // w = -perspectiveDepthToViewZ(reflectDepth.x, 1., 1000000.);\\n    // reflectDepth.x = viewZToPerspectiveDepth(-w, 1., 1000000.);\\n    w = 500. * reflectDepth.x + dist;\\n\\n    fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * w * w * LOG2 ) );\\n    reflectColor.rgb = mix(reflectColor.rgb, depthColor, fogFactor);\\n\\n    // multiply water color with the mix of both textures\\n    gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\\n    // gl_FragColor = vec4(vec3(reflectance), 1.0);\\n    // gl_FragColor = reflectColor;\\n    // gl_FragColor = reflectDepth;\\n    // gl_FragColor = vec4(vec3(w/500.), 1.0);\\n    // gl_FragColor = vec4(vec3(w/100.), 1.0);\\n\\n}\\n\\n// float fogDepth = dist + waterDepth * min(1., waterDepth / 100.);\\nfloat fogDepth = dist + clamp(waterLevel - cameraPosition.z, 0., 100.);\\nfogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\ngl_FragColor.rgb = mix(gl_FragColor.rgb, depthColor, fogFactor);\\n\\ngl_FragColor.rgb += GodRays(vUv) * (1. - smoothstep(0., 100., waterLevel - cameraPosition.z));\\n\\nvec4 star = detritus(cameraPosition, dir,  min(40., dist / STAR_VOXEL_STEP_SIZE));\\ngl_FragColor.rgb = gl_FragColor.rgb * (1.0 - star.a)+star.rgb;\\n\\n\\n// gl_FragColor = texture2D(tReflectionMap, vec2(1.0 - vUv.x, vUv.y));\\n// gl_FragColor = vec4(dir, 1.);\\n// gl_FragColor = vec4( vec3(dist /1000.), 1.0 );\\n// gl_FragColor = vec4( vec3(hitDistance/100.), 1.0 );\\n// gl_FragColor = vec4( vec3(dist/100.), 1.0 );\\n\\n}\"","module.exports = \" #include <fog_pars_vertex>\\n\\nuniform mat4 textureMatrix;\\n\\nvarying vec4 vCoord;\\nvarying vec2 vUv;\\nvarying vec3 vToEye;\\n\\nvoid main() {\\n\\nvUv = uv;\\nvCoord = textureMatrix * vec4( position, 1.0 );\\n\\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\nvToEye = cameraPosition - worldPosition.xyz;\\n\\nvec4 mvPosition = viewMatrix * worldPosition; // used in fog_vertex\\ngl_Position = projectionMatrix * mvPosition;\\n\\n#include <fog_vertex>\\n\\n}\"","module.exports = __webpack_public_path__ + \"static/media/GrassGreenTexture0003.78621f63.jpg\";","module.exports = __webpack_public_path__ + \"static/media/GrassGreenTexture0003_normal.002f20c3.jpg\";","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Qzk3MDg1MDY1MzMzMTFFMDkwN0M4OEMxQ0JGNjFGQkIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Qzk3MDg1MDc1MzMzMTFFMDkwN0M4OEMxQ0JGNjFGQkIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDOTcwODUwNDUzMzMxMUUwOTA3Qzg4QzFDQkY2MUZCQiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDOTcwODUwNTUzMzMxMUUwOTA3Qzg4QzFDQkY2MUZCQiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Po4pkJAAAA9KSURBVHja7F0JdqMw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\"","// THREE.js dependecies from SPE\nexport {\n  BufferAttribute,\n  REVISION,\n  ShaderChunk,\n  Vector2,\n  Vector3,\n  Vector4,\n  Color,\n  Texture,\n  Math,\n  AdditiveBlending,\n  ShaderMaterial,\n  BufferGeometry,\n  Points\n} from 'three'\n","module.exports = __webpack_public_path__ + \"static/media/Explosion_002_Tile_8x8_256x256.d28fc70f.png\";","module.exports = __webpack_public_path__ + \"static/media/smokeparticle.4939a8d2.png\";","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gIBEhghhPTbNQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABF0lEQVQ4y62TsU7DQBBE39opHKS4AuUrkjKlC/qUlPxcSij5A5cuyVdYSZVIGCGZoRlLF8sBJDjpdNZ6Zm92bzaYWJKW/hzOFiAi2jE2JshroAJWwNzhDtgDdUS8XiSQFBEh37oBHnzeAYVx78ABaIBnoBnUzJJkG+ARuAdKIE8UFsACuE2SvgySQ9Ja0k7SUVIv6fPK7o3ZuVRmblRlBWVy67g/cqw0tpLUZv6xcs35teYmsdzYFUBmBXPXNkWcSlSYs8z448psks5PpV9wZGwHtIOCvd+5T0BTRIw5mENmQ9Q2ySkBarSH2MnY+sLakraSnvzOHyM/9I4djdkOvNSJTWLbH638f8P0zTgvgBuH3oDz1Dh/AWVJt7banagAAAAAAElFTkSuQmCC\"","module.exports = __webpack_public_path__ + \"static/media/impact1.db06d2c4.ogg\";","module.exports = __webpack_public_path__ + \"static/media/impact2.7d720129.ogg\";","module.exports = __webpack_public_path__ + \"static/media/impact3.7a5b4e82.ogg\";","module.exports = __webpack_public_path__ + \"static/media/impact4.43348926.ogg\";","module.exports = __webpack_public_path__ + \"static/media/gatling.b8ff47f4.ogg\";","module.exports = __webpack_public_path__ + \"static/media/missile.f0faf674.ogg\";","module.exports = __webpack_public_path__ + \"static/media/explosion1.2f1ab236.ogg\";","module.exports = __webpack_public_path__ + \"static/media/explosion2.752472e3.ogg\";","import PubSub from 'pubsub-js'\n\n// PubSub.subscribe('x', (msg, data) => console.log(msg, data))\n\nexport default PubSub\n","/**\n * @author zz85 / https://github.com/zz85\n *\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n*/\nimport {\n  ShaderMaterial,\n  SphereBufferGeometry,\n  Mesh,\n  Vector3,\n  UniformsUtils,\n  BackSide\n} from 'three'\n\nconst Sky = function () {\n  var shader = Sky.SkyShader\n\n  var material = new ShaderMaterial({\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader,\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    side: BackSide\n  })\n\n  Mesh.call(this, new SphereBufferGeometry(1, 32, 15), material)\n}\n\nSky.prototype = Object.create(Mesh.prototype)\n\nSky.SkyShader = {\n\n  uniforms: {\n    luminance: { value: 1 },\n    turbidity: { value: 2 },\n    rayleigh: { value: 1 },\n    mieCoefficient: { value: 0.005 },\n    mieDirectionalG: { value: 0.8 },\n    sunPosition: { value: new Vector3() }\n  },\n\n  vertexShader: `\n        uniform vec3 sunPosition;\n        uniform float rayleigh;\n        uniform float turbidity;\n        uniform float mieCoefficient;\n\n        varying vec3 vWorldPosition;\n        varying vec3 vSunDirection;\n        varying float vSunfade;\n        varying vec3 vBetaR;\n        varying vec3 vBetaM;\n        varying float vSunE;\n\n        const vec3 up = vec3( 0.0, 0.0, 1.0 );\n\n        // constants for atmospheric scattering\n        const float e = 2.71828182845904523536028747135266249775724709369995957;\n        const float pi = 3.141592653589793238462643383279502884197169;\n\n        // wavelength of used primaries, according to preetham\n        const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n        // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n        // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n        const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n        // mie stuff\n        // K coefficient for the primaries\n        const float v = 4.0;\n        const vec3 K = vec3( 0.686, 0.678, 0.666 );\n        // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n        const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n        // earth shadow hack\n        // cutoffAngle = pi / 1.95;\n        const float cutoffAngle = 1.6110731556870734;\n        const float steepness = 1.5;\n        const float EE = 1000.0;\n\n        float sunIntensity( float zenithAngleCos ) {\n        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n        }\n\n        vec3 totalMie( float T ) {\n        float c = ( 0.2 * T ) * 10E-18;\n        return 0.434 * c * MieConst;\n        }\n\n        void main() {\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        vSunDirection = normalize( sunPosition );\n\n        vSunE = sunIntensity( dot( vSunDirection, up ) );\n\n        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.z / 450000.0 ) ), 0.0, 1.0 );\n\n        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n        // extinction (absorbtion + out scattering)\n        // rayleigh coefficients\n        vBetaR = totalRayleigh * rayleighCoefficient;\n\n        // mie coefficients\n        vBetaM = totalMie( turbidity ) * mieCoefficient;\n\n        }\n    `,\n\n  fragmentShader: `\n        varying vec3 vWorldPosition;\n        varying vec3 vSunDirection;\n        varying float vSunfade;\n        varying vec3 vBetaR;\n        varying vec3 vBetaM;\n        varying float vSunE;\n\n        uniform float luminance;\n        uniform float mieDirectionalG;\n\n        const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n        // constants for atmospheric scattering\n        const float pi = 3.141592653589793238462643383279502884197169;\n\n        const float n = 1.0003; // refractive index of air\n        const float N = 2.545E25; // number of molecules per unit volume for air at\n                                    // 288.15K and 1013mb (sea level -45 celsius)\n\n        // optical length at zenith for molecules\n        const float rayleighZenithLength = 8.4E3;\n        const float mieZenithLength = 1.25E3;\n        const vec3 up = vec3( 0.0, 0.0, 1.0 );\n        // 66 arc seconds -> degrees, and the cosine of that\n        const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n        // 3.0 / ( 16.0 * pi )\n        const float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n        // 1.0 / ( 4.0 * pi )\n        const float ONE_OVER_FOURPI = 0.07957747154594767;\n\n        float rayleighPhase( float cosTheta ) {\n        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n        }\n\n        float hgPhase( float cosTheta, float g ) {\n        float g2 = pow( g, 2.0 );\n        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n        }\n\n        // Filmic ToneMapping http://filmicgames.com/archives/75\n        const float A = 0.15;\n        const float B = 0.50;\n        const float C = 0.10;\n        const float D = 0.20;\n        const float E = 0.02;\n        const float F = 0.30;\n\n        const float whiteScale = 1.0748724675633854; // 1.0 / Uncharted2Tonemap(1000.0)\n\n        vec3 Uncharted2Tonemap( vec3 x ) {\n        return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;\n        }\n\n\n        void main() {\n        // optical length\n        // cutoff angle at 90 to avoid singularity in next formula.\n        float zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );\n        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n        float sR = rayleighZenithLength * inverse;\n        float sM = mieZenithLength * inverse;\n\n        // combined extinction factor\n        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n        // in scattering\n        float cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );\n\n        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n        vec3 betaRTheta = vBetaR * rPhase;\n\n        float mPhase = hgPhase( cosTheta, mieDirectionalG );\n        vec3 betaMTheta = vBetaM * mPhase;\n\n        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n        // nightsky\n        vec3 direction = normalize( vWorldPosition - cameraPos );\n        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]\n        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]\n        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n        vec3 L0 = vec3( 0.1 ) * Fex;\n\n        // composition + solar disc\n        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n        vec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );\n        vec3 color = curr * whiteScale;\n\n        vec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n        gl_FragColor = vec4( retColor, 1.0 );\n\n        }`\n\n}\n\nexport {Sky}\n","import {\n  DirectionalLight,\n  HemisphereLight,\n  AmbientLight\n} from 'three'\nimport { drone } from './index'\n\nconst dirLight = new DirectionalLight(0xffffff, 4)\nwindow.dirLight = dirLight\nconst hemishpereLight = new HemisphereLight(0xffffbb, 0x080820, 0.1)\nhemishpereLight.position.set(0, 0, 1)\nhemishpereLight.up.set(0, 0, 1)\nhemishpereLight.needsUpdate = true\nconst ambientLight = new AmbientLight(0x404040, 0.1) // soft white light\n\nconst updateDirLightPosition = () => {\n  dirLight.position.copy(dirLight.sunPosition)\n  dirLight.position.normalize()\n  dirLight.position.multiplyScalar(1600.0)\n  dirLight.position.add(drone.position)\n}\n\nconst initLights = (scene, sunPosition) => {\n  dirLight.sunPosition = sunPosition\n  dirLight.updatePosition = updateDirLightPosition\n  dirLight.updatePosition()\n  dirLight.up.set(0, 0, 1)\n  dirLight.name = 'sunlight'\n\n  dirLight.castShadow = true\n  dirLight.shadow.mapSize.width = dirLight.shadow.mapSize.height = 1024\n  const d = 1024\n  dirLight.shadow.camera.left = -d\n  dirLight.shadow.camera.right = d\n  dirLight.shadow.camera.top = d\n  dirLight.shadow.camera.bottom = -d\n\n  dirLight.shadow.camera.far = 3200\n  dirLight.shadow.bias = -0.0001\n  dirLight.needsUpdate = true\n\n  scene.add(dirLight)\n  scene.add(hemishpereLight)\n  scene.add(ambientLight)\n}\n\nexport { initLights, dirLight, hemishpereLight, ambientLight }\n","import {\n  ShaderMaterial,\n  TextureLoader,\n  RepeatWrapping,\n  UniformsLib,\n  Vector2,\n  Matrix3\n} from 'three'\nimport vertexShader from './meshphysical_vert.glsl'\nimport fragmentShader from './meshphysical_frag.glsl'\n\nconst textureLoader = new TextureLoader().setCrossOrigin('anonymous')\n\nconst rockTexture = textureLoader.load(require('../textures/Rock_08_UV_H_CM_1.jpg'))\nconst rockTextureNormal = textureLoader.load(require('../textures/Rock_08_UV_H_CM_1_normal.jpg'))\n// const rockTexture = textureLoader.load(require('../textures/rock_brown_1600.jpg'))\nconst grassTexture = textureLoader.load(require('../textures/GrassGreenTexture0003.jpg'))\nconst grassTextureNormal = textureLoader.load(require('../textures/GrassGreenTexture0003_normal.jpg'))\n// const grassTexture = textureLoader.load(require('../textures/rainforest512.jpg'))\n// const grassTexture2 = textureLoader.load(require('../textures/Grass_01_UV_H_CM_1.jpg'))\n// const icyTexture = textureLoader.load(require('../textures/snow_scuffed_ground_1.jpg'))\n// const snowTexture = textureLoader.load(require('../textures/Snow_01_UV_H_CM_1.jpg'))\n// const envmapTexture = textureLoader.load(require('../textures/envmap.jpg'))\nrockTexture.wrapS = rockTexture.wrapT = RepeatWrapping\nrockTexture.offset.set(0, 0)\nrockTexture.repeat.set(20, 20)\nrockTextureNormal.wrapS = rockTextureNormal.wrapT = RepeatWrapping\ngrassTexture.wrapS = grassTexture.wrapT = RepeatWrapping\ngrassTextureNormal.wrapS = grassTextureNormal.wrapT = RepeatWrapping\n// grassTexture2.wrapS = grassTexture2.wrapT = RepeatWrapping\n// icyTexture.wrapS = icyTexture.wrapT = RepeatWrapping\n// snowTexture.wrapS = snowTexture.wrapT = RepeatWrapping\n\nconst Material = (options, uniforms) => {\n  const material = new ShaderMaterial({\n    uniforms: {\n      opacity: { value: 1.0 },\n      clearCoat: { value: 0.0 },\n      clearCoatRoughness: { value: 0.0 },\n      roughness: { value: 0.0 },\n      metalness: { value: 0.0 },\n      ...UniformsLib.common,\n      ...UniformsLib.lights,\n      ...UniformsLib.specularMap,\n      ...UniformsLib.envmap,\n      ...UniformsLib.aomap,\n      ...UniformsLib.lightmap,\n      ...UniformsLib.emissivemap,\n      ...UniformsLib.bumpmap,\n      ...UniformsLib.normalmap,\n      ...UniformsLib.displacementmap,\n      ...UniformsLib.roughnessmap,\n      ...UniformsLib.metalnessmap,\n      ...UniformsLib.gradientmap,\n      ...UniformsLib.fog,\n      ...UniformsLib.points,\n      // spectral: {value: spectralTexture},\n      rockTexture: { value: rockTexture },\n      rockTextureNormal: { value: rockTextureNormal },\n      // grassTexture: {value: grassTexture},\n      // grassTextureNormal: {value: grassTextureNormal},\n      // icyTexture: {value: icyTexture},\n      // snowTexture: {value: snowTexture},\n      // sunPosition: {value: sunPosition},\n      ...uniforms\n    },\n    defines: {\n      PHYSICAL: '',\n      USE_MAP: '',\n      USE_NORMALMAP: '',\n      USE_ENVMAP: '',\n      ENVMAP_TYPE_CUBE: '',\n      ENVMAP_BLENDING_MULTIPLY: '',\n      TONE_MAPPING: ''\n    },\n    vertexShader,\n    fragmentShader,\n    extensions: {\n      derivatives: true\n    },\n    wireframe: false,\n    lights: true,\n    fog: true\n    // transparent: true,\n    // ...options,\n  })\n  material.uniforms.map.value = grassTexture\n  material.uniforms.normalMap.value = grassTextureNormal\n  // material.uniforms.envMap.value = envmapTexture\n  material.uniforms.toneMappingExposure = { value: 3 }\n  material.uniforms.toneMappingWhitePoint = { value: 5 }\n  // material.uniforms.normalScale = {value: 5}\n  material.opacity = 1.0\n  material.roughness = 1\n  material.metalness = 0\n  material.lightMapIntensity = 1.0\n  material.aoMapIntensity = 1.0\n  material.emissiveIntensity = 1.0\n  material.envMapIntensity = 1\n  material.refractionRatio = 0.98\n  material.bumpscale = 1.0\n  material.normalScale = new Vector2(5, 5)\n  material.uniforms.reflectivity.value = 0.5\n  material.clearCoatRoughness = 0.0\n\n  // needed for WebGLProgram to unroll loops\n  // cf. https://github.com/mrdoob/three.js/pull/12323\n  material.isShaderMaterial = false\n  material.isMeshStandardMaterial = true\n  material.isMeshPhysicalMaterial = true\n  // repeat the texture 20 times\n  material.uniforms.uvTransform.value = new Matrix3().multiplyScalar(20)\n\n  material.needsUpdate = true\n  return material\n}\n\nexport { Material }\n","import {\n  RawShaderMaterial,\n  TextureLoader,\n  RepeatWrapping,\n  UniformsLib,\n  Matrix3\n} from 'three'\nimport vertexShader from './terrain_tile_raw.vert.glsl'\nimport fragmentShader from './terrain_tile_raw.frag.glsl'\n\nconst textureLoader = new TextureLoader().setCrossOrigin('anonymous')\n\nconst rockTexture = textureLoader.load(require('../textures/Rock_08_UV_H_CM_1.jpg'))\nconst rockTextureNormal = textureLoader.load(require('../textures/Rock_08_UV_H_CM_1_normal.jpg'))\n// const rockTexture = textureLoader.load(require('../textures/rock_brown_1600.jpg'))\nconst grassTexture = textureLoader.load(require('../textures/GrassGreenTexture_1024.jpg'))\nconst grassTextureNormal = textureLoader.load(require('../textures/GrassGreenTexture_1024_normal.jpg'))\n// const grassTexture = textureLoader.load(require('../textures/rainforest512.jpg'))\n// const grassTexture2 = textureLoader.load(require('../textures/Grass_01_UV_H_CM_1.jpg'))\n// const icyTexture = textureLoader.load(require('../textures/snow_scuffed_ground_1.jpg'))\n// const snowTexture = textureLoader.load(require('../textures/Snow_01_UV_H_CM_1.jpg'))\n// const envmapTexture = textureLoader.load(require('../textures/envmap.jpg'))\nrockTexture.wrapS = rockTexture.wrapT = RepeatWrapping\n// rockTexture.offset.set(0, 0)\n// rockTexture.repeat.set(20, 20)\nrockTextureNormal.wrapS = rockTextureNormal.wrapT = RepeatWrapping\ngrassTexture.wrapS = grassTexture.wrapT = RepeatWrapping\ngrassTextureNormal.wrapS = grassTextureNormal.wrapT = RepeatWrapping\n// grassTexture.offset.set(0, 0);\n// grassTexture.repeat.set( 20, 20 );\n// grassTexture2.wrapS = grassTexture2.wrapT = RepeatWrapping\n// icyTexture.wrapS = icyTexture.wrapT = RepeatWrapping\n// snowTexture.wrapS = snowTexture.wrapT = RepeatWrapping\n\nconst MaterialBasic = (options, uniforms) => {\n  const material = new RawShaderMaterial({\n    uniforms: {\n      // opacity: {value: 1.0},\n      // clearCoat: {value: 0.0},\n      // clearCoatRoughness: {value: 0.0},\n      roughness: { value: 0.7 },\n      metalness: { value: 0.0 },\n      ...UniformsLib.common,\n      ...UniformsLib.lights,\n      // ...UniformsLib.specularMap,\n      // ...UniformsLib.envmap,\n      // ...UniformsLib.aomap,\n      // ...UniformsLib.lightmap,\n      // ...UniformsLib.emissivemap,\n      // ...UniformsLib.bumpmap,\n      ...UniformsLib.normalmap,\n      // ...UniformsLib.displacementmap,\n      // ...UniformsLib.roughnessmap,\n      // ...UniformsLib.metalnessmap,\n      // ...UniformsLib.gradientmap,\n      ...UniformsLib.fog,\n      // ...UniformsLib.points,\n      // spectral: {value: spectralTexture},\n      rockTexture: { value: rockTexture },\n      rockTextureNormal: { value: rockTextureNormal },\n      // grassTexture: {value: grassTexture},\n      // grassTextureNormal: {value: grassTextureNormal},\n      // icyTexture: {value: icyTexture},\n      // snowTexture: {value: snowTexture},\n      // sunPosition: {value: sunPosition},\n      ...uniforms\n    },\n    // defines: {\n    //   STANDARD: '',\n    //   USE_MAP: '',\n    //   // USE_ENVMAP: '',\n    //   USE_NORMALMAP: ''\n    //   // TONE_MAPPING: ''\n    //   // FLAT_SHADED: '',\n    // },\n    vertexShader,\n    fragmentShader,\n    // extensions: {\n    //   derivatives: true\n    // },\n    // wireframe: false,\n    lights: true,\n    fog: true\n    // transparent: true,\n    // ...options,\n  })\n  material.uniforms.map.value = grassTexture\n  material.uniforms.normalMap.value = grassTextureNormal\n  // material.uniforms.envMap.value = envmapTexture\n  // material.uniforms.toneMappingExposure = {value: 3}\n  // material.uniforms.toneMappingWhitePoint = {value: 5}\n  // material.uniforms.normalScale = {value: 5}\n  // material.opacity = 1.0\n  material.roughness = 0.7\n  material.metalness = 0\n  // material.lightMapIntensity = 1.0\n  // material.aoMapIntensity = 1.0\n  // material.emissiveIntensity = 1.0\n  // material.envMapIntensity = 1\n  // material.refractionRatio = 0.98\n  // material.bumpscale = 1.0\n  // material.normalScale = new Vector2(5, 5)\n  // material.uniforms.reflectivity.value = 0.5\n  // material.clearCoatRoughness = 0.0\n\n  // needed for WebGLProgram to unroll loops\n  // cf. https://github.com/mrdoob/three.js/pull/12323\n  // material.isShaderMaterial = false\n  // material.isMeshStandardMaterial = true\n  // material.isMeshPhysicalMaterial = true\n  // repeat the texture 20 times\n  material.uniforms.uvTransform.value = new Matrix3().multiplyScalar(20)\n\n  material.uniforms.needsUpdate = true\n  material.needsUpdate = true\n  return material\n}\n\nexport { MaterialBasic }\n","import {\n  Mesh,\n  BufferAttribute,\n  BufferGeometry\n} from 'three'\nimport { renderer, scene, options } from '../index'\n// import SimplifyModifier from '../modules/meshSimplify'\nimport Worker from './terrain.worker.js'\nimport { Material } from '../materials/terrainPhysical'\nimport { MaterialBasic } from '../materials/terrainTileRaw'\n// import { MaterialBasic } from '../materials/terrainTile'\n\n// const textureLoader = new TextureLoader().setCrossOrigin('anonymous')\n// const spectralTexture = textureLoader.load(\n//   'https://raw.githubusercontent.com/d3/d3-scale-chromatic/master/img/Spectral.png'\n// )\n\nconst materialBasic = MaterialBasic()\n\n// cf. http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#ECMAScript_.28JavaScript.2FActionScript.2C_etc..29\nconst long2tile = (lon, zoom) => {\n  return (lon + 180) / 360 * Math.pow(2, zoom)\n}\nconst lat2tile = (lat, zoom) => {\n  return (\n    (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)\n  )\n}\nconst offset = { y: 45.8671, x: 7.3087 }\nconst chamonix = { x: long2tile(offset.x, 10), y: lat2tile(offset.y, 10) }\nconst offsetAtZ = (z) => {\n  return {\n    x: chamonix.x / Math.pow(2, 10 - z),\n    y: chamonix.y / Math.pow(2, 10 - z)\n  }\n}\nwindow.chamonix = chamonix\nconst setTilePosition = (geometry, key) => {\n  const zxyijs = key.split(',').map(x => parseInt(x, 10))\n  const z = zxyijs[0]\n  const x = zxyijs[1]\n  const y = zxyijs[2]\n  const size = zxyijs[5]\n  const offset = offsetAtZ(z)\n  geometry.position.set(\n    x * size - (offset.x % 1 - 0.5) * size - (1 - chamonix.x % 1) * 800,\n    -y * size + (offset.y % 1 - 0.5) * size + (1 - chamonix.y % 1) * 800,\n    0\n  )\n}\n\n// PBR\nconst material = Material({}, {})\n\nconst buildTileFromWorker = event => {\n  const geometry = new BufferGeometry()\n  const positions = new Float32Array(event.data.positions)\n  const normals = new Float32Array(event.data.normals)\n  const IndexArrayClass = {\n    2: Uint16Array,\n    4: Uint32Array\n  }[event.data.bpe.indices]\n  const index = new IndexArrayClass(event.data.indices)\n  // const dem = new Uint8Array(event.data.dem)\n  let uv = new Float32Array(positions.length / 3 * 2)\n  const n = Math.sqrt(positions.length / 3)\n  uv = uv.map((_, index) => index % 2 ? Math.floor((index / 2) / n) / n : (index / 2) % n / n)\n  geometry.addAttribute('position', new BufferAttribute(positions, 3))\n  geometry.addAttribute('normal', new BufferAttribute(normals, 3))\n  geometry.addAttribute('uv', new BufferAttribute(uv, 2))\n  geometry.setIndex(new BufferAttribute(index, 1))\n  geometry.computeBoundingSphere()\n  geometry.computeBoundingBox()\n\n  const terrainMaterial = options.PBR ? material : materialBasic\n  const plane = new Mesh(geometry, terrainMaterial)\n\n  plane.key = event.data.key\n  plane.name = 'terrainTile'\n  plane.castShadow = true\n  plane.receiveShadow = true\n  setTilePosition(plane, event.data.key)\n  scene.add(plane)\n  renderer.shadowMap.needsUpdate = true\n}\n\nlet workerPool = []\nconst workerPoolSize = navigator.hardwareConcurrency - 1 || 3\nfor (let i = 0; i < workerPoolSize; i++) {\n  const worker = new Worker()\n  worker.onmessage = buildTileFromWorker\n  workerPool.push(worker)\n}\nlet currentWorker = 0\nworkerPool.postMessage = args => {\n  const worker = workerPool[currentWorker]\n  worker.postMessage(args)\n  currentWorker = currentWorker === workerPoolSize - 1 ? 0 : currentWorker + 1\n}\n\nconst buildPlane = (z, x, y, segments, j, size) => {\n  workerPool.postMessage([z, x, y, segments, j, size])\n}\n\nexport {\n  buildPlane,\n  material\n}\n","import {\n  Vector3\n} from 'three'\nimport { camera, scene, drone } from '../index'\nimport { dirLight } from '../lights'\nimport { buildPlane } from '../terrain'\n\nconst tileSize = 800\nconst maxTilesInMemory = 128\nlet lastCameraPosition = new Vector3(0, 0, 0)\nlet tiles = {}\nlet pngs = {}\nlet currentKeysArray = []\nwindow.tiles = tiles\nwindow.pngs = pngs\n\nconst deleteTile = (tile) => {\n  scene.remove(tile)\n  tile.geometry.dispose()\n  tile.geometry = null\n  tile.material.dispose()\n  tile.material = null\n}\n\nlet camVec = new Vector3()\nconst tileBuilder = (timestamp) => {\n  const cameraPosition = camera.position\n  camVec = camVec.set(0, 0, -1).applyQuaternion(camera.quaternion)\n  let targetPosition = cameraPosition.clone()\n\n  targetPosition = targetPosition.add(camVec.multiplyScalar(400 * Math.max(1, Math.abs(cameraPosition.z) / 400)))\n  drone.position.set(targetPosition.x, targetPosition.y, 200)\n  dirLight.updatePosition()\n\n  if (cameraPosition.distanceTo(lastCameraPosition) > 10) {\n    lastCameraPosition = cameraPosition.clone()\n\n    const z0 = 10\n    const zoomDelta = Math.min(7, Math.floor(Math.sqrt(Math.abs(cameraPosition.z)) / 28))\n    // const zoomDelta = 0\n    const zoom = z0 - zoomDelta\n    const currentTileSize = tileSize * Math.pow(2, zoomDelta)\n\n    const x0 = Math.round(targetPosition.x / currentTileSize)\n    const y0 = -Math.round(targetPosition.y / currentTileSize)\n\n    const segments0 = cameraPosition.z > 2000 ? 127 : 255\n    const segments1 = cameraPosition.z > 2000 ? 31 : 63\n    // const segments0 = 32\n    // const segments1 = 15\n    const segments2 = 15\n\n    const cutOffDistance = currentTileSize * 3\n    let distanceVector = new Vector3()\n    let cameraXY = new Vector3()\n    let objectXY = new Vector3()\n    let distance\n\n    let visibleKeysArray = [\n      [zoom, x0, y0, segments0, 0, currentTileSize],\n      [zoom, x0, y0 + 1, segments0, 0, currentTileSize],\n      [zoom, x0 + 1, y0, segments0, 0, currentTileSize],\n      [zoom, x0 + 1, y0 + 1, segments0, 0, currentTileSize],\n\n      [zoom, x0 - 1, y0 - 1, segments1, 0, currentTileSize],\n      [zoom, x0 - 1, y0 - 0, segments1, 0, currentTileSize],\n      [zoom, x0 - 1, y0 + 1, segments1, 0, currentTileSize],\n      [zoom, x0 - 1, y0 + 2, segments1, 0, currentTileSize],\n\n      [zoom, x0 + 2, y0 - 1, segments1, 0, currentTileSize],\n      [zoom, x0 + 2, y0 - 0, segments1, 0, currentTileSize],\n      [zoom, x0 + 2, y0 + 1, segments1, 0, currentTileSize],\n      [zoom, x0 + 2, y0 + 2, segments1, 0, currentTileSize],\n\n      [zoom, x0, y0 - 1, segments1, 0, currentTileSize],\n      [zoom, x0, y0 + 2, segments1, 0, currentTileSize],\n      [zoom, x0 + 1, y0 - 1, segments1, 0, currentTileSize],\n      [zoom, x0 + 1, y0 + 2, segments1, 0, currentTileSize],\n\n      [zoom, x0 - 2, y0 - 2, segments2, 0, currentTileSize],\n      [zoom, x0 - 2, y0 - 1, segments2, 0, currentTileSize],\n      [zoom, x0 - 2, y0 - 0, segments2, 0, currentTileSize],\n      [zoom, x0 - 2, y0 + 1, segments2, 0, currentTileSize],\n      [zoom, x0 - 2, y0 + 2, segments2, 0, currentTileSize],\n      [zoom, x0 - 2, y0 + 3, segments2, 0, currentTileSize],\n\n      [zoom, x0 + 3, y0 - 2, segments2, 0, currentTileSize],\n      [zoom, x0 + 3, y0 - 1, segments2, 0, currentTileSize],\n      [zoom, x0 + 3, y0 - 0, segments2, 0, currentTileSize],\n      [zoom, x0 + 3, y0 + 1, segments2, 0, currentTileSize],\n      [zoom, x0 + 3, y0 + 2, segments2, 0, currentTileSize],\n      [zoom, x0 + 3, y0 + 3, segments2, 0, currentTileSize],\n\n      [zoom, x0 - 1, y0 - 2, segments2, 0, currentTileSize],\n      [zoom, x0 - 1, y0 + 3, segments2, 0, currentTileSize],\n      [zoom, x0, y0 - 2, segments2, 0, currentTileSize],\n      [zoom, x0, y0 + 3, segments2, 0, currentTileSize],\n      [zoom, x0 + 1, y0 - 2, segments2, 0, currentTileSize],\n      [zoom, x0 + 1, y0 + 3, segments2, 0, currentTileSize],\n      [zoom, x0 + 2, y0 - 2, segments2, 0, currentTileSize],\n      [zoom, x0 + 2, y0 + 3, segments2, 0, currentTileSize]\n\n    ]\n\n    // let camera = terrainTarget.native\n    // // camera.updateMatrix(); // make sure camera's local matrix is updated\n    // // camera.updateMatrixWorld(); // make sure camera's world matrix is updated\n    // // camera.matrixWorldInverse.getInverse( camera.matrixWorld );\n    // var frustum = new THREE.Frustum();\n    // frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));\n    // console.log( frustum );\n\n    const visibleKeysString = visibleKeysArray.map(k => k.toString())\n    const currentKeysString = currentKeysArray.map(k => k.toString())\n\n    // compute tile under the camera\n    const potentialUnderKeys = visibleKeysString.slice(0, 4)\n    const potentialUnderTiles = scene.children.filter(child => potentialUnderKeys.includes(child.key))\n    const tileToCamera = (tile) => {\n      return distanceVector.subVectors(tile.position, camera.position).length()\n    }\n    potentialUnderTiles.sort((a, b) =>\n      tileToCamera(a) - tileToCamera(b)\n    )\n    camera.userData.terrainKeysUnder = potentialUnderKeys\n    camera.userData.terrainTileUnder = potentialUnderTiles[0]\n\n    const newKeys = visibleKeysString.filter(x => currentKeysString.indexOf(x) < 0)\n    const existingKeys = scene.children.filter(child => child.key).map(tile => tile.key)\n\n    // build new keys\n    newKeys.forEach(newKey => {\n      if (existingKeys.includes(newKey)) {\n        return\n      }\n      const zxyijs = newKey.split(',').map(x => parseInt(x, 10))\n      buildPlane(...zxyijs)\n    })\n\n    // switch tiles visibility with regard to their distance to the camera\n    scene.children.filter(child => child.key)\n      .forEach(tile => {\n        distance = distanceVector.subVectors(\n          objectXY.set(tile.position.x, tile.position.y, 0),\n          cameraXY.set(camera.position.x, camera.position.y, 0)\n        ).length()\n        tile.userData.distanceToCamera = distance\n        if (distance < cutOffDistance && visibleKeysString.includes(tile.key)) {\n          tile.visible = true\n        } else {\n          window.setTimeout(() => { tile.visible = false }, 750)\n        }\n      })\n\n    // delete some distant tiles\n    scene.children.filter(child => child.key)\n      .sort((a, b) => a.userData.distanceToCamera - b.userData.distanceToCamera)\n      .slice(maxTilesInMemory)\n      .forEach(tile => {\n        if (!tile.markedForDeletion) {\n          window.setTimeout(() => deleteTile(tile), 750)\n          tile.markedForDeletion = true\n        }\n      })\n\n    currentKeysArray = visibleKeysArray.slice(0)\n  }\n}\n\ntileBuilder.clean = () => {\n  scene.children\n    .filter(child => child.name === 'terrainTile')\n    .forEach(tile => deleteTile(tile))\n  currentKeysArray = []\n  lastCameraPosition = new Vector3(0, 0, 0)\n}\n\nexport { tileBuilder }\n","import {\n  ShaderMaterial,\n  TextureLoader,\n  MirroredRepeatWrapping,\n  UniformsLib,\n  Matrix3,\n  Vector2\n} from 'three'\nimport vertexShader from './terrain_voxel_vert.glsl'\nimport fragmentShader from './terrain_voxel_frag.glsl'\n\nconst textureLoader = new TextureLoader().setCrossOrigin('anonymous')\n\nconst rockTexture = textureLoader.load(require('../textures/Rock_08_UV_H_CM_1.jpg'))\nconst rockTextureNormal = textureLoader.load(require('../textures/Rock_08_UV_H_CM_1_normal.jpg'))\n// const rockTexture = textureLoader.load(require('../textures/rock_brown_1600.jpg'))\nconst grassTexture = textureLoader.load(require('../textures/GrassGreenTexture_1024.jpg'))\nconst grassTextureNormal = textureLoader.load(require('../textures/GrassGreenTexture_1024_normal.jpg'))\n// const grassTexture = textureLoader.load(require('../textures/rainforest512.jpg'))\n// const grassTexture2 = textureLoader.load(require('../textures/Grass_01_UV_H_CM_1.jpg'))\n// const icyTexture = textureLoader.load(require('../textures/snow_scuffed_ground_1.jpg'))\n// const snowTexture = textureLoader.load(require('../textures/Snow_01_UV_H_CM_1.jpg'))\n// const envmapTexture = textureLoader.load(require('../textures/envmap.jpg'))\nrockTexture.wrapS = rockTexture.wrapT = MirroredRepeatWrapping\n// rockTexture.offset.set(0, 0)\n// rockTexture.repeat.set(20, 20)\nrockTextureNormal.wrapS = rockTextureNormal.wrapT = MirroredRepeatWrapping\ngrassTexture.wrapS = grassTexture.wrapT = MirroredRepeatWrapping\ngrassTextureNormal.wrapS = grassTextureNormal.wrapT = MirroredRepeatWrapping\n// grassTexture.offset.set(0, 0);\n// grassTexture.repeat.set( 20, 20 );\n// grassTexture2.wrapS = grassTexture2.wrapT = RepeatWrapping\n// icyTexture.wrapS = icyTexture.wrapT = RepeatWrapping\n// snowTexture.wrapS = snowTexture.wrapT = RepeatWrapping\n\nconst MaterialBasic = (options, uniforms) => {\n  const material = new ShaderMaterial({\n    uniforms: {\n      // opacity: {value: 1.0},\n      // clearCoat: {value: 0.0},\n      // clearCoatRoughness: {value: 0.0},\n      roughness: { value: 0.7 },\n      metalness: { value: 0.0 },\n      ...UniformsLib.common,\n      ...UniformsLib.lights,\n      // ...UniformsLib.specularMap,\n      ...UniformsLib.envmap,\n      // ...UniformsLib.aomap,\n      // ...UniformsLib.lightmap,\n      // ...UniformsLib.emissivemap,\n      // ...UniformsLib.bumpmap,\n      ...UniformsLib.normalmap,\n      // ...UniformsLib.displacementmap,\n      // ...UniformsLib.roughnessmap,\n      // ...UniformsLib.metalnessmap,\n      // ...UniformsLib.gradientmap,\n      ...UniformsLib.fog,\n      // ...UniformsLib.points,\n      // spectral: {value: spectralTexture},\n      rockTexture: { value: rockTexture },\n      rockTextureNormal: { value: rockTextureNormal },\n      // grassTexture: {value: grassTexture},\n      // grassTextureNormal: {value: grassTextureNormal},\n      // icyTexture: {value: icyTexture},\n      // snowTexture: {value: snowTexture},\n      // sunPosition: {value: sunPosition},\n      ...uniforms\n    },\n    defines: {\n      STANDARD: '',\n      USE_MAP: '',\n      // USE_ENVMAP: '',\n      USE_NORMALMAP: ''\n      // TONE_MAPPING: ''\n      // FLAT_SHADED: '',\n    },\n    vertexShader,\n    fragmentShader,\n    extensions: {\n      derivatives: true\n    },\n    wireframe: false,\n    lights: true,\n    fog: true\n    // transparent: true,\n    // ...options,\n  })\n  material.uniforms.map.value = grassTexture\n  material.uniforms.normalMap.value = grassTextureNormal\n  // material.uniforms.envMap.value = envmapTexture\n  // material.uniforms.toneMappingExposure = {value: 3}\n  // material.uniforms.toneMappingWhitePoint = {value: 5}\n  // material.uniforms.normalScale = {value: 5}\n  // material.opacity = 1.0\n  material.roughness = 0.7\n  material.metalness = 0\n  // material.lightMapIntensity = 1.0\n  // material.aoMapIntensity = 1.0\n  // material.emissiveIntensity = 1.0\n  // material.envMapIntensity = 1\n  // material.refractionRatio = 0.98\n  // material.bumpscale = 1.0\n  material.normalScale = new Vector2(1, 1)\n  // material.uniforms.reflectivity.value = 0.5\n  // material.clearCoatRoughness = 0.0\n\n  // needed for WebGLProgram to unroll loops\n  // cf. https://github.com/mrdoob/three.js/pull/12323\n  material.isShaderMaterial = false\n  material.isMeshStandardMaterial = true\n  // material.isMeshPhysicalMaterial = true\n  // repeat the texture 20 times\n  material.uniforms.uvTransform.value = new Matrix3().multiplyScalar(20)\n\n  material.needsUpdate = true\n  return material\n}\n\nexport { MaterialBasic }\n","const voxelSize = 500\nconst voxelLayers = 2\nconst voxelNumber = 3\nconst voxelOffset = {\n  x: 0, y: 0, z: -175\n}\n\nexport {\n  voxelSize,\n  voxelLayers,\n  voxelNumber,\n  voxelOffset\n}\n","import {\n  BufferGeometry,\n  BufferAttribute,\n  Mesh,\n  // MeshNormalMaterial,\n  BoxHelper\n} from 'three'\nimport { scene } from '../index'\nimport { MaterialBasic } from '../materials/terrainVoxel'\nimport { voxelSize, voxelLayers, voxelOffset } from './constants'\n\nimport Worker from './voxel.worker.js'\n\nconst materialBasic = MaterialBasic()\nconst emptyKeys = new Set()\nwindow.emptyKeys = emptyKeys\n\nconst buildVoxelsFromWorker = (event) => {\n  const key = [event.data.i, event.data.j, event.data.k]\n  if (!event.data.hasGeometry) {\n    emptyKeys.add(key.toString())\n    return\n  }\n\n  const positions = new Float32Array(event.data.pos1)\n  const normals = new Float32Array(event.data.normals1)\n  const indices = new Uint16Array(event.data.index1)\n\n  const geometry = new BufferGeometry()\n  geometry.addAttribute('position', new BufferAttribute(positions, 3))\n  geometry.addAttribute('normal', new BufferAttribute(normals, 3))\n  geometry.setIndex(new BufferAttribute(indices, 1))\n  const mesh = new Mesh(geometry, materialBasic)\n  // const mesh = new Mesh(geometry, new MeshNormalMaterial({wireframe: true}))\n\n  mesh.position.set(\n    voxelSize * event.data.i + voxelOffset.x,\n    voxelSize * event.data.j + voxelOffset.y,\n    voxelSize * event.data.k + voxelOffset.z\n  )\n  mesh.userData.key = key\n  let box = new BoxHelper(mesh, 0xffff00)\n  mesh.name = 'terrainVoxel'\n  box.name = 'terrainVoxelHelper'\n  scene.add(box)\n  scene.add(mesh)\n}\n\nlet workerPool = []\nconst workerPoolSize = navigator.hardwareConcurrency - 1 || 3\nfor (let i = 0; i < workerPoolSize; i++) {\n  const worker = new Worker()\n  worker.onmessage = buildVoxelsFromWorker\n  workerPool.push(worker)\n}\nlet currentWorker = 0\nworkerPool.postMessage = args => {\n  const worker = workerPool[currentWorker]\n  worker.postMessage(args)\n  currentWorker = currentWorker === workerPoolSize - 1 ? 0 : currentWorker + 1\n}\n\nconst buildVoxels = (i, j, k) => {\n  workerPool.postMessage([i, j, k, voxelLayers])\n}\n\nexport { buildVoxels, emptyKeys, voxelSize }\n","import {\n  Vector3,\n  Matrix4,\n  Frustum,\n} from 'three'\nimport { camera, scene } from '../index'\nimport { buildVoxels, emptyKeys } from '../voxel'\nimport { voxelSize, voxelLayers, voxelNumber } from '../voxel/constants'\n\nlet lastCameraPosition = new Vector3(0, 0, 0)\nlet currentKeys = []\nwindow.currentKeys = currentKeys\nlet keyString\n\nconst voxelBuilder = (timestamp) => {\n  const cameraPosition = camera.position\n\n  if (cameraPosition.distanceTo(lastCameraPosition) > 10) {\n    lastCameraPosition = cameraPosition.clone()\n    let i0 = Math.floor(cameraPosition.x / voxelSize + 0.5)\n    let j0 = Math.floor(cameraPosition.y / voxelSize + 0.5)\n    console.log('camera centered on tile ', i0, j0)\n    let visibleKeys = []\n    let size = voxelNumber\n    var frustum = new Frustum()\n    frustum.setFromMatrix(new Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse))\n    for (let i = 0; i < size; i++) {\n      for (let j = 0; j < size; j++) {\n        for (let k = 0; k < voxelLayers; k++) {\n          visibleKeys.push([i - Math.floor((size - 1) / 2) + i0, j - Math.floor((size - 1) / 2) + j0, k])\n        }\n      }\n    }\n\n    visibleKeys.forEach(key => {\n      keyString = key.toString()\n      if (!emptyKeys.has(keyString) && !currentKeys.includes(keyString)) {\n        currentKeys.push(keyString)\n        console.log('build', key)\n        buildVoxels(...key)\n      }\n    })\n\n    let sub = new Vector3()\n    let cameraXY = new Vector3()\n    let objectXY = new Vector3()\n    let distance\n    scene.children.filter(child => child.userData.key).forEach(voxelBlock => {\n      distance = sub.subVectors(\n        cameraXY.set(camera.position.x, camera.position.y, 0),\n        objectXY.set(voxelBlock.position.x, voxelBlock.position.y, 0)\n      ).length()\n      let cutOffDistance = voxelSize * Math.ceil(voxelNumber / 2) * 1.1\n      voxelBlock.visible = distance < cutOffDistance\n    })\n  }\n}\n\nconst deleteTile = (tile) => {\n  scene.remove(tile)\n  tile.geometry.dispose()\n  tile.geometry = null\n  tile.material.dispose()\n  tile.material = null\n}\n\nvoxelBuilder.clean = () => {\n  scene.children\n    .filter(child => ['terrainVoxel', 'terrainVoxelHelper'].includes(child.name))\n    .forEach(tile => deleteTile(tile))\n  currentKeys = []\n  lastCameraPosition = new Vector3(0, 0, 0)\n}\n\nexport { voxelBuilder }\n","import { tileBuilder } from './tileBuilder'\nimport { voxelBuilder } from './voxelsLoop'\nimport keyboardJS from 'keyboardjs'\n\nconst terrainLoops = [\n  tileBuilder,\n  voxelBuilder\n]\n\nlet activeTerrainIndex = 0\n\nconst terrainLoop = (timestamp) => terrainLoops[activeTerrainIndex](timestamp)\n\nkeyboardJS.bind('t', e => {\n  console.log('switch terrain')\n  terrainLoops[activeTerrainIndex].clean()\n  activeTerrainIndex = activeTerrainIndex === terrainLoops.length - 1 ? 0 : activeTerrainIndex + 1\n  console.log('switch terrain done')\n})\n\nexport { terrainLoop }\n","import {\n  TextureLoader\n} from 'three'\nimport {\n  Lensflare,\n  LensflareElement\n} from '../modules'\n\nconst textureLoader = new TextureLoader()\nconst textureFlare3 = textureLoader.load(require('../textures/lensflare/lensflare3.png'))\n\nconst lensFlare = new Lensflare()\n\nlensFlare.addElement(new LensflareElement(textureFlare3, 60, 0.6))\nlensFlare.addElement(new LensflareElement(textureFlare3, 70, 0.7))\nlensFlare.addElement(new LensflareElement(textureFlare3, 120, 0.9))\nlensFlare.addElement(new LensflareElement(textureFlare3, 70, 1.0))\n\nexport default lensFlare\n","import {\n  Vector3,\n  Matrix4\n} from 'three'\n\nconst motionBlurVertexShader = `\n  varying vec2 vUv;\n\n  void main() {\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    vUv = uv;\n\n  }`\n\nconst motionBlurFragmentShader = `\n  varying vec2 vUv;\n\n  uniform sampler2D tDepth;\n  uniform sampler2D tColor;\n\n  uniform mat4 clipToWorldMatrix;\n  uniform mat4 previousWorldToClipMatrix;\n\n  uniform vec3 cameraMove;\n\n  uniform float velocityFactor;\n  uniform float delta;\n\n  void main() {\n\n    float zOverW = texture2D(tDepth, vUv).x;\n\n    // clipPosition is the viewport position at this pixel in the range -1 to 1.\n    vec4 clipPosition = vec4(vUv.x * 2. - 1., vUv.y * 2. - 1., zOverW * 2. - 1., 1.);\n\n    vec4 worldPosition = clipToWorldMatrix * clipPosition;\n    worldPosition /= worldPosition.w;\n\n    vec4 previousClipPosition = worldPosition;\n\n    // Reduce motion blur due to camera translation especially at the screen center.\n    previousClipPosition.xyz -= cameraMove * (\n      1. - smoothstep(.3, 1., clamp(length(clipPosition.xy), 0., 1.))\n    );\n\n    previousClipPosition = previousWorldToClipMatrix * previousClipPosition;\n    previousClipPosition /= previousClipPosition.w;\n\n    vec2 velocity = velocityFactor * (clipPosition - previousClipPosition).xy / delta * 16.67;\n\n    vec4 finalColor = vec4(0.);\n    vec2 offset = vec2(0.);\n    float weight = 0.;\n    const int samples = 20;\n    for(int i = 0; i < samples; i++) {\n          offset = velocity * (float(i) / (float(samples) - 1.) - .5);\n          vec4 c = texture2D(tColor, vUv + offset);\n      finalColor += c;\n    }\n    finalColor /= float(samples);\n    gl_FragColor = vec4(finalColor.rgb, 1.);\n\n    // debug: view velocity values\n    // gl_FragColor = vec4(abs(velocity), 0., 1.);\n\n    // debug: view depth buffer\n    // gl_FragColor = vec4(vec3(zOverW), 1.);\n  }`\n\nexport const motionBlurShader = {\n\n  uniforms: {\n    tDepth: { type: 't', value: null },\n    tColor: { type: 't', value: null },\n\n    velocityFactor: { type: 'f', value: 1 },\n    delta: { type: 'f', value: 16.67 },\n\n    clipToWorldMatrix: { type: 'm4', value: new Matrix4() },\n    previousWorldToClipMatrix: { type: 'm4', value: new Matrix4() },\n\n    cameraMove: { type: 'v3', value: new Vector3() }\n  },\n\n  vertexShader: motionBlurVertexShader,\n  fragmentShader: motionBlurFragmentShader\n}\n","import {\n  Matrix4,\n  Vector3\n} from 'three'\n\nconst CloudsShader = {\n  uniforms: {\n    tDepth: { type: 't', value: null },\n    tColor: { type: 't', value: null },\n\n    cameraNear: { type: 'f', value: 1 },\n    cameraFar: { type: 'f', value: 1e6 },\n\n    clipToWorldMatrix: { type: 'm4', value: new Matrix4() },\n    cameraPosition: { type: 'v3', value: new Vector3() },\n    sun: { type: 'v3', value: new Vector3() }\n\n  },\n\n  vertexShader: `\n    varying vec2 vUv;\n\n    void main() {\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n      vUv = uv;\n\n    }\n  `,\n  fragmentShader: `\n  varying vec2 vUv;\n\n  uniform sampler2D tDepth;\n  uniform sampler2D tColor;\n\n  uniform mat4 clipToWorldMatrix;\n  uniform vec3 sun;\n\n  uniform float cameraNear;\n  uniform float cameraFar;\n\n  mat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat map(vec3 p){\n    return p.z + ((fbm(p*0.03)-0.1) + sin(p.x*0.014 + sin(p.y*.001)*7.)*0.4+0.15 + sin(p.y*0.008)*0.1) / 0.007;\n    return p.z + ((fbm(p*0.03)-0.1) + sin(p.x*0.024 + sin(p.y*.001)*7.)*0.22+0.15 + sin(p.y*0.008)*0.05) / 0.007;\n}\n\nfloat getres (in vec3 ro, in vec3 rd, in float z) {\n  return map(ro + rd * z);\n}\n\nfloat dikomarch(in vec3 ro, in vec3 rd, in vec3 world)\n{\n    float precis = .3;\n    float d = 0.;\n    float z0 = 1.;\n    float z1 = length(world - ro);\n    for (int i = 0; i < 8; i++) {\n      float res0 = getres(ro, rd, z0);\n      float res1 = getres(ro, rd, z1);\n      float mid = (z0+z1)/2.;\n      float resmid = getres(ro, rd, mid);\n      z0 = sign(res0) == sign(resmid) ? mid : z0;\n      z1 = sign(res1) == sign(resmid) ? mid : z1;\n      d = z0;\n      if (z0==z1) break;\n    }\n    float h= .0;\n    for( int i=0; i<8; i++ )\n    {\n      if( abs(h)<precis) break;\n      d += h;\n      vec3 pos = ro+rd*d;\n      h = map(pos);\n    }\n    return d;\n}\n\nvec4 march(in vec3 ro, in vec3 rd, in vec3 bgc, in vec3 world)\n{\n  float d = 0., t = 0.;\n  vec4 rz = vec4( 0.0 );\n  float l = length(ro - world);\n  float td=.0, w;\n\n  for( int i=0; i<250; i++ )\n  {\n    if(rz.a > 0.99 || t>l) break;\n\n    vec3 pos = ro + t*rd;\n    d = map(pos);\n    if (d<0.) {\n      float den = clamp(-d/200., 0., 1.);\n\n      vec4 col = vec4(mix( vec3(.8,.75,.85), vec3(.0), den ), den);\n\n      col.a *= .9;\n      col.rgb *= col.a;\n      rz = rz + col*(1.0 - rz.a);\n    }\n\n    t += max(1., abs(d) * .49);\n  }\n\n  return clamp(rz, 0., 1.);\n}\n\n\n  #include <packing>\n\n  float readDepth(sampler2D depthSampler, vec2 coord) {\n    return texture2D(depthSampler, coord).x;\n    float fragCoordZ = texture2D(depthSampler, coord).x;\n    float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n    return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n  }\n\n  void main() {\n\n    float zOverW = readDepth(tDepth, vUv);\n\n    // clipPosition is the viewport position at this pixel in the range -1 to 1.\n    vec4 clipPosition = vec4(vUv.x * 2. - 1., vUv.y * 2. - 1., zOverW * 2. - 1., 1.);\n\n    vec4 worldPosition = clipToWorldMatrix * clipPosition;\n    worldPosition /= worldPosition.w;\n\n    vec3 color = texture2D(tColor, vUv).rgb;\n    vec3 dir = normalize(worldPosition.xyz - cameraPosition);\n\n    // float rz = dikomarch(cameraPosition, dir, worldPosition.xyz);\n    // float rz = march(cameraPosition, dir, worldPosition.xyz);\n    // color = vec3(rz/700.);\n    // if (rz < 7000.)\n    // {\n      vec4 res = march(cameraPosition, dir, color, worldPosition.xyz);\n      color = color*(1.0-res.w) + res.xyz;\n    // }\n    // color = dir;\n\n    // color.w = 1.;\n    // debug: view depth buffer\n    // gl_FragColor = texture2D(tColor, vUv);\n    // gl_FragColor = vec4(clipPosition.xyz, 1.);\n    // gl_FragColor = vec4(normalize(cameraPosition), 1.);\n    // gl_FragColor = vec4(vec3(map(worldPosition.xyz)), 1.);\n    // gl_FragColor = vec4(vec3(zOverW), 1.);\n    // gl_FragColor = vec4((worldPosition.xyz - cameraPosition)/100., 1.);\n    // gl_FragColor = vec4(vec3(fbm(cameraPosition + dir)), 1.);\n    \n    // gl_FragColor = vec4(vec3(rz)/700., 1.);\n    // gl_FragColor = vec4(vec3(length(worldPosition.xyz - cameraPosition))/1500., 1.);\n    // gl_FragColor = res;\n    // gl_FragColor = vec4(col, 1.);\n    gl_FragColor = vec4(color, 1.);\n    // gl_FragColor = mix(texture2D(tColor, vUv), vec4(color, 1.), clamp(rz/zOverW, 0., 1.));\n    \n    // gl_FragColor = texture2D(tColor, vUv) + color;\n    // gl_FragColor = mix(texture2D(tColor, vUv), vec4(.9), 1. - color.x);\n  }\n  `\n}\n\nexport default CloudsShader\n","import { camera } from '../index'\n\nfunction screenXY (vec3, centered = false) {\n  const vector = vec3.clone()\n\n  const widthHalf = (window.innerWidth / 2)\n  const heightHalf = (window.innerHeight / 2)\n\n  vector.project(camera)\n\n  vector.x = (vector.x * widthHalf)\n  vector.y = -(vector.y * heightHalf)\n\n  if (!centered) {\n    vector.x += widthHalf\n    vector.y += heightHalf\n  }\n\n  return vector\n}\n\nconst screenXYclamped = (vec3) => {\n  const screenPosition = screenXY(vec3)\n  return {\n    x: Math.min(Math.max(10, screenPosition.x), window.innerWidth - 10),\n    y: Math.min(Math.max(10, screenPosition.y), window.innerHeight - 10),\n    z: screenPosition.z\n  }\n}\n\nconst clamp = (min, value, max) => Math.min(Math.max(min, value), max)\n\nexport { screenXY, screenXYclamped, clamp }\n","import { Vector2, Vector3 } from 'three'\nimport React, { Component } from 'react'\nimport ReactDOM from 'react-dom'\nimport clone from 'clone'\nimport { screenXYclamped } from '../utils'\nimport PubSub from '../events'\nimport { scene, camera } from '../index'\nimport Crosshair from './crosshair'\n\nlet pilotDrone\nlet screenCenter = new Vector2(window.innerWidth / 2, window.innerHeight / 2)\nPubSub.subscribe('x.screen.resized', (msg, rendererSize) => {\n  screenCenter = new Vector2(rendererSize.width / 2, rendererSize.height / 2)\n})\nlet horizonStyle\nlet focalStyle\nconst hudData = {\n  targets: new Set(),\n  targetsInSight: new Set(),\n  targetsInFront: new Set(),\n  gunTarget: null\n}\n\nclass HUD extends Component {\n  constructor (props) {\n    super(props)\n    this.state = { time: 0, gunHeat: 0, lockLevel: 0, pilot: null }\n  }\n\n  componentDidMount () {\n    PubSub.publish('x.hud.mounted')\n  }\n\n  gunHeat () {\n    if (!pilotDrone || !pilotDrone.gunClock.running) {\n      return Math.max(0, this.state.gunHeat - 0.01)\n    }\n    const delta = pilotDrone.gunClock.getDelta()\n    const gunHeat = this.state.gunHeat + delta / 1.5\n    if (gunHeat >= 1) {\n      PubSub.publish('x.drones.gun.stop', pilotDrone)\n      PubSub.publish('x.camera.shake.stop')\n      pilotDrone.gunClock.stop()\n    }\n    return Math.min(gunHeat, 1)\n  }\n\n  lockLevel () {\n    if (hudData.targetsInSight.size === 0) {\n      return Math.max(0, this.state.lockLevel - 0.02)\n    }\n    const times = []\n    hudData.targetsInSight.forEach(target => {\n      const delta = target.lockClock.getDelta()\n      times.push(this.state.lockLevel + delta / 2)\n    })\n    return Math.min(Math.max(...times), 1)\n  }\n\n  update (timestamp, newState) {\n    const gunHeat = this.gunHeat()\n    const lockLevel = this.lockLevel()\n    this.setState({\n      ...newState,\n      time: timestamp,\n      gunHeat,\n      lockLevel,\n      lock: lockLevel === 1,\n      pilot: pilotDrone ? pilotDrone.userData : null\n    })\n  }\n\n  render () {\n    const targets = Array.from(hudData.targets)\n    const targetsData = targets.map(target => Object.assign(\n      clone(target.userData),\n      { id: target.id }\n    ))\n    return (\n      <div>\n        <div id='limiter' />\n        <div id='pointer' />\n        <div id='focal' style={this.state.focalStyle} />\n        <div id='horizon' style={this.state.horizonStyle} />\n        { this.state.pilot ? (\n          <div id='messages'>\n            <div>{this.state.pilot.altitude.toFixed(0)} m</div>\n            <div>{this.state.pilot.speed.toFixed(0)} m/s</div>\n          </div>\n        ) : null\n        }\n        <svg className='vector'>\n          <Crosshair size='30' x={screenCenter.x} y={screenCenter.y}\n            fill='transparent'\n            stroke='#0f0'\n            strokeWidth='17'\n            opacity='0.8'\n          />\n          <circle\n            cx={screenCenter.x} cy={screenCenter.y} r={160}\n            stroke='#666' opacity={0.8} strokeWidth='10' fill='transparent'\n            strokeDasharray='140 1000' transform={`rotate(155 ${screenCenter.x} ${screenCenter.y})`}\n            strokeLinecap='round'\n          />\n          {\n            this.state.lockLevel\n              ? (<circle\n                cx={screenCenter.x} cy={screenCenter.y} r={160}\n                stroke='#0f0' opacity={0.8} strokeWidth='10' fill='transparent'\n                strokeDasharray={`${this.state.lockLevel * 140} 1000`}\n                transform={`rotate(155 ${screenCenter.x} ${screenCenter.y})`}\n                strokeLinecap='round'\n              />) : null\n          }\n          <circle\n            cx={screenCenter.x} cy={screenCenter.y} r={160}\n            stroke='#666' opacity={0.8} strokeWidth='10' fill='transparent'\n            strokeDasharray='140 1000'\n            strokeLinecap='round' transform={`rotate(205 ${screenCenter.x} ${screenCenter.y}) translate(${screenCenter.x * 2}, 0) scale(-1, 1)`}\n          />\n          {\n            this.state.gunHeat\n              ? (<circle\n                cx={screenCenter.x} cy={screenCenter.y} r={160}\n                stroke='orange' opacity={0.8} strokeWidth='10' fill='transparent'\n                strokeDasharray={`${this.state.gunHeat * 140} 1000`}\n                strokeLinecap='round' transform={`rotate(205 ${screenCenter.x} ${screenCenter.y}) translate(${screenCenter.x * 2}, 0) scale(-1, 1)`}\n              />)\n              : null\n          }\n          {targets.map(target => (\n            target.gunHud\n              ? (<g key={target.id}>\n                <path\n                  d={`M ${target.hudPosition.x} ${target.hudPosition.y}\n                    l ${target.direction.x} ${target.direction.y}`}\n                  strokeWidth='1'\n                  stroke={target === this.state.gunTarget ? '#0f0' : 'orange'}\n                  fill='transparent' />\n                {target === this.state.gunTarget ? (\n                  <Crosshair size='30'\n                    x={target.hudPosition.x + target.direction.x}\n                    y={target.hudPosition.y + target.direction.y}\n                    fill='#0f0'\n                    fillOpacity='0.6'\n                    stroke='#0f0'\n                    strokeWidth='17'\n                    strokeOpacity='1'\n                  />\n                ) : null}\n              </g>)\n              : null\n          ))}\n        </svg>\n        <div id='targets'>\n          {targetsData.map(target => (\n            <div className='target' key={target.id} id={'target-' + target.id} style={target.hud.element.style}>\n              <div className='life' style={{ width: target.life / 100 * 20 }} />\n              <div className='arrow' style={target.hud.arrow.style} />\n              <div className='distance'>{target.hud.distance.innerHTML}</div>\n              <div className='name'>drone-{target.id}</div>\n            </div>\n          ))}\n        </div>\n      </div>\n    )\n  }\n}\n\nconst registerTarget = (msg, target) => {\n  hudData.targets.add(target)\n  target.userData.hud = {\n    element: { style: {} },\n    arrow: { style: {} },\n    distance: { style: {} }\n  }\n  let hudPosition\n  let targetDistance2D\n  let targetDistance3D\n  let targetVector2D\n  let targetVector3D\n  let targetDirection\n  const ZONE = 400\n  const FOCAL_SIZE = 150\n  const GUN_RANGE = 500\n  const targetLoop = (timestamp, delta) => {\n    if (!hudElement.mounted) return\n    hudPosition = screenXYclamped(target.position)\n    if (hudPosition.z > 1) {\n      hudPosition.x = window.innerWidth - hudPosition.x\n      hudPosition.y = window.innerHeight - 10\n      target.userData.hud.element.style.borderColor = 'red'\n      target.userData.hud.arrow.style.borderBottomColor = 'red'\n    } else {\n      target.userData.hud.element.style.borderColor = 'orange'\n      target.userData.hud.arrow.style.borderBottomColor = 'orange'\n    }\n    target.hudPosition = hudPosition\n    targetVector2D = new Vector2(hudPosition.x, hudPosition.y).sub(screenCenter)\n    target.userData.hudPositionCentered = targetVector2D\n    if (targetVector2D.length() > ZONE) {\n      targetVector2D.normalize().multiplyScalar(ZONE)\n    }\n    target.userData.hud.arrow.style.opacity = 0.8 * (1 - (ZONE - targetVector2D.length()) / 50)\n    targetVector3D = camera.position.clone().sub(target.position)\n    targetDistance3D = targetVector3D.length()\n    target.userData.distance = targetDistance3D\n    target.userData.hud.distance.innerHTML = targetDistance3D.toFixed(0)\n    target.userData.hud.distance.style.color = targetDistance3D < GUN_RANGE ? '#0f0' : 'orange'\n    target.userData.hud.element.style.transform = `\n      translateX(${targetVector2D.x + screenCenter.x}px)\n      translateY(${targetVector2D.y + screenCenter.y}px)\n      scale(${1.1 - Math.min(0.2, targetDistance3D / 2000)})\n    `\n    target.userData.hud.arrow.style.transform = `\n      translateY(2px)\n      rotate(${targetVector2D.angle() / Math.PI * 180 + 90}deg)\n    `\n    targetDistance2D = targetVector2D.length()\n    if (!target.destroyed && target.userData.hud.element.style.borderColor === 'orange' && targetDistance2D < FOCAL_SIZE) {\n      target.userData.hud.arrow.style.borderBottomColor = '#0f0'\n      hudData.targetsInSight.add(target)\n      if (!target.lockClock.running) target.lockClock.start()\n    } else {\n      hudData.targetsInSight.delete(target)\n      target.lockClock.stop()\n    }\n    if (!target.destroyed && targetDistance2D < ZONE - 10) {\n      hudData.targetsInFront.add(target)\n    } else {\n      hudData.targetsInFront.delete(target)\n    }\n    if (hudPosition.z <= 1 && targetDistance2D < ZONE * 0.8) {\n      targetDirection = screenXYclamped(\n        target.position.clone().add(target.velocity.clone().multiplyScalar(\n          Math.min(1,\n            (targetDistance3D + targetVector3D.clone().add(target.velocity).length()) / 2 / GUN_RANGE\n          )\n        ))\n      )\n      target.gunHud = true\n      target.direction = {\n        x: targetDirection.x - (targetVector2D.x + screenCenter.x),\n        y: targetDirection.y - (targetVector2D.y + screenCenter.y)\n      }\n    } else {\n      target.gunHud = false\n    }\n    target.ready = true\n  }\n  targetLoop.id = target.id\n  const destroyTarget = (msg, targetToDestroy) => {\n    if (targetToDestroy.id !== target.id) return\n    scene.remove(targetToDestroy)\n    PubSub.publish('x.loops.remove', targetLoop)\n    hudData.targets.delete(targetToDestroy)\n    hudData.targetsInSight.delete(target)\n    hudElement.forceUpdate()\n  }\n  PubSub.subscribe('x.drones.destroy', destroyTarget)\n  PubSub.publish('x.loops.push', targetLoop)\n}\nPubSub.subscribe('x.hud.register.target', registerTarget)\n\nconst camVec = new Vector3()\nlet localX\nlet localY\nlet rollAngle\nlet pitch\nlet rollAngleDegree\nconst hudLoop = (timestamp) => {\n  localX = new Vector3(1, 0, 0).applyQuaternion(camera.quaternion)\n  localY = new Vector3(0, 1, 0).applyQuaternion(camera.quaternion)\n  rollAngle = (\n    Math.PI / 2 - camera.up.angleTo(localX) * Math.sign(camera.up.dot(localY))\n  )\n  camera.rollAngle = rollAngle\n  pitch = camera.up.dot(camVec.set(0, 0, -1).applyQuaternion(camera.quaternion))\n  rollAngleDegree = rollAngle / Math.PI * 180\n  horizonStyle = {\n    transform: `translateX(-50%) translateY(${pitch * window.innerHeight / 2}px) rotate(${rollAngleDegree}deg)`\n  }\n  if (hudElement.state.lock) {\n    focalStyle = { boxShadow: '0 0 75px #0f0' }\n  } else {\n    focalStyle = { boxShadow: '' }\n  }\n  hudData.gunTarget = selectNearestGunTarget()\n  hudElement.update(timestamp, { horizonStyle, focalStyle, gunTarget: hudData.gunTarget })\n}\n\nPubSub.subscribe('x.hud.mounted', () => {\n  PubSub.publish('x.loops.push', hudLoop)\n  hudElement.mounted = true\n})\n\nPubSub.subscribe('x.drones.pilotDrone.loaded', (msg, data) => {\n  pilotDrone = data.pilotDrone\n})\n\nPubSub.subscribe('x.drones.missile.start', (msg, pilotDrone) => {\n  hudElement.setState(state => ({ ...state, lockLevel: 0, lock: false }))\n})\n\nconst selectNearestTargetInSight = () => {\n  if (hudData.targetsInSight.size === 0 || !hudElement.state.lock) return null\n  const distances = []\n  hudData.targetsInSight.forEach(target =>\n    distances.push([camera.position.distanceTo(target.position), target])\n  )\n  distances.sort((a, b) => a[0] > b[0])\n  return distances[0][1]\n}\n\nconst selectNearestGunTarget = () => {\n  if (hudData.targetsInSight.size === 0) return null\n  const distances = []\n  hudData.targetsInSight.forEach(target =>\n    distances.push([\n      new Vector2(target.hudPosition.x, target.hudPosition.y)\n        .sub(screenCenter)\n        .add(new Vector2(target.direction.x, target.direction.y)).length(),\n      target])\n  )\n  distances.sort((a, b) => a[0] > b[0])\n  return distances[0][1]\n}\n\nconst hudElement = ReactDOM.render(\n  <HUD />,\n  document.getElementById('hud')\n)\n\nexport {\n  selectNearestTargetInSight,\n  selectNearestGunTarget,\n  hudElement,\n  hudData\n}\n","import React, { PureComponent } from 'react'\n\nclass Crosshair extends PureComponent {\n  render () {\n    return (\n      <svg\n        x={this.props.x - this.props.size / 2}\n        y={this.props.y - this.props.size / 2}\n        viewBox='-10 -10 415 415' width={this.props.size} height={this.props.size}>\n        <g {...this.props}>\n          <circle cx='202.224' cy='202.228' r='26.686' />\n          <path d='M83.807,49.322L50.87,4.891c-9.519-9.527-30.71-3.78-40.236,5.747S-4.64,41.347,4.887,50.874\n            l44.431,32.937c9.519,9.519,24.963,9.527,34.49,0C93.334,74.284,93.326,58.84,83.807,49.322z' />\n          <path d='M393.823,10.638c-9.527-9.527-30.71-15.274-40.236-5.747l-32.937,44.431\n            c-9.527,9.527-9.527,24.963,0,34.49c9.527,9.527,24.963,9.519,34.49,0l44.431-32.937\n            C409.096,41.347,403.349,20.164,393.823,10.638z' />\n          <path d='M355.139,320.645c-9.527-9.527-24.963-9.527-34.49,0c-9.527,9.527-9.527,24.963,0,34.49\n            l32.937,44.431c9.527,9.519,30.71,3.78,40.236-5.747s15.274-30.71,5.747-40.236L355.139,320.645z' />\n          <path d='M49.318,320.645L4.887,353.582c-9.527,9.527-3.78,30.71,5.747,40.236s30.71,15.274,40.236,5.747\n            l32.937-44.431c9.527-9.519,9.527-24.963,0-34.49C74.28,311.127,58.844,311.127,49.318,320.645z' />\n        </g>\n      </svg>\n    )\n  }\n}\n\nexport default Crosshair\n","import SPE from 'shader-particle-engine/build/SPE'\nimport {\n  TextureLoader,\n  Vector2,\n  AdditiveBlending,\n  NormalBlending,\n  Vector3,\n  Color,\n  Line3\n} from 'three'\nimport PubSub from '../events'\n// import {scene} from '../index'\nimport { hudData, selectNearestGunTarget } from '../hud'\nimport { camera } from '../index'\n\n// GROUPS\nconst textureLoader = new TextureLoader()\nconst fireGroupOptions = {\n  texture: {\n    value: textureLoader.load(require('../textures/Explosion_002_Tile_8x8_256x256.png')),\n    frames: new Vector2(8, 8),\n    // value: textureLoader.load(require('../textures/sprite-explosion2.png')),\n    // frames: new Vector2(5, 5),\n    loop: 1\n  },\n  depthTest: true,\n  depthWrite: false,\n  blending: AdditiveBlending,\n  scale: 600,\n  maxParticleCount: 25000\n}\nconst pointsGroupOptions = {\n  texture: {\n    value: textureLoader.load(require('../textures/smokeparticle.png'))\n  },\n  depthTest: true,\n  depthWrite: false,\n  blending: NormalBlending,\n  maxParticleCount: 25000\n}\nconst debrisGroupOptions = {\n  texture: {\n    value: textureLoader.load(require('../textures/spark.png'))\n  },\n  depthTest: true,\n  depthWrite: false,\n  blending: NormalBlending,\n  maxParticleCount: 25000\n}\nconst bulletGroupOptions = {\n  texture: {\n    value: textureLoader.load(require('../textures/bullet.png'))\n  },\n  depthTest: true,\n  depthWrite: false,\n  blending: NormalBlending,\n  maxParticleCount: 25000\n}\n\n// EMITTERS\nconst shockwaveOptions = {\n  particleCount: 200,\n  type: SPE.distributions.DISC,\n  position: {\n    radius: 5,\n    spread: new Vector3(5)\n  },\n  maxAge: {\n    value: 2,\n    spread: 0\n  },\n  duration: 1,\n  activeMultiplier: 2000,\n\n  velocity: {\n    value: new Vector3(40)\n  },\n  rotation: {\n    axis: new Vector3(0, 0, 1),\n    angle: Math.PI * 0.5,\n    static: true\n  },\n  size: { value: 2 },\n  color: {\n    value: [\n      new Color(0.4, 0.2, 0.1),\n      new Color(0.2, 0.2, 0.2)\n    ]\n  },\n  opacity: { value: [0.5, 0.2, 0] }\n}\nconst debrisOptions = {\n  particleCount: 100,\n  type: SPE.distributions.SPHERE,\n  position: {\n    radius: 0.1\n  },\n  maxAge: {\n    value: 2\n  },\n  duration: 1,\n  activeMultiplier: 40,\n  velocity: {\n    value: new Vector3(100)\n  },\n  acceleration: {\n    value: new Vector3(0, 0, -20),\n    distribution: SPE.distributions.BOX\n  },\n  wiggle: 3,\n  size: {\n    value: 2,\n    spread: 5\n  },\n  angle: {\n    spread: Math.PI * 2\n  },\n  drag: {\n    value: 1\n  },\n  color: {\n    value: [\n      new Color(1, 1, 1),\n      new Color(1, 1, 0),\n      new Color(1, 0, 0),\n      new Color(0.4, 0.2, 0.1)\n    ]\n  },\n  opacity: { value: [1, 1, 0] }\n}\nconst fireOptions = {\n  particleCount: 20,\n  type: SPE.distributions.SPHERE,\n  position: {\n    radius: 5\n  },\n  maxAge: { value: 2 },\n  duration: 1,\n  activeMultiplier: 20,\n  velocity: {\n    value: new Vector3(10)\n  },\n  size: { value: [20, 100] },\n  color: {\n    value: [\n      new Color(0.5, 0.1, 0.05),\n      new Color(0.2, 0.2, 0.2)\n    ]\n  },\n  opacity: { value: [0.5, 0.35, 0.1, 0] }\n}\nconst mistOptions = {\n  particleCount: 100,\n  position: {\n    spread: new Vector3(15, 15, 15),\n    distribution: SPE.distributions.SPHERE\n  },\n  maxAge: { value: 2 },\n  duration: 1,\n  activeMultiplier: 2000,\n  velocity: {\n    value: new Vector3(8, 3, 10),\n    distribution: SPE.distributions.SPHERE\n  },\n  size: { value: 40 },\n  color: {\n    value: new Color(0.2, 0.2, 0.2)\n  },\n  opacity: { value: [0, 0, 0.4, 0] }\n}\nconst flashOptions = {\n  duration: 1,\n  particleCount: 50,\n  position: { spread: new Vector3(5, 5, 5) },\n  velocity: {\n    spread: new Vector3(30),\n    distribution: SPE.distributions.SPHERE\n  },\n  size: { value: [40, 20, 20, 20] },\n  maxAge: { value: 2 },\n  activeMultiplier: 2000,\n  // opacity: { value: [0.5, 0.25, 0, 0] }\n  opacity: { value: [1, 1, 0, 0] }\n  // opacity: { value: 1 }\n}\n\nconst smokeOptions = {\n  particleCount: 1000,\n  position: {\n    spread: new Vector3(1, 1, 1)\n  },\n  maxAge: { value: 10 },\n  // activeMultiplier: 2000,\n  velocity: {\n    value: new Vector3(4, 2, 5),\n    distribution: SPE.distributions.SPHERE\n  },\n  size: { value: [20, 60] },\n  color: {\n    value: new Color(0.9, 0.9, 0.9)\n  },\n  opacity: { value: [0.4, 0.4, 0.4, 0] }\n}\n\nconst smokeLightOptions = {\n  particleCount: 1000,\n  position: {\n    spread: new Vector3(1, 1, 1)\n  },\n  maxAge: { value: 5 },\n  // activeMultiplier: 2000,\n  velocity: {\n    value: new Vector3(4, 2, 5),\n    distribution: SPE.distributions.SPHERE\n  },\n  size: { value: [5, 10] },\n  color: {\n    value: new Color(1, 1, 1)\n  },\n  opacity: { value: [0.4, 0.4, 0.4, 0] }\n}\n\nconst bulletOptions = {\n  particleCount: 35,\n  type: SPE.distributions.BOX,\n  position: {\n    radius: 0.1\n  },\n  maxAge: {\n    value: 1\n  },\n  duration: null,\n  activeMultiplier: 1,\n  velocity: {\n    value: new Vector3(100),\n    spread: new Vector3(20, 20, 20)\n  },\n  acceleration: {\n    value: 0\n  },\n  size: {\n    value: 1\n  },\n  color: {\n    value: [\n      new Color(1, 1, 1),\n      new Color(1, 1, 0)\n    ]\n  },\n  opacity: { value: 1 }\n}\n\nconst sparkOptions = {\n  particleCount: 10,\n  type: SPE.distributions.SPHERE,\n  position: {\n    radius: 0.1\n  },\n  maxAge: {\n    value: 0.3\n  },\n  duration: 0.3,\n  activeMultiplier: 1000,\n  velocity: {\n    value: new Vector3(100)\n  },\n  acceleration: {\n    value: 0\n  },\n  wiggle: 30,\n  size: {\n    value: [3, 1, 0.5]\n  },\n  color: {\n    value: [\n      new Color(1, 1, 1),\n      new Color(1, 1, 0)\n    ]\n  },\n  opacity: { value: 1 }\n}\n\nconst flashGroup = new SPE.Group(fireGroupOptions)\nconst fireGroup = new SPE.Group(fireGroupOptions)\n\nconst debrisGroup = new SPE.Group(debrisGroupOptions)\nconst shockGroup = new SPE.Group(pointsGroupOptions)\nconst mistGroup = new SPE.Group(pointsGroupOptions)\nconst smokeGroup = new SPE.Group(pointsGroupOptions)\nconst smokeLightGroup = new SPE.Group(pointsGroupOptions)\n\nconst bulletGroup = new SPE.Group(bulletGroupOptions)\nconst sparkGroup = new SPE.Group(debrisGroupOptions)\n\nconst poolSize = 25\nconst createNew = false\n\nflashGroup.addPool(poolSize, flashOptions, createNew)\nfireGroup.addPool(poolSize, fireOptions, createNew)\n\ndebrisGroup.addPool(poolSize, debrisOptions, createNew)\nshockGroup.addPool(poolSize, shockwaveOptions, createNew)\nmistGroup.addPool(poolSize, mistOptions, createNew)\nsmokeGroup.addPool(poolSize, smokeOptions, createNew)\nsmokeLightGroup.addPool(poolSize, smokeLightOptions, createNew)\n\nbulletGroup.addPool(poolSize, bulletOptions, createNew)\nsparkGroup.addPool(poolSize, sparkOptions, createNew)\n\nconst groups = [\n  flashGroup,\n  fireGroup,\n  debrisGroup,\n  shockGroup,\n  mistGroup,\n  smokeGroup,\n  smokeLightGroup,\n  bulletGroup,\n  sparkGroup\n]\n// avoid artifacts with the ocean\ngroups.forEach(group => { group.mesh.renderOrder = 2 })\nsmokeGroup.mesh.renderOrder = 1\n// cf. https://github.com/squarefeet/ShaderParticleEngine/issues/126\ngroups.forEach(group => { group.mesh.frustumCulled = false })\n\nwindow.smokeGroup = smokeGroup\n\nlet camVec = new Vector3()\n\nconst triggerSingleEmitter = (group, target, follow = false, velocityFunction, offset = false) => {\n  const emitter = group.getFromPool()\n\n  if (emitter === null) {\n    console.log('SPE.Group pool ran out.')\n    return\n  }\n\n  if (offset) {\n    emitter.position.value = target.position.clone().add(\n      camVec.set(0, 0, -1).applyQuaternion(camera.quaternion).multiplyScalar(5)\n    )\n  } else {\n    emitter.position.value = target.position.clone()\n  }\n  if (velocityFunction) {\n    emitter.velocity.value = velocityFunction()\n  }\n\n  let initialPositions\n  // paramsArray vec4( alive, age, maxAge, wiggle )\n  let params\n  let velocities\n  let positions\n  let collisions\n  let bulletLine\n  let closestDistance\n  const targetVec3 = new Vector3()\n  const chunkReducer = (chunkSize) =>\n    (ar, it, i) => {\n      const ix = Math.floor(i / chunkSize)\n      if (!ar[ix]) ar[ix] = []\n      ar[ix].push(it)\n      return ar\n    }\n  const loop = {\n    loop: (timestamp, delta) => {\n      if (offset) {\n        emitter.position.value = target.position.clone().add(\n          camVec.set(0, 0, -1).applyQuaternion(camera.quaternion).multiplyScalar(5)\n        )\n      } else {\n        emitter.position.value = target.position.clone()\n      }\n      if (velocityFunction) {\n        emitter.velocity.value = velocityFunction()\n        initialPositions = emitter.attributes.position.typedArray.array.slice(\n          emitter.attributeOffset * 3,\n          (emitter.activationEnd) * 3\n        ).reduce(chunkReducer(3), [])\n        velocities = emitter.attributes.velocity.typedArray.array.slice(\n          emitter.attributeOffset * 3,\n          (emitter.activationEnd) * 3\n        ).reduce(chunkReducer(3), [])\n        params = emitter.paramsArray.slice(\n          emitter.attributeOffset * 4,\n          (emitter.activationEnd) * 4\n        ).reduce(chunkReducer(4), [])\n        positions = params.map((param, i) => {\n          return param[0]\n            ? new Vector3(...initialPositions[i]).add(\n              new Vector3(...velocities[i]).multiplyScalar(param[1])\n            )\n            : null\n        })\n        collisions = []\n        positions.forEach((pos, i) => {\n          if (pos === null) return\n          hudData.targetsInFront.forEach((target) => {\n            bulletLine = new Line3(\n              pos,\n              pos.clone().add(new Vector3(...velocities[i]).multiplyScalar(delta / 1000))\n            )\n            closestDistance = bulletLine.closestPointToPoint(target.position, true, targetVec3).sub(target.position).length()\n            if (closestDistance < 10) {\n              collisions.push([target, pos])\n            }\n          })\n        })\n        if (collisions.length) {\n          collisions.forEach(ar => {\n            PubSub.publish('x.sound.impact', ar[0])\n            triggerSmallExplosion({ position: ar[1] })\n            ar[0].userData.life -= 5\n          })\n        }\n      }\n    },\n    alive: true,\n    id: target.id\n  }\n  if (follow && !target.destroyed) {\n    PubSub.publish('x.loops.push', loop)\n    PubSub.subscribe('x.drones.destroy', (msg, drone) => {\n      if (drone.id !== target.id) return\n      loop.alive = false\n      emitter.disable()\n      group.releaseIntoPool(emitter)\n    })\n  }\n\n  emitter.loop = loop\n  emitter.enable()\n\n  if (emitter.duration) {\n    setTimeout(() => {\n      emitter.disable()\n      if (follow) { loop.alive = false }\n      group.releaseIntoPool(emitter)\n    }, (emitter.duration + emitter.maxAge.value + emitter.maxAge.spread) * 1000)\n  }\n\n  return emitter\n}\n\nconst triggerExplosion = (target) => {\n  triggerSingleEmitter(flashGroup, target)\n  triggerSingleEmitter(fireGroup, target)\n  triggerSingleEmitter(debrisGroup, target)\n  triggerSingleEmitter(mistGroup, target)\n}\nPubSub.subscribe('x.drones.explode', (msg, drone) => triggerExplosion(drone))\n\nconst triggerSmoke = (target) => {\n  if (target.smoking) return\n  target.smoking = true\n  triggerSingleEmitter(smokeGroup, target, true)\n}\nPubSub.subscribe('x.drones.smoke.start', (msg, drone) => triggerSmoke(drone))\n\nconst triggerLightSmoke = (target) => {\n  if (target.smoking) return\n  target.smoking = true\n  const smokeEmitter = triggerSingleEmitter(smokeLightGroup, target, true)\n  PubSub.subscribe('x.drones.missile.stop', (msg, missile) => {\n    smokeEmitter.loop.alive = false\n    smokeEmitter.disable()\n    smokeLightGroup.releaseIntoPool(smokeEmitter)\n  })\n}\nPubSub.subscribe('x.drones.missile.start', (msg, missile) => triggerLightSmoke(missile))\n\nconst triggerSmallExplosion = (target) => {\n  triggerSingleEmitter(sparkGroup, target)\n}\n\nlet tmpVec1 = new Vector3()\nlet targetVector = new Vector3()\nPubSub.subscribe('x.drones.gun.start', (msg, drone) => {\n  const target = selectNearestGunTarget()\n  const velocityFunction = () => {\n    if (target !== null && target.gunHud) {\n      tmpVec1.copy(target.position).sub(drone.position)\n      tmpVec1.add(target.velocity.clone().multiplyScalar(tmpVec1.length() / 500))\n      tmpVec1.normalize().multiplyScalar(500)\n      targetVector.copy(tmpVec1)\n    } else {\n      targetVector = camVec.set(0, 0, -1).applyQuaternion(camera.quaternion).multiplyScalar(500)\n      const localY = new Vector3(0, 1, 0).applyQuaternion(camera.quaternion)\n      targetVector = targetVector.add(localY.multiplyScalar(24))\n    }\n    return targetVector\n  }\n  drone.gunEmitter = triggerSingleEmitter(bulletGroup, drone, true, velocityFunction, true)\n})\n\nPubSub.subscribe('x.drones.gun.stop', (msg, drone) => {\n  if (drone.gunEmitter) {\n    drone.gunEmitter.loop.alive = false\n    drone.gunEmitter.disable()\n    bulletGroup.releaseIntoPool(drone.gunEmitter)\n  }\n})\n\nexport { groups as particleGroups, triggerExplosion }\n","import { GLTFLoader } from '../modules'\nimport PubSub from '../events'\n\nvar loader = new GLTFLoader()\n\nlet droneMesh\n\nconst loadDroneAssets = () => {\n  loader.load(\n    // resource URL\n    './assets/drone/scene.gltf',\n    // called when the resource is loaded\n    function (gltf) {\n      droneMesh = gltf.scene.children[0]\n      PubSub.publish('x.assets.drone.loaded', { mesh: droneMesh })\n    }\n  )\n}\n\nexport default loadDroneAssets\n","import {\n  Vector3,\n  Clock,\n  Raycaster\n} from 'three'\nimport { scene, camera, loops } from '../index'\nimport PubSub from '../events'\nimport { triggerExplosion } from '../particles'\n\nlet droneFactory = {\n  ready: false\n}\n\nconst initDroneFactory = (msg, data) => {\n  droneFactory = () => {\n    const drone = data.mesh.clone()\n    drone.up.set(0, 0, 1)\n    drone.rotation.x = 0\n    drone.scale.set(0.1, 0.1, 0.1)\n    drone.name = `drone-${drone.id}`\n    return drone\n  }\n  droneFactory.ready = true\n  PubSub.publish('x.drones.factory.ready')\n}\nPubSub.subscribe('x.assets.drone.loaded', initDroneFactory)\n\nconst buildPilotDrone = () => {\n  const pilotDrone = droneFactory()\n  pilotDrone.gunClock = new Clock(false)\n  pilotDrone.userData.altitude = NaN\n  pilotDrone.userData.speed = 0\n  pilotDrone.userData.lastPosition = pilotDrone.position.clone()\n  scene.add(pilotDrone)\n  window.pilotDrone = pilotDrone\n  let localY\n  let targetPosition\n  let targetPositionFinal\n  let camVec = new Vector3()\n  const raycaster = new Raycaster()\n  const downVector = new Vector3(0, 0, -1)\n  const offsetVector = new Vector3(0, 0, 100)\n  let terrainTiles\n  let lastTimestamp = 0\n  const pilotDroneLoop = (timestamp, delta) => {\n    camVec = camVec.set(0, 0, -1).applyQuaternion(camera.quaternion)\n    targetPosition = camera.position.clone()\n      .add(camVec.multiplyScalar(20))\n    localY = new Vector3(0, 1, 0).applyQuaternion(camera.quaternion)\n    targetPositionFinal = targetPosition.sub(localY.multiplyScalar(8))\n    pilotDrone.position.copy(targetPositionFinal)\n    pilotDrone.lookAt(targetPosition\n      .add(camVec)\n      .add({ x: 0, y: 0, z: 60 })\n    )\n\n    // velocity computation\n    pilotDrone.userData.velocity = pilotDrone.position.clone()\n      .sub(pilotDrone.userData.lastPosition)\n      .multiplyScalar(1000 / delta)\n    pilotDrone.userData.speed = pilotDrone.userData.velocity.length()\n    pilotDrone.userData.lastPosition.copy(pilotDrone.position)\n\n    // altitude computation\n    if (timestamp - lastTimestamp > 200) {\n      lastTimestamp = timestamp\n      raycaster.set(pilotDrone.position.clone().add(offsetVector), downVector)\n      terrainTiles = raycaster.intersectObjects(\n        camera.userData.terrainTileUnder ? [camera.userData.terrainTileUnder] : []\n      )\n      if (terrainTiles.length > 0) {\n        pilotDrone.userData.altitude = terrainTiles[0].distance - offsetVector.length()\n        pilotDrone.userData.groundNormal = terrainTiles[0].face.normal\n      }\n      if (pilotDrone.userData.altitude < 5) {\n        PubSub.publish('x.drones.explode.pilotDrone', pilotDrone)\n        PubSub.publish('x.drones.collision.terrain.pilotDrone', pilotDrone.userData.groundNormal)\n      }\n    }\n  }\n  loops.push(pilotDroneLoop)\n  PubSub.publish('x.drones.pilotDrone.loaded', { pilotDrone })\n}\nPubSub.subscribe('x.drones.factory.ready', buildPilotDrone)\n\nconst spawnDrone = (circle = true, phase = 0) => {\n  const drone = droneFactory()\n  drone.lockClock = new Clock(false)\n  drone.userData.life = 100\n  scene.add(drone)\n  drone.lastPosition = drone.position.clone()\n  let camVec = new Vector3()\n  const droneLoop = (timestamp, delta) => {\n    if (!drone) return\n    const radius = 300\n    if (circle) {\n      drone.position.set(\n        radius * Math.cos(timestamp / 1000 / 3 + phase),\n        radius * Math.sin(timestamp / 1000 / 3 + phase),\n        300 + 50 * Math.cos(timestamp / 1000 + phase)\n      )\n    } else {\n      drone.position.copy(camera.position.clone()\n        .add(camVec.set(0, 0, -1).applyQuaternion(camera.quaternion).multiplyScalar(100)))\n    }\n    drone.velocity = drone.position.clone().sub(drone.lastPosition).multiplyScalar(1000 / delta)\n    drone.lastPosition = drone.position.clone()\n    if (!drone.destroyed && drone.userData.life <= 50) {\n      PubSub.publish('x.drones.smoke.start', drone)\n    }\n    if (!drone.destroyed && drone.userData.life <= 0) {\n      PubSub.publish('x.drones.destroy', drone)\n      drone.destroyed = true\n      triggerExplosion(drone)\n    }\n  }\n  PubSub.subscribe('x.drones.destroy', (msg, deadDrone) => {\n    if (deadDrone.id === drone.id) {\n      PubSub.publish('x.loops.remove', droneLoop)\n    }\n  })\n  PubSub.publish('x.hud.register.target', drone)\n  loops.push(droneLoop)\n}\n\nconst initTargets = () => {\n  spawnDrone(true)\n  spawnDrone(true, Math.PI / 8)\n  spawnDrone(true, Math.PI / 4)\n  spawnDrone(true, Math.PI / 2)\n  spawnDrone(true, Math.PI)\n}\nPubSub.subscribe('x.drones.factory.ready', initTargets)\nPubSub.subscribe('x.drones.destroy', () => spawnDrone(true, Math.random() * 2 * Math.PI))\n\nexport default initDroneFactory\n","import loadDroneAssets from './loader'\nimport './init'\n\nexport default loadDroneAssets\n","import {\n    Quaternion,\n    Vector2,\n    Vector3\n} from 'three'\n\n/**\n * @author James Baicoianu / http://www.baicoianu.com/\n */\n\nexport default function FlyControls (object, domElement, nipple, pointer) {\n  this.object = object\n\n  this.domElement = (domElement !== undefined) ? domElement : document\n  if (domElement) this.domElement.setAttribute('tabindex', -1)\n\n    // API\n\n  this.movementSpeed = 0.1\n  this.rollSpeed = 0.001\n\n  this.dragToLook = false\n  this.autoForward = false\n\n  this.nipple = nipple\n  if (this.nipple) {\n    this.nipple.on('move', (event, data) => this.nipplemove(event, data))\n    this.nipple.on('end', (event, data) => {\n      this.autoForward = false\n      this.updateMovementVector()\n    })\n  }\n\n  this.acceleration = 100\n  this.velocity = new Vector3(0, 0, 0)\n\n  this.pointer = pointer\n  if (this.pointer) {\n    const pointerElement = document.getElementById('pointer')\n    this.zone = 400\n    this.pointer.on('attain', movements => {\n      const dims = this.getContainerDimensions().size\n      pointerElement.style.left = dims[0] / 2 + 'px'\n      pointerElement.style.top = dims[1] / 2 + 'px'\n\n      // movements is a readable stream\n      let pointerVector = new Vector2(0, 0)\n      movements.on('data', move => {\n        pointerVector.add(new Vector2(move.dx, move.dy))\n        if (pointerVector.length() > this.zone) {\n          pointerVector.normalize().multiplyScalar(this.zone)\n        }\n        pointerElement.style.transform = `\n          translateX(${pointerVector.x - 16}px)\n          translateY(${pointerVector.y - 16}px)\n        `\n        this.mousemove({\n          pageX: (pointerVector.x) / 1.5,\n          pageY: (pointerVector.y) / 1.5\n        })\n      })\n\n      movements.on('close', function () {\n                // no more movements from this pointer-lock session.\n      })\n    })\n  }\n\n    // disable default target object behavior\n\n  this.nipplemove = function (event, data) {\n    const mockEvent = {\n      pageX: data.distance * Math.cos(data.angle.radian) * 1.5,\n      pageY: -data.distance * Math.sin(data.angle.radian) * 1.5\n    }\n    this.mousemove(mockEvent)\n    this.autoForward = true\n    this.updateMovementVector()\n  }\n\n    // internals\n\n  this.tmpQuaternion = new Quaternion()\n\n  this.moveState = {\n    up: 0,\n    down: 0,\n    left: 0,\n    right: 0,\n    forward: 0,\n    back: 0,\n    pitchUp: 0,\n    pitchDown: 0,\n    yawLeft: 0,\n    yawRight: 0,\n    rollLeft: 0,\n    rollRight: 0\n  }\n  this.moveVector = new Vector3(0, 0, 0)\n  this.rotationVector = new Vector3(0, 0, 0)\n\n  this.keydown = function (event) {\n    if (event.altKey) {\n      return\n    }\n\n        // event.preventDefault();\n\n    switch (event.keyCode) {\n      case 16: /* shift */ this.movementSpeedMultiplier = 0.1; break\n\n      case 87: /* W */ this.moveState.forward = 1; break\n      case 83: /* S */ this.moveState.back = 1; break\n\n      case 65: /* A */ this.moveState.yawLeft = 1; break\n      case 68: /* D */ this.moveState.yawRight = 1; break\n\n      case 82: /* R */ this.moveState.up = 1; break\n      case 70: /* F */ this.moveState.down = 1; break\n\n      case 38: /* up */ this.moveState.pitchUp = 1; break\n      case 40: /* down */ this.moveState.pitchDown = 1; break\n\n      case 37: /* left */ this.moveState.yawLeft = 1; break\n      case 39: /* right */ this.moveState.yawRight = 1; break\n\n      case 81: /* Q */ this.moveState.rollLeft = 1; break\n      case 69: /* E */ this.moveState.rollRight = 1; break\n\n      default: // do nothing\n    }\n\n    this.updateMovementVector()\n    this.updateRotationVector()\n  }\n\n  this.keyup = function (event) {\n    switch (event.keyCode) {\n      case 16: /* shift */ this.movementSpeedMultiplier = 1; break\n\n      case 87: /* W */ this.moveState.forward = 0; break\n      case 83: /* S */ this.moveState.back = 0; break\n\n      case 65: /* A */ this.moveState.yawLeft = 0; break\n      case 68: /* D */ this.moveState.yawRight = 0; break\n\n      case 82: /* R */ this.moveState.up = 0; break\n      case 70: /* F */ this.moveState.down = 0; break\n\n      case 38: /* up */ this.moveState.pitchUp = 0; break\n      case 40: /* down */ this.moveState.pitchDown = 0; break\n\n      case 37: /* left */ this.moveState.yawLeft = 0; break\n      case 39: /* right */ this.moveState.yawRight = 0; break\n\n      case 81: /* Q */ this.moveState.rollLeft = 0; break\n      case 69: /* E */ this.moveState.rollRight = 0; break\n\n      default: // do nothing\n    }\n\n    this.updateMovementVector()\n    this.updateRotationVector()\n  }\n\n  this.mousemove = function (event) {\n    var container = this.getContainerDimensions()\n    var halfWidth = container.size[ 0 ] / 2\n    var halfHeight = container.size[ 1 ] / 2\n\n    this.moveState.yawLeft = -event.pageX / halfWidth\n    this.moveState.rollLeft = this.moveState.yawLeft / 2 - this.object.rollAngle / 5\n    this.moveState.pitchDown = event.pageY / halfHeight\n  }\n\n  this.deltaVelocity = null\n  this.deltaPosition = null\n  this.update = (delta) => {\n    var rotMult = delta * this.rollSpeed\n\n    this.deltaVelocity = this.moveVector.clone().multiplyScalar(\n      delta / 1000 * this.acceleration\n    )\n    this.velocity.sub(\n      this.velocity.clone().multiplyScalar(\n        Math.max(\n          1,\n          this.deltaVelocity.length() ? 1 : 100 / (this.velocity.length() + 1)\n        ) * 0.01 * delta / 16.67\n      )\n    ).add(this.deltaVelocity)\n    this.deltaPosition = this.velocity.clone().multiplyScalar(delta / 1000)\n    this.object.position.add(this.deltaPosition.applyQuaternion(this.object.quaternion))\n\n    this.tmpQuaternion.set(this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1).normalize()\n    this.object.quaternion.multiply(this.tmpQuaternion)\n\n        // expose the rotation vector for convenience\n    this.object.rotation.setFromQuaternion(this.object.quaternion, this.object.rotation.order)\n\n    this.updateRotationVector()\n    this.updateMovementVector()\n  }\n\n  this.updateMovementVector = function () {\n    var forward = (this.moveState.forward || (this.autoForward && !this.moveState.back)) ? 1 : 0\n\n    this.moveVector.x = (-this.moveState.left + this.moveState.right)\n    this.moveVector.y = (-this.moveState.down + this.moveState.up)\n    this.moveVector.z = (-forward + this.moveState.back)\n\n        // console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );\n  }\n\n  this.updateRotationVector = function () {\n    this.rotationVector.x = (-this.moveState.pitchDown + this.moveState.pitchUp)\n    this.rotationVector.y = (-this.moveState.yawRight + this.moveState.yawLeft)\n    this.rotationVector.z = (-this.moveState.rollRight + this.moveState.rollLeft)\n\n        // console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );\n  }\n\n  this.getContainerDimensions = function () {\n    if (this.domElement !== document) {\n      return {\n        size: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],\n        offset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]\n      }\n    } else {\n      return {\n        size: [ window.innerWidth, window.innerHeight ],\n        offset: [ 0, 0 ]\n      }\n    }\n  }\n\n  function bind (scope, fn) {\n    return function () {\n      fn.apply(scope, arguments)\n    }\n  }\n\n  function contextmenu (event) {\n    event.preventDefault()\n  }\n\n  this.dispose = function () {\n    this.domElement.removeEventListener('contextmenu', contextmenu, false)\n\n    window.removeEventListener('keydown', _keydown, false)\n    window.removeEventListener('keyup', _keyup, false)\n  }\n\n  var _keydown = bind(this, this.keydown)\n  var _keyup = bind(this, this.keyup)\n\n  this.domElement.addEventListener('contextmenu', contextmenu, false)\n\n  window.addEventListener('keydown', _keydown, false)\n  window.addEventListener('keyup', _keyup, false)\n\n  this.updateMovementVector()\n  this.updateRotationVector()\n};\n","import {\n  hudElement,\n  hudData\n} from '../hud'\nimport { clamp } from '../utils'\n\nclass AutoPilot {\n  constructor (ship, controls, active) {\n    this.ship = ship\n    this.controls = controls\n    this.active = active\n    this.target = null\n    this.pointerElement = document.getElementById('pointer')\n  }\n\n  toggle () {\n    this.active = !this.active\n  }\n\n  update (delta) {\n    if (!this.active) return\n    this.state = { ...hudElement.state, ...hudData }\n\n    if (this.target === null || this.target.destroyed) {\n      this.target = Array.from(this.state.targets)\n        .filter(target => target.ready && !target.destroyed)\n        .reduce(\n          (a, b) => a.userData.distance < b.userData.distance ? a : b\n        )\n    }\n\n    if (!this.target) return\n\n    const move = { x: 0, y: 0 }\n    if (this.target.hudPosition.z > 1) {\n      let uturnX = Math.sign(this.target.userData.hudPositionCentered.x) * 100\n      move.x += uturnX\n      move.y += uturnX * Math.abs(Math.sin(this.ship.rollAngle))\n    } else {\n      move.x += clamp(-100, this.target.userData.hudPositionCentered.x, 100)\n      move.y += clamp(-100, this.target.userData.hudPositionCentered.y, 100)\n    }\n    this.controls.mousemove({\n      pageX: move.x,\n      pageY: move.y\n    })\n    this.pointerElement.style.transform = `\n      translateX(${move.x - 16}px)\n      translateY(${move.y - 16}px)\n    `\n\n    if (this.target.userData.distance > 150) {\n      this.controls.moveState.forward = 1\n    } else {\n      this.controls.moveState.forward = 0\n    }\n  }\n}\n\nexport default AutoPilot\n","import keyboardJS from 'keyboardjs'\nimport nipplejs from 'nipplejs'\nimport lock from 'pointer-lock'\nimport { mobileAndTabletcheck } from '../utils/isMobile'\nimport FlyControls from '../modules/FlyControls'\n// import {OrbitControls} from '../modules/OrbitControls'\nimport { triggerExplosion } from '../particles'\nimport PubSub from '../events'\nimport { scene, camera, renderer } from '../index'\nimport {\n  Mesh,\n  SphereBufferGeometry,\n  MeshPhongMaterial,\n  Vector3\n} from 'three'\nimport { selectNearestTargetInSight, hudElement } from '../hud'\nimport AutoPilot from './autopilot'\n\nlet controls = {\n  module: null,\n  setAcceleration (value) {\n    if (this.module && value !== this.module.acceleration) {\n      this.module.acceleration = value\n      console.log('acceleration set to ', value)\n    }\n  }\n}\nlet isMobile = mobileAndTabletcheck()\nlet controlsInitialized = false\nconst initControls = (msg, data) => {\n  if (controlsInitialized) return\n  if (isMobile) {\n    document.getElementById('touchPane').style.display = 'block'\n    const touchPaneLeft = window.document.getElementsByClassName('touchPaneLeft')[0]\n    const nippleLook = nipplejs.create({\n      zone: touchPaneLeft,\n      mode: 'static',\n      position: { left: '30%', top: '90%' },\n      color: 'white'\n    })\n\n    // display touch buttons\n    Array.from(document.getElementsByClassName('touchButton')).forEach(el => {\n      el.style.display = 'block'\n    })\n    // hide verbose text\n    document.getElementById('verbosePane').style.display = 'none'\n    // get button X\n    const buttonX = document.getElementById('buttonX')\n    const pressX = (event) => {\n      event.target.style.opacity = 0.5\n      fireBullet({ button: 2 })\n      setTimeout(() => { event.target.style.opacity = 0.3 }, 250)\n    }\n    buttonX.addEventListener('click', pressX, false)\n    buttonX.addEventListener('touchstart', pressX, false)\n\n    controls.module = new FlyControls(camera, touchPaneLeft, nippleLook)\n  } else {\n    const pointer = lock(renderer.domElement)\n    controls.module = new FlyControls(camera, renderer.domElement, undefined, pointer)\n  }\n\n  controls.module.update(0)\n\n  const autoPilot = new AutoPilot(camera, controls.module, false)\n  keyboardJS.bind('p', e => autoPilot.toggle())\n\n  PubSub.publish('x.loops.unshift', (timestamp, delta) => {\n    autoPilot.update(timestamp, delta)\n    controls.module.update(delta)\n  })\n\n  const pilotDrone = data.pilotDrone\n\n  // keyboardJS.bind('p', e => {\n  //   if (isMobile) { return }\n  //   const NewControlsClass = controls.module.constructor.name === 'OrbitControls' ? FlyControls : OrbitControls\n  //   console.log('controlsClass', NewControlsClass)\n  //   controls.module.dispose()\n  //   const newModule = new NewControlsClass(camera, controlsElement)\n  //   window.controls = newModule\n  //   controls.module = newModule\n  //   controls.module.update(0)\n\n  //   if (NewControlsClass === OrbitControls) {\n  //     let cam = pilotDrone.position.clone()\n  //     newModule.target.set(cam.x, cam.y, cam.z)\n  //   }\n  // })\n\n  keyboardJS.bind('c', e => {\n    console.log(camera.position)\n  })\n\n  keyboardJS.bind('r', e => {\n    if (controls.module.constructor.name === 'OrbitControls') {\n      controls.module.autoRotate = !controls.module.autoRotate\n    }\n  })\n\n  keyboardJS.bind('space', e => PubSub.publish('x.toggle.play'))\n\n  const bullet = new Mesh(\n    new SphereBufferGeometry(1, 5, 5),\n    new MeshPhongMaterial({ color: 0x111111 })\n  )\n  const fireBullet = e => {\n    if (!pilotDrone) return\n\n    if (e.button === 0) { // left click\n      PubSub.publish('x.drones.gun.start', pilotDrone)\n      PubSub.publish('x.camera.shake.start', 5)\n      pilotDrone.gunClock.start()\n    } else if (e.button === 2) { // right click\n      const target = selectNearestTargetInSight()\n      if (target === null || target.destroyed) return\n\n      const fire = bullet.clone()\n      fire.position.copy(pilotDrone.position)\n      scene.add(fire)\n      PubSub.publish('x.drones.missile.start', fire)\n\n      const BulletContructor = function () {\n        this.alive = true\n        this.object = fire\n        this.loop = (timestamp, delta) => {\n          if (!this.alive) return\n          const vec = target.position.clone().sub(fire.position)\n          if (vec.length() < 10) {\n            this.alive = false\n            triggerExplosion(target)\n            PubSub.publish('x.drones.missile.stop', fire)\n            PubSub.publish('x.drones.explosion', target)\n            target.userData.life -= 25\n            hudElement.forceUpdate()\n          }\n          const newDir = vec.normalize().multiplyScalar(10 * delta / 16.66)\n          fire.position.add(newDir)\n        }\n      }\n\n      const callback = new BulletContructor()\n      PubSub.publish('x.loops.push', callback)\n    }\n  }\n  renderer.domElement.addEventListener('mousedown', fireBullet, false)\n  renderer.domElement.addEventListener('mouseup', (e) => {\n    if (e.button === 0) {\n      PubSub.publish('x.drones.gun.stop', pilotDrone)\n      PubSub.publish('x.camera.shake.stop')\n      pilotDrone.gunClock.stop()\n    }\n  }, false)\n}\nPubSub.subscribe('x.drones.pilotDrone.loaded', initControls)\n\nlet tmpVec = new Vector3()\nPubSub.subscribe('x.drones.collision.terrain.pilotDrone', (msg, terrainNormal) => {\n  controls.setAcceleration(0)\n  tmpVec.copy(controls.module.velocity).applyQuaternion(camera.quaternion)\n  tmpVec.reflect(terrainNormal)\n  tmpVec.add(camera.position)\n  controls.module.velocity = camera.worldToLocal(tmpVec)\n  setTimeout(() => { controls.setAcceleration(60) }, 1000)\n})\n\nexport default controls\n","const mobilecheck = function () {\n  var check = false;\n  (function (a) { if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4))) check = true })(navigator.userAgent || navigator.vendor || window.opera) // eslint-disable-line\n  return check\n}\n\nconst mobileAndTabletcheck = function () {\n  var check = false;\n  (function (a) { if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4))) check = true })(navigator.userAgent || navigator.vendor || window.opera) // eslint-disable-line\n  return check\n}\n\nexport { mobilecheck, mobileAndTabletcheck }\n","import {\n  AudioListener,\n  Audio,\n  PositionalAudio,\n  AudioLoader\n} from 'three'\nimport { camera } from '../index'\nimport PubSub from '../events'\n\nconst audioLoader = new AudioLoader()\n\nconst impacts = [\n  { url: require('./impact1.ogg') },\n  { url: require('./impact2.ogg') },\n  { url: require('./impact3.ogg') },\n  { url: require('./impact4.ogg') }\n]\n\nconst weapons = [\n  { url: require('./gatling.ogg') },\n  { url: require('./missile.ogg') }\n]\n\nconst explosions = [\n  { url: require('./explosion1.ogg') },\n  { url: require('./explosion2.ogg') }\n]\n\nconst audioMapper = sound => {\n  audioLoader.load(sound.url, buffer => { sound.buffer = buffer })\n}\n\nconst setupSound = () => {\n  camera.listener = new AudioListener()\n  camera.add(camera.listener)\n\n  impacts.map(audioMapper)\n  weapons.map(audioMapper)\n  explosions.map(audioMapper)\n\n  PubSub.subscribe('x.sound.impact', (msg, drone) => {\n    const n = Math.floor(Math.random() * impacts.length)\n    if (!impacts[n].buffer) return\n    const sound = new PositionalAudio(camera.listener)\n    sound.setBuffer(impacts[n].buffer)\n    sound.setRefDistance(100)\n    drone.add(sound)\n    sound.play()\n    // drone.remove(sound) // necessary ?\n  })\n\n  const playExplosion = (msg, drone) => {\n    const n = Math.floor(Math.random() * explosions.length)\n    if (!explosions[n].buffer) return\n    const sound = new PositionalAudio(camera.listener)\n    sound.setBuffer(explosions[n].buffer)\n    sound.setRefDistance(500)\n    drone.add(sound)\n    sound.play()\n    // drone.remove(sound) // necessary ?\n  }\n  PubSub.subscribe('x.drones.destroy', playExplosion)\n  PubSub.subscribe('x.drones.explosion', playExplosion)\n\n  const gatlingSound = new Audio(camera.listener)\n  PubSub.subscribe('x.drones.gun.start', (msg, drone) => {\n    if (!weapons[0].buffer) return\n    gatlingSound.setBuffer(weapons[0].buffer)\n    gatlingSound.setLoop(true)\n    gatlingSound.play()\n  })\n  PubSub.subscribe('x.drones.gun.stop', (msg, drone) => {\n    gatlingSound.stop()\n  })\n\n  const missileSound = new Audio(camera.listener)\n  PubSub.subscribe('x.drones.missile.start', (msg, drone) => {\n    if (!weapons[1].buffer) return\n    missileSound.setBuffer(weapons[1].buffer)\n    missileSound.play()\n  })\n  PubSub.subscribe('x.drones.missile.stop', (msg, drone) => {\n    missileSound.stop()\n  })\n}\n\nexport default setupSound\n","import {\n  Vector4,\n  Matrix4,\n  Color\n} from 'three'\nimport waterFragmentShader from './water_frag.glsl'\nimport waterVertexShader from './water_vert.glsl'\nimport underwaterFragmentShader from './underwater_frag.glsl'\nimport underwaterVertexShader from './underwater_vert.glsl'\n\nconst WaterShader = {\n\n  uniforms: {\n\n    'color': { type: 'c', value: null },\n    'reflectivity': { type: 'f', value: 0 },\n    'surface': { type: 'f', value: 0 },\n    'tReflectionMap': { type: 't', value: null },\n    'tRefractionMap': { type: 't', value: null },\n    'tNormalMap0': { type: 't', value: null },\n    'tNormalMap1': { type: 't', value: null },\n    'tDepth': { type: 't', value: null },\n    'textureMatrix': { type: 'm4', value: null },\n    'clipToWorldMatrix': { type: 'm4', value: null },\n    'config': { type: 'v4', value: new Vector4() }\n  },\n  vertexShader: waterVertexShader,\n  fragmentShader: waterFragmentShader\n}\n\nconst UnderwaterShader = {\n  uniforms: {\n    color: { type: 'c', value: new Color(0xffffff) },\n    reflectivity: { type: 'f', value: 0.75 },\n    waterLevel: { type: 'f', value: 0 },\n    tDepth: { type: 't', value: null },\n    tDiffuse: { type: 't', value: null },\n    tReflectionMap: { type: 't', value: null },\n    tReflectionDepth: { type: 't', value: null },\n    tNormalMap0: { type: 't', value: null },\n    tNormalMap1: { type: 't', value: null },\n\n    clipToWorldMatrix: { type: 'm4', value: null },\n    worldToClipMatrix: { type: 'm4', value: new Matrix4() },\n    cameraPosition: { type: 'v3', value: null },\n    sunPosition: { type: 'v3', value: null },\n    time: { type: 'f', value: 0 }\n  },\n  vertexShader: underwaterVertexShader,\n  fragmentShader: underwaterFragmentShader\n}\n\nconst WiggleShader = {\n  uniforms: {\n    tDiffuse: { type: 't', value: null },\n    time: { type: 'f', value: 0 }\n  },\n  vertexShader: `\n    varying vec2 vUv;\n\n    void main() {\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n      vUv = uv;\n\n    }\n  `,\n  fragmentShader: `\n    uniform float time;\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n\n    float frequency = 10.;\n    float amplitude = 0.005;\n\n    void main() {\n      vec2 uv = vUv;\n      float X = vUv.x * frequency + time;\n      float Y = vUv.y * frequency + time;\n      uv.y += cos(X + Y) * amplitude * cos(Y);\n      uv.x += sin(X - Y) * amplitude * sin(Y);\n      gl_FragColor = texture2D(tDiffuse, uv);\n    }\n  `\n}\n\nexport { WaterShader, UnderwaterShader, WiggleShader }\n","import './index.css'\nimport {\n  Scene,\n  PerspectiveCamera,\n  Vector2,\n  Vector3,\n  Matrix4,\n  WebGLRenderer,\n  PCFSoftShadowMap,\n  Uncharted2ToneMapping,\n  Color,\n  FogExp2,\n  Mesh,\n  SphereBufferGeometry,\n  MeshBasicMaterial,\n  WebGLRenderTarget,\n  DepthTexture,\n  MeshDepthMaterial,\n\n  // Water imports\n  PlaneBufferGeometry,\n  TextureLoader,\n  RepeatWrapping,\n  LOD,\n} from 'three'\nimport dat from 'dat.gui/build/dat.gui.js'\nimport Stats from 'stats.js'\nimport queryString from 'query-string'\nimport { WindowResize } from './modules/WindowResize'\n// import {ShadowMapViewer} from './modules/ShadowMapViewer'\nimport { initSky } from './sky'\nimport { initLights, dirLight } from './lights'\nimport { terrainLoop } from './loops/terrainLoop'\nimport {\n  lensFlare,\n  motionBlurShader\n} from './postprocessing'\nimport { particleGroups } from './particles'\nimport PubSub from './events'\nimport setupDrones from './drones'\nimport controls from './controls'\nimport setupSound from './sound'\n\nimport {\n  EffectComposer,\n  ShaderPass,\n  RenderPass,\n  GlitchPass,\n  Water,\n  Reflector\n} from './modules'\nimport {\n  WaterShader,\n  UnderwaterShader,\n  WiggleShader\n} from './ocean'\n\nconst queryStringOptions = queryString.parse(window.location.search)\nconst options = {\n  PBR: queryStringOptions.PBR === 'true',\n  shadows: queryStringOptions.shadows === 'true',\n  postprocessing: queryStringOptions.postprocessing === 'true'\n}\nif (options.PBR) {\n  // PBR material needs an envMap\n  options.postprocessing = true\n}\n\nconst scene = new Scene()\nlet camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1e6)\n\ncamera.up = new Vector3(0, 0, 1)\n// camera.position.set(-500, 0, 700)\n// camera.position.set(-70, -475, 275)\n// // camera.position.set(170, -500, 180)\n// camera.lookAt(0, 0, 0)\ncamera.position.set(-70, 175, 345)\ncamera.lookAt(0, -400, 0)\ncamera.rollAngle = 0\ncamera.userData = { terrainKeysUnder: [] }\ncamera.updateMatrixWorld()\ncamera.updateProjectionMatrix()\n\nsetupSound()\n\nvar renderer = new WebGLRenderer({\n  antialias: true,\n  alpha: true,\n  logarithmicDepthBuffer: false\n})\n\nrenderer.gammaInput = true\nrenderer.gammaOutput = true\nrenderer.shadowMap.enabled = options.shadows\nrenderer.shadowMap.bias = 0.001\nrenderer.shadowMap.type = PCFSoftShadowMap\nrenderer.shadowMap.autoUpdate = true\nrenderer.physicallyCorrectLights = true\nrenderer.toneMapping = Uncharted2ToneMapping\n\nrenderer.setSize(window.innerWidth, window.innerHeight)\ndocument.body.appendChild(renderer.domElement)\n\nwindow.scene = scene\nwindow.renderer = renderer\nwindow.camera = camera\nwindow.controls = controls\n\nconst gui = new dat.GUI({ autoPlace: false })\ngui.closed = true\nwindow.document.getElementsByClassName('guiPane')[0].appendChild(gui.domElement)\nwindow.gui = gui\nPubSub.publish('x.gui.init', { gui })\n\nconst rendererFolder = gui.addFolder('Level of detail')\nconst RendererController = function () {\n  this.low = () => {\n    window.location.href = window.location.pathname + '?' +\n    queryString.stringify({\n      PBR: false,\n      shadows: false,\n      postprocessing: false\n    })\n  }\n  this.lowShadow = () => {\n    window.location.href = window.location.pathname + '?' +\n    queryString.stringify({\n      PBR: false,\n      shadows: true,\n      postprocessing: false\n    })\n  }\n  this.lowShadowDoF = () => {\n    window.location.href = window.location.pathname + '?' +\n    queryString.stringify({\n      PBR: false,\n      shadows: true,\n      postprocessing: true\n    })\n  }\n  this.high = () => {\n    window.location.href = window.location.pathname + '?' +\n    queryString.stringify({\n      PBR: true,\n      shadows: true,\n      postprocessing: true\n    })\n  }\n}\nconst rendererController = new RendererController()\nconst lowController = rendererFolder.add(rendererController, 'low')\nlowController.name('low (default)')\n// rendererFolder.add(rendererController, 'lowShadow')\n// rendererFolder.add(rendererController, 'lowShadowDoF')\n// rendererFolder.add(rendererController, 'high')\nscene.background = new Color(0x91abb5)\nscene.fog = new FogExp2(0x91abb5, 0.0005)\n\nconst drone = new Mesh(\n  new SphereBufferGeometry(5, 5, 5),\n  new MeshBasicMaterial({\n    color: 0xffffff\n  })\n)\ndrone.visible = false\nscene.add(drone)\n\nconst sunPosition = new Vector3()\nwindow.sunPosition = sunPosition\ninitSky(scene, sunPosition, gui)\ninitLights(scene, sunPosition)\ndirLight.target = drone\nscene.add(lensFlare)\n\n// ##########################\nconst waterParameters = {\n  oceanSide: 20000,\n  size: 1.0,\n  distortionScale: 3.7,\n  alpha: 1.0\n}\nconst waterGeometry = new PlaneBufferGeometry(waterParameters.oceanSide * 5, waterParameters.oceanSide * 5, 10, 10)\n\nconst textureLoader = new TextureLoader().setCrossOrigin('anonymous')\nconst water = new Water(\n  waterGeometry,\n  {\n    textureWidth: 512,\n    textureHeight: 512,\n    color: 0xffffff,\n    flowDirection: new Vector2(1, 1),\n    scale: 20000 / 15.0,\n    normalMap0: textureLoader.load(require('./textures/Water_1_M_Normal.jpg')),\n    normalMap1: textureLoader.load(require('./textures/Water_2_M_Normal.jpg')),\n    clipBias: 0.00001,\n    reflectivity: 0.2,\n    shader: WaterShader,\n    flowSpeed: 0.1\n  }\n)\nwindow.water = water\nconst waterTarget = new WebGLRenderTarget(window.innerWidth, window.innerHeight)\nconst depthMaterial = new MeshDepthMaterial()\nwaterTarget.depthBuffer = true\nwaterTarget.depthTexture = new DepthTexture()\nwater.material.uniforms.tDepth.value = waterTarget.depthTexture\n\nwater.up.set(0, 0, 1)\n// water.rotation.z = -Math.PI / 2\nwater.position.z = 75\nwater.material.uniforms.surface.value = water.position.z\ngui.__folders['Sun, sky and ocean'].add(water.position, 'z', 0, 200, 1)\nwater.receiveShadow = true\nwater.userData.isWater = true\nwindow.water = water\nscene.add(water)\n\nconst underwaterReflector = new Reflector(waterGeometry, {\n  textureWidth: 512,\n  textureHeight: 512,\n  clipBias: 0.00001\n  // shader: WaterRefractionShader\n})\nunderwaterReflector.rotation.y = Math.PI\nunderwaterReflector.up.set(0, 0, -1)\nunderwaterReflector.position.copy(water.position)\nunderwaterReflector.getRenderTarget().depthBuffer = true\nunderwaterReflector.getRenderTarget().depthTexture = new DepthTexture()\nwindow.ref = underwaterReflector\nunderwaterReflector.updateMatrixWorld()\n// ##########################\n\nsetupDrones()\n\nparticleGroups.forEach(group => scene.add(group.mesh))\n// var helper = new CameraHelper( camera );\n// scene.add( helper );\n\n// const shadowMapViewer = new ShadowMapViewer(dirLight)\nlet shakeCamera = false\nlet shakeAmplitude = 1\nPubSub.subscribe('x.camera.shake.start', (msg, value = 1) => (shakeCamera = true))\nPubSub.subscribe('x.camera.shake.stop', () => (shakeCamera = false))\n\nlet loops = [\n  () => lensFlare.position.copy(sunPosition),\n  terrainLoop,\n  (timestamp, delta) => {\n    particleGroups.forEach(group => group.tick(delta / 1000))\n  },\n  () => {\n    if (shakeCamera) {\n      camera.position.add({\n        x: (Math.random() - 0.5) * shakeAmplitude,\n        y: (Math.random() - 0.5) * shakeAmplitude,\n        z: (Math.random() - 0.5) * shakeAmplitude\n      })\n      glitch.enabled = true\n      motionPass.renderToScreen = false\n    } else {\n      glitch.enabled = false\n      motionPass.renderToScreen = true\n    }\n  },\n  () => scene.children.forEach(child => {\n    if (child instanceof LOD) {\n      child.update(camera)\n    }\n  }),\n  (timestamp, delta) => {\n    if (camera.position.z < water.position.z) {\n      underwaterPass.enabled = true\n      wigglePass.enabled = true\n      water.visible = false\n      underwaterReflector.onBeforeRender(renderer, scene, camera)\n      underwaterPass.material.uniforms.time.value = timestamp / 1000\n      wigglePass.material.uniforms.time.value = timestamp / 1000\n      controls.setAcceleration(30)\n    } else {\n      underwaterPass.enabled = false\n      wigglePass.enabled = false\n      water.visible = true\n      controls.setAcceleration(100)\n    }\n  }\n]\nconst removeLoop = (loop) => {\n  loops = loops.filter(item => item !== loop)\n}\nPubSub.subscribe('x.loops.remove', (msg, loop) => removeLoop(loop))\nPubSub.subscribe('x.loops.push', (msg, loop) => loops.push(loop))\nPubSub.subscribe('x.loops.unshift', (msg, loop) => loops.unshift(loop))\n\nwindow.loops = loops\nPubSub.publish('x.loops.loaded')\nconst cleanLoops = () => {\n  loops.forEach(loop => {\n    if (loop.alive !== undefined && loop.alive === false && loop.object) {\n      scene.remove(loop.object)\n    }\n  })\n  loops = loops.filter(loop => loop.alive === undefined || loop.alive === true)\n}\n\n// Start the app\nrenderer.setPixelRatio(1.0)\n\nconst stats = new Stats()\ndocument.body.appendChild(stats.dom)\n\n// ###################################\n// EFFECTS\n// define a render target with a depthbuffer\nconst target = new WebGLRenderTarget(window.innerWidth, window.innerHeight)\nconst composer = new EffectComposer(renderer, target)\n\n// initial render pass\nconst renderPass = new RenderPass(scene, camera)\ncomposer.addPass(renderPass)\n\n// add an underwater shader pass\nconst underwaterPass = new ShaderPass(UnderwaterShader)\nunderwaterPass.enabled = false\nunderwaterPass.material.uniforms.waterLevel.value = water.position.z\nunderwaterPass.material.uniforms.tDepth.value = waterTarget.depthTexture\nunderwaterPass.material.uniforms.cameraPosition.value = camera.position\nunderwaterPass.material.uniforms.sunPosition.value = sunPosition\nunderwaterPass.material.uniforms.tReflectionMap.value = underwaterReflector.getRenderTarget().texture\nunderwaterPass.material.uniforms.tReflectionDepth.value = underwaterReflector.getRenderTarget().depthTexture\nlet tNormalMap0 = underwaterPass.material.uniforms.tNormalMap0\nlet tNormalMap1 = underwaterPass.material.uniforms.tNormalMap1\ntNormalMap0.value = textureLoader.load(require('./textures/Water_1_M_Normal.jpg'))\ntNormalMap1.value = textureLoader.load(require('./textures/Water_2_M_Normal.jpg'))\ntNormalMap0.value.wrapS = tNormalMap0.value.wrapT = RepeatWrapping\ntNormalMap1.value.wrapS = tNormalMap1.value.wrapT = RepeatWrapping\ncomposer.addPass(underwaterPass)\nwindow.upass = underwaterPass\n\n// add an underwater wiggle pass\nconst wigglePass = new ShaderPass(WiggleShader)\nwigglePass.enabled = false\ncomposer.addPass(wigglePass)\n\n// add a motion blur pass\nconst motionPass = new ShaderPass(motionBlurShader, 'tColor')\nmotionPass.renderToScreen = true\nmotionPass.material.uniforms.tDepth.value = waterTarget.depthTexture\nmotionPass.material.uniforms.velocityFactor.value = 1\ncomposer.addPass(motionPass)\n\n// define variables used by the motion blur pass\nlet previousMatrixWorldInverse = new Matrix4()\nlet previousProjectionMatrix = new Matrix4()\nlet previousCameraPosition = new Vector3()\nlet tmpMatrix = new Matrix4()\n\n// add a glitch pass\nconst glitch = new GlitchPass()\nglitch.renderToScreen = true\ncomposer.addPass(glitch)\n// ###################################\n\nlet play = true\nPubSub.subscribe('x.toggle.play', () => { play = !play })\n\nlet lastTimestamp = 0\nvar mainLoop = (timestamp) => {\n  requestAnimationFrame(mainLoop)\n  let delta = timestamp - lastTimestamp\n  lastTimestamp = timestamp\n\n  if (play) {\n    loops.forEach(loop => {\n      loop.loop ? loop.loop(timestamp, delta) : loop(timestamp, delta)\n    })\n\n    // update motion blur shader uniforms\n    motionPass.material.uniforms.delta.value = delta\n    // tricky part to compute the clip-to-world and world-to-clip matrices\n    motionPass.material.uniforms.clipToWorldMatrix.value\n      .getInverse(camera.matrixWorldInverse).multiply(tmpMatrix.getInverse(camera.projectionMatrix))\n    motionPass.material.uniforms.previousWorldToClipMatrix.value\n      .copy(previousProjectionMatrix.multiply(previousMatrixWorldInverse))\n    motionPass.material.uniforms.cameraMove.value.copy(camera.position).sub(previousCameraPosition)\n\n    // render to depth target\n    scene.overrideMaterial = depthMaterial\n    water.visible = false\n    renderer.setRenderTarget(waterTarget)\n    renderer.render(scene, camera)\n    water.visible = true\n    scene.overrideMaterial = null\n\n    // water uniforms\n    water.material.uniforms.clipToWorldMatrix.value = motionPass.material.uniforms.clipToWorldMatrix.value\n    underwaterPass.material.uniforms.clipToWorldMatrix.value = motionPass.material.uniforms.clipToWorldMatrix.value\n    underwaterPass.material.uniforms.worldToClipMatrix.value\n      .copy(camera.projectionMatrix).multiply(camera.matrixWorldInverse)\n\n    // render the postprocessing passes\n    composer.render(delta)\n\n    // save some values for the next render pass\n    previousMatrixWorldInverse.copy(camera.matrixWorldInverse)\n    previousProjectionMatrix.copy(camera.projectionMatrix)\n    previousCameraPosition.copy(camera.position)\n\n    // if (dirLight.shadow && dirLight.shadow.map) {\n    //   shadowMapViewer.render(renderer)\n    // }\n  }\n\n  cleanLoops()\n\n  stats.update()\n}\n\nmainLoop(0)\n\nWindowResize(renderer, camera)\n\nexport { renderer, scene, camera, drone, sunPosition, gui, options, loops }\n","import {\n  Mesh,\n  // SphereBufferGeometry,\n  SphereGeometry,\n  MeshBasicMaterial,\n  BackSide\n} from 'three'\nimport { Sky } from '../modules/Sky'\nimport { dirLight } from '../lights'\n\nfunction initSky (scene, sunPosition, gui) {\n  // Add Sky\n  const sky = new Sky()\n  sky.scale.setScalar(450000)\n  scene.add(sky)\n\n  // Add Sun Helper\n  // const sunSphere = new Mesh(\n  //     new SphereBufferGeometry( 20000, 16, 8 ),\n  //     new MeshBasicMaterial( { color: 0xffffff } )\n  // );\n  // sunSphere.position.y = - 700000;\n  // sunSphere.visible = false;\n  // scene.add( sunSphere );\n\n  var skyGeo = new SphereGeometry(1e5, 8, 8)\n  // flip faces so that overrideMaterial MeshDepthMatrial renders the skydome\n  // cf. https://stackoverflow.com/a/21485105/343834\n  for (let i = 0; i < skyGeo.faces.length; i++) {\n    const face = skyGeo.faces[i]\n    const temp = face.a\n    face.a = face.c\n    face.c = temp\n  }\n  var material = new MeshBasicMaterial({\n    opacity: 0\n  })\n  var skyDome = new Mesh(skyGeo, material)\n  skyDome.material.side = BackSide\n  scene.add(skyDome)\n\n  /// GUI\n\n  var effectController = {\n    turbidity: 10,\n    rayleigh: 2,\n    mieCoefficient: 0.005,\n    mieDirectionalG: 0.8,\n    luminance: 1,\n    inclination: 0.32, // elevation / inclination\n    azimuth: 0.2, // Facing front,\n    sun: !true\n  }\n\n  if (gui) {\n    var distance = 400000\n    function guiChanged () { // eslint-disable-line\n      var uniforms = sky.material.uniforms\n      uniforms.turbidity.value = effectController.turbidity\n      uniforms.rayleigh.value = effectController.rayleigh\n      uniforms.luminance.value = effectController.luminance\n      uniforms.mieCoefficient.value = effectController.mieCoefficient\n      uniforms.mieDirectionalG.value = effectController.mieDirectionalG\n\n      var theta = Math.PI * (effectController.inclination - 0.5)\n      var phi = 2 * Math.PI * (effectController.azimuth - 0.5)\n\n      sunPosition.x = distance * Math.cos(phi)\n      sunPosition.z = distance * Math.sin(phi) * Math.sin(theta)\n      sunPosition.y = distance * Math.sin(phi) * Math.cos(theta)\n\n      // sunSphere.visible = effectController.sun;\n\n      uniforms.sunPosition.value.copy(sunPosition)\n      sunPosition.copy(sunPosition)\n\n      dirLight.position.copy(sunPosition)\n      dirLight.position.normalize()\n      dirLight.position.multiplyScalar(2000.0)\n    }\n\n    const folder = gui.addFolder('Sun, sky and ocean')\n    folder.add(effectController, 'turbidity', 1.0, 20.0, 0.1).onChange(guiChanged)\n    folder.add(effectController, 'rayleigh', 0.0, 4, 0.001).onChange(guiChanged)\n    folder.add(effectController, 'mieCoefficient', 0.0, 0.1, 0.001).onChange(guiChanged)\n    folder.add(effectController, 'mieDirectionalG', 0.0, 1, 0.001).onChange(guiChanged)\n    folder.add(effectController, 'luminance', 0.0, 2).onChange(guiChanged)\n    folder.add(effectController, 'inclination', 0, 1, 0.0001).onChange(guiChanged)\n    folder.add(effectController, 'azimuth', 0, 1, 0.0001).onChange(guiChanged)\n    folder.add(effectController, 'sun').onChange(guiChanged)\n\n    guiChanged()\n  }\n\n  return sky\n}\n\nexport { initSky }\n","import PubSub from '../events'\n\nconst WindowResize = function (renderer, camera, dimension) {\n  dimension = dimension || function () { return { width: window.innerWidth, height: window.innerHeight } }\n  var callback = function () {\n        // fetch target renderer size\n    var rendererSize = dimension()\n        // notify the renderer of the size change\n    renderer.setSize(rendererSize.width, rendererSize.height)\n        // update the camera\n    camera.aspect = rendererSize.width / rendererSize.height\n    camera.updateProjectionMatrix()\n\n    PubSub.publish('x.screen.resized', rendererSize)\n  }\n    // bind the resize event\n  window.addEventListener('resize', callback, false)\n    // return .stop() the function to stop watching window resize\n  return {\n    trigger: function () {\n      callback()\n    },\n        /**\n         * Stop watching window resize\n        */\n    destroy: function () {\n      window.removeEventListener('resize', callback)\n    }\n  }\n}\n\nexport {WindowResize}\n"],"sourceRoot":""}