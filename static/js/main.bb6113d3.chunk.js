(this.webpackJsonp=this.webpackJsonp||[]).push([[0],{114:function(e,t,n){e.exports=n.p+"static/media/Rock_08_UV_H_CM_1.da494a88.jpg"},115:function(e,t,n){e.exports=n.p+"static/media/Rock_08_UV_H_CM_1_normal.6085c2f7.jpg"},137:function(e,t,n){e.exports=n.p+"static/media/GrassGreenTexture_1024.3f1df3f0.jpg"},138:function(e,t,n){e.exports=n.p+"static/media/GrassGreenTexture_1024_normal.ce43156e.jpg"},157:function(e,t,n){e.exports=n.p+"static/media/Water_1_M_Normal.a33d50da.jpg"},158:function(e,t,n){e.exports=n.p+"static/media/Water_2_M_Normal.639428cf.jpg"},167:function(e,t,n){e.exports=function(){return new Worker(n.p+"static/js/terrain.worker.f5d6880c.js")}},168:function(e,t){e.exports="#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\tvarying vec3 vNormal2;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <envmap_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\t#include <envmap_vertex>\n\n\tvNormal2 = normal;\n}\n"},169:function(e,t){e.exports="#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n// ####### custom uniforms #########\nuniform sampler2D rockTexture;\nuniform sampler2D rockTextureNormal;\n// #################################\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal2;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <envmap_physical_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvec4 physicalColor(sampler2D map, sampler2D normalMap, float roughness, float metalness) {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t// #include <specularmap_fragment>\n\t// #include <envmap_fragment>\n\t// return vec4(envColor.rgb, 1.0);\n\treturn vec4(outgoingLight, diffuseColor.a);\n}\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 grassColor = physicalColor(map, normalMap, roughness, metalness);\n\tvec4 rockColor = physicalColor(rockTexture, rockTextureNormal, 0.4, 0.15);\n\tvec3 normal = normalize( vNormal2 );\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\tfloat flatness = dot(normal, vec3(0.0, 0.0, 1.0));\n\tvec4 colorTerrain = mix(\n\t\trockColor,\n\t\t// rockColor,\n\t\tgrassColor,\n\t\tsmoothstep(0.6, 0.7, flatness)\n\t);\n\tgl_FragColor = colorTerrain;\n\t// gl_FragColor = vec4(vec3(vWorldPosition.z/100.0), 1.0);\n\tvec3 outgoingLight = gl_FragColor.rgb;\n\t#include <specularmap_fragment>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4(outgoingLight.rgb, gl_FragColor.a);\n\n\n\t// gl_FragColor = vec4(material.specularColor, 1.0);\n\t// gl_FragColor = vec4(reflectedLight.indirectDiffuse, 1.0);\n\t// gl_FragColor = vec4(directLight.direction, 1.0);\n\t// // gl_FragColor = texture2D(map, vUv);\n\t// gl_FragColor = vec4(normal, 1.0);\n\t// gl_FragColor = vec4(material.diffuseColor, 1.0);\n\t// gl_FragColor = vec4(metalness, metalness, metalness, 1.0);\n\t// gl_FragColor = vec4(diffuseColor.rgb * ( 1.0 - metalnessFactor ), 1.0);\n\t// gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n\t//  FOG\n\t// #include <fog_fragment>\n\treflectVec = refract( cameraToVertex, worldNormal, 1.0 );\n\tvec4 fogColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\tfogFactor = mix(fogFactor, fogFactor / 10.0, smoothstep(100.0, 300.0, vWorldPosition.z));\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor.rgb, fogFactor );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n"},170:function(e,t){e.exports="precision highp float;\nprecision highp int;\n#define USE_FOG\n\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform mat3 uvTransform;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec3 vNormal2;\nvarying float flatness;\nvarying vec3 vWorldPosition;\nvarying vec2 vUv;\nvarying vec2 vUv2;\nvarying float fogDepth;\n\nvoid main() {\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tvUv2 = uv2;\n\n\tvec3 objectNormal = vec3( normal );\n\n\tvec3 transformedNormal = normalMatrix * objectNormal;\n\n\n\tvNormal = normalize( transformedNormal );\n\n\tvec3 transformed = vec3( position );\n\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t// #include <worldpos_vertex>\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n\tfogDepth = -mvPosition.z;\n\n\tvNormal2 = normalize(normal);\n\tflatness = dot(normal, vec3(0.0, 0.0, 1.0));\n  \tvWorldPosition = position;\n}\n"},171:function(e,t){e.exports="#extension GL_OES_standard_derivatives : enable\nprecision highp float;\nprecision highp int;\n#define SHADER_NAME ShaderMaterial\n#define STANDARD \n#define USE_MAP \n#define USE_NORMALMAP \n#define GAMMA_FACTOR 2\n#define USE_FOG\n#define FOG_EXP2\n#define PHYSICALLY_CORRECT_LIGHTS\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n#define TONE_MAPPING\n#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}\nvec3 toneMapping( vec3 color ) { return Uncharted2ToneMapping( color ); }\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\nvec4 mapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }\nvec4 matcapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }\nvec4 envMapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }\nvec4 emissiveMapTexelToLinear( vec4 value ) { return GammaToLinear( value, float( GAMMA_FACTOR ) ); }\nvec4 linearToOutputTexel( vec4 value ) { return LinearToGamma( value, float( GAMMA_FACTOR ) ); }\n\n#define STANDARD\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n// ####### custom uniforms #########\nuniform sampler2D rockTexture;\nuniform sampler2D rockTextureNormal;\n// #################################\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal2;\nvarying float flatness;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n\n#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if 1 > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ 1 ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if 0 > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ 0 ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if 0 > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ 0 ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if 0 > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ 0 ];\n#endif\n#if 1 > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ 1 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\nstruct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if 0 > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n#ifdef USE_SHADOWMAP\n\t#if 1 > 0\n\t\tuniform sampler2D directionalShadowMap[ 1 ];\n\t\tvarying vec4 vDirectionalShadowCoord[ 1 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform sampler2D spotShadowMap[ 0 ];\n\t\tvarying vec4 vSpotShadowCoord[ 0 ];\n\t#endif\n\t#if 0 > 0\n\t\tuniform sampler2D pointShadowMap[ 0 ];\n\t\tvarying vec4 vPointShadowCoord[ 0 ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t// Per-Pixel Tangent Space Normal Mapping\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, sampler2D normalMap) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n\n#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n#if 0 > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ 0 ];\n#endif\n\nvec4 physicalColor(sampler2D map, sampler2D normalMap, float roughness, float metalness) {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\tvec2 vUvXY = vec2(mod(vWorldPosition.x, 100.0) / 100.0, mod(vWorldPosition.y, 100.0) / 100.0 );\n\tvec2 vUvXZ = vec2(mod(vWorldPosition.x, 100.0) / 100.0 , mod(vWorldPosition.z, 100.0) / 100.0 );\n\tvec2 vUvYZ = vec2(mod(vWorldPosition.y, 100.0) / 100.0 , mod(vWorldPosition.z, 100.0) / 100.0 );\n\n\tvec3 mixer = clamp(abs(vNormal2), 0.0, 1.0);\n\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif\n\n\t// #include <map_fragment>\n\tvec4 texelColorXY = texture2D( map, vUvXY );\n\tvec4 texelColorXZ = texture2D( map, vUvXZ );\n\tvec4 texelColorYZ = texture2D( map, vUvYZ );\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 texelColor = (\n\t\tmix(black, texelColorXY, pow(mixer.z, 2.5)) +\n\t\tmix(black, texelColorXZ, pow(mixer.y, 2.5)) +\n\t\tmix(black, texelColorYZ, pow(mixer.x, 2.5))\n\t);\n\t// texelColor = texelColorXY;\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\t// return diffuseColor;\n\n\nvec3 normal = normalize( vNormal );\nnormal = perturbNormal2Arb( -vViewPosition, normal, normalMap);\n\n\t// accumulation\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalness );\nmaterial.specularRoughness = clamp( roughness, 0.04, 1.0 );\nmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalness );\n\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n\n#if ( 1 > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t\n\t\tdirectionalLight = directionalLights[ 0 ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ 0 ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ 0 ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( 1 > 0 )\n\t\t\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ 0 ], geometry );\n\t\t\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t// #include <specularmap_fragment>\n\t// #include <envmap_fragment>\n\t// return vec4(envColor.rgb, 1.0);\n\treturn vec4(outgoingLight, diffuseColor.a);\n}\n\nvoid main() {\n\n\tvec4 grassColor = physicalColor(map, normalMap, roughness, metalness);\n\tvec4 rockColor = physicalColor(rockTexture, rockTextureNormal, 0.4, 0.15);\n\tvec4 colorTerrain = mix(\n\t\trockColor,\n\t\tgrassColor,\n\t\tsmoothstep(0.6, 0.7, flatness)\n\t);\n\tgl_FragColor = colorTerrain;\n\t// gl_FragColor = vec4(vec3(vWorldPosition.z/100.0), 1.0);\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n\t// gl_FragColor = vec4(normal, 1.0);\n\n}\n"},172:function(e,t){e.exports="#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\nvarying vec3 vNormal2;\nvarying float flatness;\nvarying vec3 vWorldPosition;\nvarying vec2 vNoise;\n\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec4 P){\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 / 7.0;\n  vec4 gy00 = floor(gx00) / 7.0;\n  vec4 gz00 = floor(gy00) / 6.0;\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 / 7.0;\n  vec4 gy01 = floor(gx01) / 7.0;\n  vec4 gz01 = floor(gy01) / 6.0;\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 / 7.0;\n  vec4 gy10 = floor(gx10) / 7.0;\n  vec4 gz10 = floor(gy10) / 6.0;\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 / 7.0;\n  vec4 gy11 = floor(gx11) / 7.0;\n  vec4 gz11 = floor(gy11) / 6.0;\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t// transformed = floor(transformed);\n\n\t// #include <worldpos_vertex>\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n\tvNormal2 = normalize(normal);\n\tflatness = dot(normal, vec3(0.0, 0.0, 1.0));\n\tvWorldPosition = position;\n\t// uvnoise = vec2(\n\t// \t// (sin((position.x + position.y + position.z) + / 30.0)) * 0.3333332,\n\n\t// \t// (sin(position.x / 10.0) + sin(position.y / 10.0) + sin(1.5 + position.z / 10.0)) * 0.3333332,\n\t// \t// (sin(position.x / 10.0) + sin(position.y / 10.0) + sin(1.5 + position.z / 10.0)) * 0.3333332\n\n\t// \t// mod((position.x + position.y + position.z), 10.0) / 10.0,\n\t// \t// mod((position.x + position.y + position.z), 10.0) / 10.0\n\n\t// \t// mod(mod(position.x, 1.0) + position.z, 1.0),\n\t// \t// mod(mod(position.y, 1.0) + position.z, 1.0)\n\n\t// \t// mod(position.x + 0.5 * cnoise(vec4(position, 1.0)), 10.0) / 10.0,\n\t// \t// mod(position.y + 0.5 * cnoise(vec4(position.zyx, 1.0)), 10.0) / 10.0\n\n  vNoise = vec2(\n    noise(position / 50.0),\n    noise(position.zyx / 50.0)\n  );\n\n\t// \t// cos(position / 5.0) * 0.5 + 0.5,\n\t// \t// cos(position.zyx / 5.0) * 0.5 + 0.5\n\n\t// \t// noise(position.xyz) * mod(position.z, 10.0) / 10.0,\n\t// \t// noise(position.zyx) * mod(position.z, 10.0) / 10.0\n\t// );\n\t// vUv = uvnoise;\n\n\t// vec2 vUvXY = vec2(mod(position.x, 100.0) / 100.0, mod(position.y, 100.0) / 100.0 );\n\t// vec2 vUvXZ = vec2(mod(position.x, 100.0) / 100.0 , mod(position.z, 100.0) / 100.0 );\n\t// vec2 vUvYZ = vec2(mod(position.y, 100.0) / 100.0 , mod(position.z, 100.0) / 100.0 );\n\n\t// vec3 mixer = clamp(abs(normal), 0.0000001, 1.0);\n\t// vec2 zero2 = vec2(0.0, 0.0);\n\t// vUv = (\n\t// \tmix(zero2, vUvXY, pow(mixer.z, 2.5)) +\n\t// \tmix(zero2, vUvXZ, pow(mixer.y, 2.5)) +\n\t// \tmix(zero2, vUvYZ, pow(mixer.x, 2.5))\n\t// );\n}\n"},173:function(e,t){e.exports="#define STANDARD\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n// ####### custom uniforms #########\nuniform sampler2D rockTexture;\nuniform sampler2D rockTextureNormal;\n// #################################\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPosition;\nvarying vec2 vNoise;\nvarying vec3 vNormal2;\nvarying float flatness;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <envmap_physical_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t// Per-Pixel Tangent Space Normal Mapping\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 vUv1, vec2 vUv2, vec2 vUv3) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN1 = texture2D( normalMap, vUv1 ).xyz;\n\t\tvec3 mapN2 = texture2D( normalMap, vUv2 ).xyz;\n\t\tvec3 mapN3 = texture2D( normalMap, vUv3 ).xyz;\n\t\tvec3 black = vec3(0.0, 0.0, 0.0);\n\t\tvec3 mapN = (\n\t\t\tmix(black, mapN1, pow(N.z, 2.5)) +\n\t\t\tmix(black, mapN2, pow(N.y, 2.5)) +\n\t\t\tmix(black, mapN3, pow(N.x, 2.5))\n\t\t);\n\t\t// return mapN;\n\t\tmapN = mapN * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvec4 physicalColor(sampler2D map, sampler2D normalMap, float roughness, float metalness) {\n\n\t// return vec4(vUv, 0.0, 1.0);\n\t// return vec4(clamp(vNormal2.z, 0.0, 1.0), 0.0, 0.0, 1.0);\n\t// return vec4(cos(vWorldPosition.xyz / 5.0) * 0.5 + 0.5, 1.0);\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\tvec2 vUvXY = vec2(mod(vWorldPosition.x, 100.0) / 100.0, mod(vWorldPosition.y, 100.0) / 100.0 );\n\tvec2 vUvXZ = vec2(mod(vWorldPosition.x, 100.0) / 100.0 , mod(vWorldPosition.z, 100.0) / 100.0 );\n\tvec2 vUvYZ = vec2(mod(vWorldPosition.y, 100.0) / 100.0 , mod(vWorldPosition.z, 100.0) / 100.0 );\n\n\tvec3 mixer = clamp(abs(vNormal2), 0.0, 1.0);\n\n\t#include <logdepthbuf_fragment>\n\n\t// #include <map_fragment>\n\tvec4 texelColorXY = texture2D( map, vUvXY );\n\tvec4 texelColorXZ = texture2D( map, vUvXZ );\n\tvec4 texelColorYZ = texture2D( map, vUvYZ );\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 texelColor = (\n\t\tmix(black, texelColorXY, pow(mixer.z, 2.5)) +\n\t\tmix(black, texelColorXZ, pow(mixer.y, 2.5)) +\n\t\tmix(black, texelColorYZ, pow(mixer.x, 2.5))\n\t);\n\t// texelColor = texelColorXY;\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\t// return diffuseColor;\n\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t// #include <normal_fragment_maps>\n\t// normal = perturbNormal2Arb( -vViewPosition, normal , vUvXY, vUvXZ, vUvYZ);\n\t// return vec4(normal, 1.0);\n\t// #include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t// #include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t// #include <specularmap_fragment>\n\t// #include <envmap_fragment>\n\t// return vec4(envColor.rgb, 1.0);\n\treturn vec4(outgoingLight, diffuseColor.a);\n}\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 grassColor = physicalColor(map, normalMap, roughness, metalness);\n\tvec4 rockColor = physicalColor(rockTexture, rockTextureNormal, 0.4, 0.15);\n\tvec4 colorTerrain = mix(\n\t\trockColor,\n\t\tgrassColor,\n\t\tsmoothstep(0.15, 0.3, flatness * vNoise.x + flatness * vNoise.y)\n\t\t// smoothstep(vNoise.x, vNoise.y, flatness)\n\t);\n\tgl_FragColor = colorTerrain;\n\t// gl_FragColor = vec4(vec3(vWorldPosition.z/100.0), 1.0);\n\tvec3 outgoingLight = gl_FragColor.rgb;\n\t#include <specularmap_fragment>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4(outgoingLight.rgb, gl_FragColor.a);\n\n\n\t// gl_FragColor = vec4(material.specularColor, 1.0);\n\t// gl_FragColor = vec4(reflectedLight.indirectDiffuse, 1.0);\n\t// gl_FragColor = vec4(directLight.direction, 1.0);\n\t// // gl_FragColor = texture2D(map, vUv);\n\t// gl_FragColor = vec4(normal, 1.0);\n\t// gl_FragColor = vec4(material.diffuseColor, 1.0);\n\t// gl_FragColor = vec4(metalness, metalness, metalness, 1.0);\n\t// gl_FragColor = vec4(diffuseColor.rgb * ( 1.0 - metalnessFactor ), 1.0);\n\t// gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n\t#include <fog_fragment>\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n\t// gl_FragColor = vec4(flatness, flatness, flatness, 1.0);\n\n}\n"},174:function(e,t,n){e.exports=function(){return new Worker(n.p+"static/js/voxel.worker.626df7dc.js")}},178:function(e,t){e.exports="#include <common>\n#include <fog_pars_fragment>\n\nuniform sampler2D tReflectionMap;\nuniform sampler2D tRefractionMap;\nuniform sampler2D tNormalMap0;\nuniform sampler2D tNormalMap1;\nuniform sampler2D tDepth;\n\n#ifdef USE_FLOWMAP\nuniform sampler2D tFlowMap;\n#else\nuniform vec2 flowDirection;\n#endif\n\nuniform vec3 color;\nuniform float reflectivity;\nuniform float surface;\nuniform vec4 config;\nuniform mat4 clipToWorldMatrix;\n\nvarying vec4 vCoord;\nvarying vec2 vUv;\nvarying vec3 vToEye;\n\nvec3 surfaceColor = vec3(0.0078, 0.5176, 0.7);\nvec3 shoreColor = vec3(0.0078, 0.5176, 0.7);\nvec3 depthColor = vec3(0.0039, 0.00196, 0.145);\n// Description : Water color based on water depth and color extinction\n//\n// based on Rendering Water as a Post-process Effect by Wojciech Toman\n//\n\n// waterTransparency - x = , y = water visibility along eye vector,\n// waterDepthValues - x = water depth in world space, y = view/accumulated water depth in world space\nvec3 DepthRefraction(float waterDepth, float viewWaterDepth, vec3 refractionColor)\n{\n  float waterClarity = 0.75;\n  float visibility = 200.;\n  float shoreRange = 50.;\n  float horizontalExtinction = 200.;\n\n  float accDepth = viewWaterDepth * waterClarity; // accumulated water depth\n  float accDepthExp = saturate(accDepth / (2.5 * visibility));\n  accDepthExp *= (1.0 - accDepthExp) * accDepthExp * accDepthExp + 1.0; // out cubic\n\n  surfaceColor = mix(shoreColor, surfaceColor, saturate(waterDepth / shoreRange));\n  vec3 waterColor = mix(surfaceColor, depthColor, saturate(waterDepth / horizontalExtinction));\n\n  refractionColor = mix(refractionColor, surfaceColor * waterColor, saturate(accDepth / visibility));\n  refractionColor = mix(refractionColor, depthColor, accDepthExp);\n  refractionColor = mix(refractionColor, depthColor * waterColor, saturate(waterDepth / horizontalExtinction));\n  return refractionColor;\n}\n\nvoid main() {\n\n  float flowMapOffset0 = config.x;\n  float flowMapOffset1 = config.y;\n  float halfCycle = config.z;\n  float scale = config.w;\n\n  vec3 toEye = normalize( vToEye );\n  vec3 surfacePosition = cameraPosition - vToEye;\n\n  // determine flow direction\n  vec2 flow;\n  #ifdef USE_FLOWMAP\n  flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n  #else\n  flow = flowDirection;\n  #endif\n  flow.x *= - 1.0;\n\n  // sample normal maps (distort uvs with flowdata)\n  vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n  vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n  // linear interpolate to get the final normal color\n  float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n  vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n  // calculate normal vector\n  //  vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n  vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0,  normalColor.g * 2.0 - 1.0, normalColor.b ));\n\n  // calculate the fresnel term to blend reflection and refraction maps\n  float theta = max( dot( toEye, normal ), 0.0 );\n  float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n  // calculate final uv coords\n  vec3 coord = vCoord.xyz / vCoord.w;\n  vec2 uv = coord.xy + coord.z * normal.xy * 0.1;\n\n  vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n  vec4 refractColor = texture2D( tRefractionMap, uv );\n\n  // water depth\n\n  float zOverW = texture2D(tDepth, coord.xy).x;\n  // clipPosition is the viewport position at this pixel in the range -1 to 1.\n  vec4 clipPosition = vec4(coord.xy * 2. - 1., zOverW * 2. - 1., 1.);\n  vec4 worldPosition = clipToWorldMatrix * clipPosition;\n  worldPosition /= worldPosition.w;\n\n  float waterDepth = surfacePosition.z - worldPosition.z;\n  float viewWaterDepth = length(surfacePosition - worldPosition.xyz);\n\n  float depthDensity = 0.01;\n  float depthFactor = whiteCompliment( exp2( - depthDensity * depthDensity * viewWaterDepth * viewWaterDepth * LOG2 ) );\n  refractColor.rgb = mix( refractColor.rgb, depthColor, depthFactor );\n  // refractColor.rgb = DepthRefraction(waterDepth, viewWaterDepth, refractColor.rgb);\n\n  // multiply water color with the mix of both textures\n  gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n  // gl_FragColor = refractColor;\n  // gl_FragColor = vec4(vec3(waterDepth/500.), 1.0);\n\n  // #include <tonemapping_fragment>\n  // #include <encodings_fragment>\n  // #include <fog_fragment>\n\n}"},179:function(e,t){e.exports="#include <fog_pars_vertex>\n\nuniform mat4 textureMatrix;\n\nvarying vec4 vCoord;\nvarying vec2 vUv;\nvarying vec3 vToEye;\n\nvoid main() {\n\n  vUv = uv;\n  vCoord = textureMatrix * vec4( position, 1.0 );\n\n  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n  vToEye = cameraPosition - worldPosition.xyz;\n\n  vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n  gl_Position = projectionMatrix * mvPosition;\n\n  #include <fog_vertex>\n\n}"},180:function(e,t){e.exports="#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nuniform sampler2D tReflectionMap;\nuniform sampler2D tReflectionDepth;\nuniform sampler2D tNormalMap0;\nuniform sampler2D tNormalMap1;\n\n#ifdef USE_FLOWMAP\nuniform sampler2D tFlowMap;\n#else\nuniform vec2 flowDirection;\n#endif\n\nuniform vec3 color;\nuniform float reflectivity;\nuniform float time;\nuniform float waterLevel;\nuniform vec4 config;\nuniform vec3 sunPosition;\nuniform mat4 clipToWorldMatrix;\nuniform mat4 worldToClipMatrix;\n\nvarying vec4 vCoord;\nvarying vec2 vUv;\nvarying vec3 vToEye;\n\n// vec3 depthColor = vec3(0.0039, 0.00196, 0.145);\nvec3 depthColor = vec3(0.0117, 0.0117, 0.325);\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\nvec3 caustic(vec2 uv) {\n  vec2 p = mod(uv*TAU, TAU)-250.0;\n\n  vec2 i = vec2(p);\n  float c = 1.0;\n  float inten = .005;\n\n  for (int n = 0; n < MAX_ITER; n++) {\n    float t = time * (1.0 - (3.5 / float(n+1)));\n    i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n    c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n  }\n\n  c /= float(MAX_ITER);\n  c = 1.17-pow(c, 1.4);\n  vec3 color = vec3(pow(abs(c), 8.0));\n  // color = clamp(color + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n  color = mix(color, vec3(1.0,1.0,1.0),0.5);\n\n  return color;\n}\n\nfloat causticX(float x, float power, float gtime) {\n  float p = mod(x*TAU, TAU)-250.0;\n\n  float i = p;;\n  float c = 1.0;\n  float inten = .005;\n\n  for (int n = 0; n < MAX_ITER/2; n++) {\n    float t = gtime * (1.0 - (3.5 / float(n+1)));\n    i = p + cos(t - i) + sin(t + i);\n    c += 1.0/length(p / (sin(i+t)/inten));\n  }\n  c /= float(MAX_ITER);\n  c = 1.17-pow(c, power);\n\n  return c;\n}\n\nfloat GodRays(vec2 uv) {\n  float light = 0.0;\n  vec4 uvSun = worldToClipMatrix * vec4(sunPosition, 1.);\n  uvSun /= uvSun.w;\n  uvSun = uvSun / 2. + 0.5;\n  vec2 uv2 = vec2(\n    dot(normalize(uv - uvSun.xy), vec2(1., 0.)),\n    length(uv - uvSun.xy)\n  );\n\n  light += pow(causticX((uv2.x + 0.08 * uv2.y) / 1.7 + 0.5, 1.8, time * 0.65), 10.0) * 0.05;\n  light += pow(causticX(sin(uv2.x), 0.3, time * 0.7), 9.0) * 0.4;\n  light += pow(causticX(cos(uv2.x * 2.3), 0.3, time * 1.3), 4.0) * 0.1;\n\n  light *= smoothstep(0., .3, uv2.y) * smoothstep(0., .3, uv2.y);\n  light = clamp(light, 0.0, 1.0);\n\n  return light;\n}\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nfloat hash11(float p)\n{\n  vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n  p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nconst int   STAR_VOXEL_STEPS = 8;\nconst float STAR_VOXEL_STEP_SIZE = 3.;\n\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p - ro, rd);\n    return length(p - ro - rd * h);\n}\nvec3 getDotColour(float t)\n{\n  return vec3(t*.57,t*.3,t*.05);\n  return vec3(t*.9,t*.9,t*.9);\n  return vec3(t*.3,t*.6,t*.5);\n}\n\n// This code is the starfield stuff from iapafoto\n// https://www.shadertoy.com/view/Xl2BRR\nvec4 detritus(in vec3 ro, in vec3 rd, in float tmax) {\n\n  float d =  0.;\n\n  vec3 ros = ro + rd*d;\n  ros /= STAR_VOXEL_STEP_SIZE;\n  vec3 pos = floor(ros),\n       mm, ri = 1./rd,\n       rs = sign(rd),\n       dis = (pos - ros + 0.5 + rs * 0.5) * ri;\n\n  float dint;\n  vec3 offset, id;\n  vec4 col = vec4(0);\n  vec4 sum = vec4(0);\n\n  for(int i = 0; i < STAR_VOXEL_STEPS; i++) {\n    id = hash33(pos);\n    float size  = hash11(float(i))*.02 + .005;\n    offset = clamp(id + .2 * cos(id + id.x * time), size, 1. - size);\n    d = distanceRayPoint(ros, rd, pos + offset, dint);\n\n    if (dint > 0. && dint * STAR_VOXEL_STEP_SIZE < tmax) {\n      col = vec4(getDotColour(id.x), .8) * smoothstep(size, 0.0, d);\n      col.a *= smoothstep(float(STAR_VOXEL_STEPS), 0., dint);\n      col.rgb *= col.a / dint;\n      sum += (1. - sum.a) * col;\n      if (sum.a>.99) break;\n    }\n\n    mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n    dis += mm * rs * ri;\n    pos += mm * rs;\n  }\n\n  return sum * .75;\n}\n\n\nvoid main() {\n\n  float flowMapOffset0 = config.x;\n  float flowMapOffset1 = config.y;\n  float halfCycle = config.z;\n  float scale = config.w;\n\n  float depth = texture2D(tDepth, vUv).x;\n  float w;\n  // float logDepthBufFC = 2.0 / log2( 1000000. + 1.0 );\n  // float w = pow(2.0, (2. * depth / logDepthBufFC)) - 1.0;\n  // depth = viewZToPerspectiveDepth(-w, 1., 1000000.);\n\n  vec4 world = clipToWorldMatrix * vec4(vUv * 2. - 1., depth * 2. - 1., 1.0);\n  world /= world.w;\n  float worldDistance = length(world.xyz - cameraPosition);\n\n  vec3 dir = normalize(world.xyz - cameraPosition);\n  vec3 hitPoint = linePlaneIntersect(cameraPosition, dir, vec3(0., 0., waterLevel), vec3(0., 0., -1.));\n  float hitDirection = dot(hitPoint - cameraPosition, dir);\n  float hitDistance = hitDirection > 0. ? length(hitPoint - cameraPosition) : 1e7;\n\n  float dist = min(hitDistance, worldDistance);\n  float fogDensity = 0.007;\n  float fogFactor;\n  vec3 nearestPoint = dist == hitDistance ? hitPoint : world.xyz;\n  float waterDepth = waterLevel - nearestPoint.z;\n\n  // sample normal maps (distort uvs with flowdata)\n  vec2 nUV = fract(hitPoint.xy / 15.);\n  vec2 flow = vec2(1., 1.);\n  vec4 normalColor0 = texture2D( tNormalMap0, nUV + flow * time / 10.);\n  vec4 normalColor1 = texture2D( tNormalMap1, nUV + flow * time / 10.);\n\n  // linear interpolate to get the final normal color\n  float flowLerp = sin(time) / 2. + 0.5;\n  vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n  // calculate normal vector\n  vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0,  normalColor.g * 2.0 - 1.0, -normalColor.b ));\n  vec3 waterNormal = normalize(normal);\n  vec4 coord = worldToClipMatrix * vec4(hitPoint.xy + waterNormal.xy * waterNormal.z * 3., hitPoint.z, 1.0);\n  coord /= coord.w;\n  coord = coord / 2.0 + 0.5;\n  // coord.xy = vUv;\n\n  if (worldDistance < hitDistance) {\n    gl_FragColor = texture2D(tDiffuse, vUv);\n    gl_FragColor.rgb *= caustic(nearestPoint.xy / 10.);\n  } else {\n\n    // calculate the fresnel term to blend reflection and refraction maps\n    float theta = max( dot( -dir, waterNormal ), 0.0 );\n    float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n    reflectance = (1. - length(refract(dir, waterNormal, 1.33))) * reflectance;\n    reflectance = clamp(reflectance, 0.15, 0.85);\n\n    vec4 reflectColor = texture2D( tReflectionMap, vec2(1. - coord.x, coord.y) );\n    vec4 reflectDepth = texture2D( tReflectionDepth, vec2(1.0 - coord.x, coord.y) );\n    vec4 refractColor = texture2D( tDiffuse, coord.xy );\n\n    // w = pow(2.0, (2. * reflectDepth.x / logDepthBufFC)) - 1.0;\n    // w = -perspectiveDepthToViewZ(reflectDepth.x, 1., 1000000.);\n    // reflectDepth.x = viewZToPerspectiveDepth(-w, 1., 1000000.);\n    w = 500. * reflectDepth.x + dist;\n\n    fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * w * w * LOG2 ) );\n    reflectColor.rgb = mix(reflectColor.rgb, depthColor, fogFactor);\n\n    // multiply water color with the mix of both textures\n    gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n    // gl_FragColor = vec4(vec3(reflectance), 1.0);\n    // gl_FragColor = reflectColor;\n    // gl_FragColor = reflectDepth;\n    // gl_FragColor = vec4(vec3(w/500.), 1.0);\n    // gl_FragColor = vec4(vec3(w/100.), 1.0);\n\n}\n\n// float fogDepth = dist + waterDepth * min(1., waterDepth / 100.);\nfloat fogDepth = dist + clamp(waterLevel - cameraPosition.z, 0., 100.);\nfogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\ngl_FragColor.rgb = mix(gl_FragColor.rgb, depthColor, fogFactor);\n\ngl_FragColor.rgb += GodRays(vUv) * (1. - smoothstep(0., 100., waterLevel - cameraPosition.z));\n\nvec4 star = detritus(cameraPosition, dir,  min(40., dist / STAR_VOXEL_STEP_SIZE));\ngl_FragColor.rgb = gl_FragColor.rgb * (1.0 - star.a)+star.rgb;\n\n\n// gl_FragColor = texture2D(tReflectionMap, vec2(1.0 - vUv.x, vUv.y));\n// gl_FragColor = vec4(dir, 1.);\n// gl_FragColor = vec4( vec3(dist /1000.), 1.0 );\n// gl_FragColor = vec4( vec3(hitDistance/100.), 1.0 );\n// gl_FragColor = vec4( vec3(dist/100.), 1.0 );\n\n}"},181:function(e,t){e.exports=" #include <fog_pars_vertex>\n\nuniform mat4 textureMatrix;\n\nvarying vec4 vCoord;\nvarying vec2 vUv;\nvarying vec3 vToEye;\n\nvoid main() {\n\nvUv = uv;\nvCoord = textureMatrix * vec4( position, 1.0 );\n\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvToEye = cameraPosition - worldPosition.xyz;\n\nvec4 mvPosition = viewMatrix * worldPosition; // used in fog_vertex\ngl_Position = projectionMatrix * mvPosition;\n\n#include <fog_vertex>\n\n}"},246:function(e,t,n){e.exports=n(287)},247:function(e,t,n){},252:function(e,t,n){e.exports=n.p+"static/media/GrassGreenTexture0003.78621f63.jpg"},253:function(e,t,n){e.exports=n.p+"static/media/GrassGreenTexture0003_normal.002f20c3.jpg"},256:function(e,t){e.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Qzk3MDg1MDY1MzMzMTFFMDkwN0M4OEMxQ0JGNjFGQkIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Qzk3MDg1MDc1MzMzMTFFMDkwN0M4OEMxQ0JGNjFGQkIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDOTcwODUwNDUzMzMxMUUwOTA3Qzg4QzFDQkY2MUZCQiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDOTcwODUwNTUzMzMxMUUwOTA3Qzg4QzFDQkY2MUZCQiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Po4pkJAAAA9KSURBVHja7F0JdqMwDJUh9z8yHsBgZG0WYEPaKdPXIRQSol1fshjhb3t1G3/KjQbH9seAjuTud9UfAwTa9Xjb72TA53W6Nz8zbTFG+x34Cf+RBnik8qZOVK/9ErX4fJXIG3+9owH4WiL4+U9vKcT4sNT7RbWTBtjHfzkDmhz/ywP+GPDTfMApErfih8cHcAeQjjzpD8bepOeE4yZYtMu9fYBxn0/6g/FJwddI7IlQ5wOnfqrM0I48bAPHTlIvUr/KifKgSlDfbVSY4aH7A6rw6S31/KAtZeL3vUYFZNnxQRDNPX4573NX0ckxfHrbHA/pTxHdZkbV9+Zj6QBnQ+bBM954fIb6WJfLfa+JcHpj7WTNxNVuj+43t0ifB8wO/g6a1Bu6cicM5UpAQs/0imuDbZEaasbYlvqi6NnUN6TMEPxqQYYfF19WtcEpH+8wwL4t5ZsIX9WmFLgrLdppxkuDDc/w4NOP+pz0tloYlicbhNvhUGGRyNtmo5QtEjFHmsd+gQHu8IZS32GdgsaAJnLH406J0HKMxOl+nwfjK9Qn6s+vSn8ahiG9TDt440eINRPtm+Hb2b1Z4VnDhPkuA+5QX4v5Sgouv2Zyp8Mr3efdAUIiEuw7y8+w/tqlOSTxFAmnKaLIp2pi/1MZQMi9Uhmy1GdJTMdXCm/vsJMfMtaQftLbK5mdkJQ0tGzPMcBB8aBRn3xzYlLSkbyzH887+SBsqsF+4DgBvdh2rdsw5UOFeMWv3JcBHuqTYF/8tljMhaBwpftiaNazwmJx1hfzr528QfIB25/CyqsIO6/i+h4WA3KEo5igjplwuO97beqLdj+fljmRI4752EKydCYYRAlqhBOXK/P+8m/9fz1wxCzTNJEL85F8Er4mX0j+Ku500YC2DGDpUhjHTWaHlfKroZ+5sTkGiWd0S39KFJ/3F3KE5R3mI8P8P0JCAagG/AAfYNsfnk/a1Ce2fjUbG+OS5Yc15Fn5EEhUakMRdGc4VD1kzZKCUqdP9gS17RMxP/WNVFZzwrCZG8xCdNqAP2L+HfHnZysy76v5UaBmN2lJesVTYpIqo48oKgpN4Lmxoe/lYIPhaYuQZhF0WAPOgaRa+Pd25iBLf/6N4x8jwpktEhwmCM5mWFoge1YJmsHR1XhfsUXZMgQjJ0LfSoODwtmYYvELCw9gx38iDoeIHpSIRQEWcfE/pRCfVsbHk23x+HqjOwST9BE5leC4YYzjb/RKRCnostIfIrWcDJsLhDcYLLpviD73nTCJeUStFNgAoYra7287OHVc8gFxs/lwBDyMTDGUzkD0BxpNCJx3lgefC9Uuzfjke81Ro2L6D5HX4XswklX7fszqVdKhqRTzJb+b3fK0udkgmR1ulyxD5OfE6GRANfI5gBqL+imokam/Q2p3N9P9wEJqHJFiru+BjrtKcV126xrgXhUk+wMN5gTQqJ9s/RLyGBiGcWOaJ2RmZz4wZaNUvkNRML7WuX7WCn2uWX/nqgfKEhCqjBvCDBvynJVAgb0A23TF9w6k0sKjGgKOTtOUzpzT5gmmPdsIWg0O2ajDw1/zBJ9W4s/fgdmiAjPAoX3G87XSx24eDkaIQSc266JgljoxIfg6ZOOZoIyEZGirmsrQSOCBXxuGfihHxJWRshCfCiyZTOnEkm0k4gzlwQL2QC2Ihxr5gMiQM1sEN9Xte3cs6BTwQIAaNePdD4zjiBlDqjGKc5Z/28iuFkGxKzViB209U18GVEu+JIklpp8RERCdOVmN2i/oO1YHdb5TNwOEg7HI/q7zoHr+CQaIyA+PdoRyORTE5Sdk4yMhSCfas3AaARDOIjZFxhvrKRjU+mi6JGJc/IG10JQIogjAgciA8k0CrgM7e3IxWsCRS958iGBOGr/h3sXdW4hOOOSw9UIuNrayPziwydXEBDInaB/V3GmbCTNBMAxFadeJ0SuNeIHzkjVRB9y2fgRLC0oxeOyJlg9Vty5REGpfGAYYynjUDmpjCawOJLtuUnwlEkAqGTiAHkAMyVpun5vORD9efPFd/INGzQOoGGhsrhi3CgwnNrXNNzDbjNVcRB4urx81pMrw/LlpZ03JDrSuexSktVoY9ge7UPRSDFuCPndG7pl1NiJUG/yzW3amL8dOkn6pZ90vu8bJowd9U6soKqoDKa1nhl6LlIp87fLiSNENcEOUuy4k0kfib1Fq3SUtGO7YGaNdOcCpuQOBZM5tXRGTm0FcyaSmn5sPt5CJyzZ8vFb71WQ/R5mS+AdFA/bGTpYKXKa7nbvk0FMhaCnpSyQUQanFa7C8/1sMfnZ5QPA98qfAZy7nSgI+vxz6NeZIqUm0l8FIyhpyYU5bkNPACd93AKneMuyRj9ZNzjWAp8H36a59C9GXlkZfSIOjhIE39gFn0QyxUJfSePfS50LrW1G/GlkQgFZzP1quoMMEp63QcEGJtNVbKc5Zs8ei5m5f2C/HscGf5HVyKEGyE9Y11wugvpVhtkhMNkQeQwUPbjL7U8L4zNYYiogpAtrg3OpKpuQPQWyz6eaE8Z9iDszqMWVQGy+/hQFrMzKQ4iG3nqGAKZ6W+q0rMRInZC3p3tOaBcNgCdqzGlD1QjjcxF9ZuSTmePylHvEAelOeFGDHO3mieOFw7WIlUQBUyRDgTykDEFvV+tqi3eUc4q8JdUHuKPTUdNGAB51h5CR4wA3kNiRihU5h2t/ohNcKxlYB9q1qP2Tq8ir4G5wIR+Z+XlxaKe4Ab26vDw/OQYODbaEx6b+BAd/Ag3MpC17a9wsY8FwMagQ2xm3EfWsUpkeVAY3sL7WSNTGP+Uu+tFa9SERQLey5kGGsRpliMcCAQqGsa4O6SuBY0kWC8QcjsXgsLmZoKIVC49dHQUaGrKhhagZJ/a3P6QHpVmdZQvSbtfvWabSlHsxyGAiTTdLIEp6w2DPLt6XV/ZQAr3kvCRcTwFAupI8UcljOoabpa8NQeR2W2Kr/0hL1mCd8JLKTm9Fvqmdbyn0N2Hugt34mydyDmOjbS1n7KEEmdCxJT/e3q/ZsIaJNM7blhIkKz26tEz5DoMrSxjeioPgNWchwWZQUModYDAJw2spkiHtVnZQbiKA80aQQ8BQA1axlg1EFzsl5vCu9PFNYt4TGPIA9YYNXhntoRnankVmVgvLbq80DV1sTbfujXXuCAYDgZWW+G9jjObUZ0aIP6DFPbGewTBdC/bRKIIU/hhNuNjXxbC4G6swYY0WKvDo+aw+/kZts4PK4i/8RfRbOFu2npZOE+svaPjTXyelpezlhM1YLHnPJCoEhz83olBLuDaCC8BLjs2lAnAirzg5Wt890tSZ63ADKcYI2irkaQZWLUl03dkr2EfYgaABxAjHS3EuMVpvlAX43wLMBALLkIY98O6bl8ZzAaPDT+uAvm6PsdfNOsiRaXJ+OTCXFezxUYLSl0rlCTwAYBk3erQKItgrhQvLB7H7kVhu9BEEhdnXRMi8+0u9UCtaYAWzMTAGdlsN/Bi34KcPQKHZUVBnADEXg5rukaYxSlosP1tj8qgbg8cC4wQT3o+dzoBwRBvrgJzJGDHlmK3NmEydp9wMPeGKUHMZ6Mi9/NQevTq+S5G5AMya7L0hNcgUPRBxCijjTVbEsm2AggcIJe5AT4wHfs9yqZMBM5TQ3YvYK6T6nOGXVEfkqckK0P1WG3WKAnZHlUZGgzosWIiVlQnlxCxrf84CyzDziADCxErllKoNggjphVmPVxfmRUQWD24IhOxg9/8wkdaCk5g95zgVsKUAS/8w2uyZcdQANFmqfVQJFJ9RQhxek9DOhnFWjJoB4bEz+XbrfzbTPqW7hZuMRbvI1GriMY9ufWxpwXwnIeodABjXJfWpq1sbjVykYDzu+T8P2TPoVV5iQOYIENOA5Qtj0k4wMzIHSF6LPvgwA3oO2zyzQJufmcIU/OwRP68y2hDtzHMsTSu0HN77kPmeK/ECMoV516esDblohKBdhoUr3UikIqbZUhrBMioEsHmLzN3gcmcP8ZFiyhZkyppasSvq0NexBTIqr7MNhhZ4syIxO1+eZWGx0eeYlS/pn8TmddM20hzS63QAs0zFOGPGPR1m4wDv5+5R/su7q1tjKa0qQQSHRoOfpKfwWmVkPZBi381vxAkg8EDWGPE+H0SphoiiizWxVpXVjfjUabVjmGg/M9wnu7qZwtmarM4Bi/Qjs1HCIKAaynuSrgQk6ywDNGyuTN5alTFEBnDkeJ9WtZPASVxxFjAGfto6nBI4FeSotDd2Ed3KujVebY/eV7GyfXC6CvaVZCOg7BxzvFzLMiipVmpKWLLKjuQFuqe7gRS0ZoD04QxuAu0U1Kx34WG3pcage/BmKgiIL4bPmpXKAiND5zcv9x8jUH+BwgQdw4sk7weMXnPEPseaC8EKG+SfSE2dAaRxyuOxyGzDA4wwkax54BouHIGF2cIuPO2eNOqIo8gW4hpYDZ0DCpr5H6jv6gFM8AH2keq0UnKQybMQKmWRHfb8agGqgZv5vz4WF87U2Hu0BVnCm8+cdBoAyuYLAZCgEOZZQb+M+1qETMbVlKqkvEv+jVpOt/HYtbEPiCG7zjIC3YYBHlpUuCmB1rsifYld++bCT7qDq/nr/Tw4MIzJnK/Qx5VmsySELHf0cOtWgZtvf9n2K0n0GYJSCj4UX9SaWz+eMm5KAgUXvoEKAog0i2rDBi09xgztP0gNvG4taeHHMdj7G0UdMY/aTHgA35UaGeX860BsCOzt9rH2w1dCI6w/z9OuBXf+q3j0x8aYTxu46Vlx0xaNCD4PzJgOIoNsTCI1hK4bY8tM8MeWLDxN+mgG500R8eqD2CKmzBCJgMn8u2DV0r0cWBk2eKX/WPWhnYmm9I5U8j3NCp3bIfx/2eZQBzvzgmoxfe75RVX7FN+tK/YsMuKYHcOLZQPXmQ0/HoN9o+OP95n64JQPO8sCY5WS/uTbf7VqUaVP/MjjYnQG2tDofRucMcojga9jcSV9a59wDidtDDHAfgQsm65Socuq1WuvyDgPOsuEURNpqs72rx8H2gyvGVm/Ugwf32XBB3jtFO90ZUDUa/pVirezPHXjnMZzuZQb0ZsMXwp99GXDZKHWS/SrFb/a1fTUD7ot2jyjo2/RjfOZjnrH1nbThjwG/eftjwP/BAHCD0q8YnxdDo/H5j7z2rJS25P6ekHR864ObPxn5LDW/JBsY4Tu2103Q/86Arpz4TtJ/KQMu8+abqfxLGPArt38CDADEuKXiVIDdyAAAAABJRU5ErkJggg=="},257:function(e,t,n){"use strict";n.r(t);var o=n(9);n.d(t,"BufferAttribute",function(){return o.b}),n.d(t,"REVISION",function(){return o.g}),n.d(t,"ShaderChunk",function(){return o.h}),n.d(t,"Vector2",function(){return o.k}),n.d(t,"Vector3",function(){return o.l}),n.d(t,"Vector4",function(){return o.m}),n.d(t,"Color",function(){return o.d}),n.d(t,"Texture",function(){return o.j}),n.d(t,"Math",function(){return o.e}),n.d(t,"AdditiveBlending",function(){return o.a}),n.d(t,"ShaderMaterial",function(){return o.i}),n.d(t,"BufferGeometry",function(){return o.c}),n.d(t,"Points",function(){return o.f})},262:function(e,t,n){e.exports=n.p+"static/media/Explosion_002_Tile_8x8_256x256.d28fc70f.png"},263:function(e,t,n){e.exports=n.p+"static/media/smokeparticle.4939a8d2.png"},264:function(e,t){e.exports="data:image/png;base64,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"},265:function(e,t){e.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gIBEhghhPTbNQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABF0lEQVQ4y62TsU7DQBBE39opHKS4AuUrkjKlC/qUlPxcSij5A5cuyVdYSZVIGCGZoRlLF8sBJDjpdNZ6Zm92bzaYWJKW/hzOFiAi2jE2JshroAJWwNzhDtgDdUS8XiSQFBEh37oBHnzeAYVx78ABaIBnoBnUzJJkG+ARuAdKIE8UFsACuE2SvgySQ9Ja0k7SUVIv6fPK7o3ZuVRmblRlBWVy67g/cqw0tpLUZv6xcs35teYmsdzYFUBmBXPXNkWcSlSYs8z448psks5PpV9wZGwHtIOCvd+5T0BTRIw5mENmQ9Q2ySkBarSH2MnY+sLakraSnvzOHyM/9I4djdkOvNSJTWLbH638f8P0zTgvgBuH3oDz1Dh/AWVJt7banagAAAAAAElFTkSuQmCC"},267:function(e,t){},269:function(e,t){},279:function(e,t,n){e.exports=n.p+"static/media/impact1.db06d2c4.ogg"},280:function(e,t,n){e.exports=n.p+"static/media/impact2.7d720129.ogg"},281:function(e,t,n){e.exports=n.p+"static/media/impact3.7a5b4e82.ogg"},282:function(e,t,n){e.exports=n.p+"static/media/impact4.43348926.ogg"},283:function(e,t,n){e.exports=n.p+"static/media/gatling.b8ff47f4.ogg"},284:function(e,t,n){e.exports=n.p+"static/media/missile.f0faf674.ogg"},285:function(e,t,n){e.exports=n.p+"static/media/explosion1.2f1ab236.ogg"},286:function(e,t,n){e.exports=n.p+"static/media/explosion2.752472e3.ogg"},287:function(e,t,n){"use strict";n.r(t);n(247);var o=n(132),a=n(26),i=n(1),r=n(161),l=n(0),c=n(2),s=n(156),d=n(21),u=n(289),v=n(41),f=n(134),p=n(62),m=n(3),g=n(65),h=n(92),x=n(159),y=n(160),w=n(4),C=n(164),b=n.n(C),_=n(165),D=n.n(_),M=n(69),P=n.n(M),S=n(166),A=n.n(S).a,E=n(29),z=n(14),L=function e(){var t=e.SkyShader,n=new E.a({fragmentShader:t.fragmentShader,vertexShader:t.vertexShader,uniforms:z.a.clone(t.uniforms),side:l.g});d.a.call(this,new u.a(1,32,15),n)};L.prototype=Object.create(d.a.prototype),L.SkyShader={uniforms:{luminance:{value:1},turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new i.a}},vertexShader:"\n        uniform vec3 sunPosition;\n        uniform float rayleigh;\n        uniform float turbidity;\n        uniform float mieCoefficient;\n\n        varying vec3 vWorldPosition;\n        varying vec3 vSunDirection;\n        varying float vSunfade;\n        varying vec3 vBetaR;\n        varying vec3 vBetaM;\n        varying float vSunE;\n\n        const vec3 up = vec3( 0.0, 0.0, 1.0 );\n\n        // constants for atmospheric scattering\n        const float e = 2.71828182845904523536028747135266249775724709369995957;\n        const float pi = 3.141592653589793238462643383279502884197169;\n\n        // wavelength of used primaries, according to preetham\n        const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n        // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n        // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n        const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n        // mie stuff\n        // K coefficient for the primaries\n        const float v = 4.0;\n        const vec3 K = vec3( 0.686, 0.678, 0.666 );\n        // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n        const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n        // earth shadow hack\n        // cutoffAngle = pi / 1.95;\n        const float cutoffAngle = 1.6110731556870734;\n        const float steepness = 1.5;\n        const float EE = 1000.0;\n\n        float sunIntensity( float zenithAngleCos ) {\n        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n        }\n\n        vec3 totalMie( float T ) {\n        float c = ( 0.2 * T ) * 10E-18;\n        return 0.434 * c * MieConst;\n        }\n\n        void main() {\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        vSunDirection = normalize( sunPosition );\n\n        vSunE = sunIntensity( dot( vSunDirection, up ) );\n\n        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.z / 450000.0 ) ), 0.0, 1.0 );\n\n        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n        // extinction (absorbtion + out scattering)\n        // rayleigh coefficients\n        vBetaR = totalRayleigh * rayleighCoefficient;\n\n        // mie coefficients\n        vBetaM = totalMie( turbidity ) * mieCoefficient;\n\n        }\n    ",fragmentShader:"\n        varying vec3 vWorldPosition;\n        varying vec3 vSunDirection;\n        varying float vSunfade;\n        varying vec3 vBetaR;\n        varying vec3 vBetaM;\n        varying float vSunE;\n\n        uniform float luminance;\n        uniform float mieDirectionalG;\n\n        const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n        // constants for atmospheric scattering\n        const float pi = 3.141592653589793238462643383279502884197169;\n\n        const float n = 1.0003; // refractive index of air\n        const float N = 2.545E25; // number of molecules per unit volume for air at\n                                    // 288.15K and 1013mb (sea level -45 celsius)\n\n        // optical length at zenith for molecules\n        const float rayleighZenithLength = 8.4E3;\n        const float mieZenithLength = 1.25E3;\n        const vec3 up = vec3( 0.0, 0.0, 1.0 );\n        // 66 arc seconds -> degrees, and the cosine of that\n        const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n        // 3.0 / ( 16.0 * pi )\n        const float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n        // 1.0 / ( 4.0 * pi )\n        const float ONE_OVER_FOURPI = 0.07957747154594767;\n\n        float rayleighPhase( float cosTheta ) {\n        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n        }\n\n        float hgPhase( float cosTheta, float g ) {\n        float g2 = pow( g, 2.0 );\n        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n        }\n\n        // Filmic ToneMapping http://filmicgames.com/archives/75\n        const float A = 0.15;\n        const float B = 0.50;\n        const float C = 0.10;\n        const float D = 0.20;\n        const float E = 0.02;\n        const float F = 0.30;\n\n        const float whiteScale = 1.0748724675633854; // 1.0 / Uncharted2Tonemap(1000.0)\n\n        vec3 Uncharted2Tonemap( vec3 x ) {\n        return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;\n        }\n\n\n        void main() {\n        // optical length\n        // cutoff angle at 90 to avoid singularity in next formula.\n        float zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );\n        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n        float sR = rayleighZenithLength * inverse;\n        float sM = mieZenithLength * inverse;\n\n        // combined extinction factor\n        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n        // in scattering\n        float cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );\n\n        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n        vec3 betaRTheta = vBetaR * rPhase;\n\n        float mPhase = hgPhase( cosTheta, mieDirectionalG );\n        vec3 betaMTheta = vBetaM * mPhase;\n\n        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n        // nightsky\n        vec3 direction = normalize( vWorldPosition - cameraPos );\n        float theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n        float phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n        vec3 L0 = vec3( 0.1 ) * Fex;\n\n        // composition + solar disc\n        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n        vec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );\n        vec3 color = curr * whiteScale;\n\n        vec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n        gl_FragColor = vec4( retColor, 1.0 );\n\n        }"};var T=n(121),R=n(135),F=n(136),U=new T.a(16777215,4);window.dirLight=U;var I=new R.a(16777147,526368,.1);I.position.set(0,0,1),I.up.set(0,0,1),I.needsUpdate=!0;var k=new F.a(4210752,.1),N=function(){U.position.copy(U.sunPosition),U.position.normalize(),U.position.multiplyScalar(1600),U.position.add(Do.position)};var V=n(46),G=n(17),O=n(10),B=n(167),H=n.n(B),Y=n(37),W=n(5),X=n(15),Z=n(168),j=n.n(Z),Q=n(169),q=n.n(Q),K=(new p.a).setCrossOrigin("anonymous"),J=K.load(n(114)),$=K.load(n(115)),ee=K.load(n(252)),te=K.load(n(253));J.wrapS=J.wrapT=l.ac,J.offset.set(0,0),J.repeat.set(20,20),$.wrapS=$.wrapT=l.ac,ee.wrapS=ee.wrapT=l.ac,te.wrapS=te.wrapT=l.ac;var ne=n(80),oe=n(170),ae=n.n(oe),ie=n(171),re=n.n(ie),le=(new p.a).setCrossOrigin("anonymous"),ce=le.load(n(114)),se=le.load(n(115)),de=le.load(n(137)),ue=le.load(n(138));ce.wrapS=ce.wrapT=l.ac,se.wrapS=se.wrapT=l.ac,de.wrapS=de.wrapT=l.ac,ue.wrapS=ue.wrapT=l.ac;var ve,fe,pe=function(e,t){var n=new ne.a({uniforms:Object(Y.a)({roughness:{value:.7},metalness:{value:0}},W.a.common,W.a.lights,W.a.normalmap,W.a.fog,{rockTexture:{value:ce},rockTextureNormal:{value:se}},t),vertexShader:ae.a,fragmentShader:re.a,lights:!0,fog:!0});return n.uniforms.map.value=de,n.uniforms.normalMap.value=ue,n.roughness=.7,n.metalness=0,n.uniforms.uvTransform.value=(new X.a).multiplyScalar(20),n.uniforms.needsUpdate=!0,n.needsUpdate=!0,n}(),me=45.8671,ge={x:(ve=7.3087,fe=10,(ve+180)/360*Math.pow(2,fe)),y:function(e,t){return(1-Math.log(Math.tan(e*Math.PI/180)+1/Math.cos(e*Math.PI/180))/Math.PI)/2*Math.pow(2,t)}(me,10)};window.chamonix=ge;for(var he=function(e,t){var n=t.split(",").map(function(e){return parseInt(e,10)}),o=n[0],a=n[1],i=n[2],r=n[5],l=function(e){return{x:ge.x/Math.pow(2,10-e),y:ge.y/Math.pow(2,10-e)}}(o);e.position.set(a*r-(l.x%1-.5)*r-800*(1-ge.x%1),-i*r+(l.y%1-.5)*r+800*(1-ge.y%1),0)},xe=function(e,t){var n=new E.a({uniforms:Object(Y.a)({opacity:{value:1},clearCoat:{value:0},clearCoatRoughness:{value:0},roughness:{value:0},metalness:{value:0}},W.a.common,W.a.lights,W.a.specularMap,W.a.envmap,W.a.aomap,W.a.lightmap,W.a.emissivemap,W.a.bumpmap,W.a.normalmap,W.a.displacementmap,W.a.roughnessmap,W.a.metalnessmap,W.a.gradientmap,W.a.fog,W.a.points,{rockTexture:{value:J},rockTextureNormal:{value:$}},t),defines:{PHYSICAL:"",USE_MAP:"",USE_NORMALMAP:"",USE_ENVMAP:"",ENVMAP_TYPE_CUBE:"",ENVMAP_BLENDING_MULTIPLY:"",TONE_MAPPING:""},vertexShader:j.a,fragmentShader:q.a,extensions:{derivatives:!0},wireframe:!1,lights:!0,fog:!0});return n.uniforms.map.value=ee,n.uniforms.normalMap.value=te,n.uniforms.toneMappingExposure={value:3},n.uniforms.toneMappingWhitePoint={value:5},n.opacity=1,n.roughness=1,n.metalness=0,n.lightMapIntensity=1,n.aoMapIntensity=1,n.emissiveIntensity=1,n.envMapIntensity=1,n.refractionRatio=.98,n.bumpscale=1,n.normalScale=new m.a(5,5),n.uniforms.reflectivity.value=.5,n.clearCoatRoughness=0,n.isShaderMaterial=!1,n.isMeshStandardMaterial=!0,n.isMeshPhysicalMaterial=!0,n.uniforms.uvTransform.value=(new X.a).multiplyScalar(20),n.needsUpdate=!0,n}(0,{}),ye=function(e){var t=new G.a,n=new Float32Array(e.data.positions),o=new Float32Array(e.data.normals),a=new(0,{2:Uint16Array,4:Uint32Array}[e.data.bpe.indices])(e.data.indices),i=new Float32Array(n.length/3*2),r=Math.sqrt(n.length/3);i=i.map(function(e,t){return t%2?Math.floor(t/2/r)/r:t/2%r/r}),t.addAttribute("position",new O.a(n,3)),t.addAttribute("normal",new O.a(o,3)),t.addAttribute("uv",new O.a(i,2)),t.setIndex(new O.a(a,1)),t.computeBoundingSphere(),t.computeBoundingBox();var l=ho.PBR?xe:pe,c=new d.a(t,l);c.key=e.data.key,c.name="terrainTile",c.castShadow=!0,c.receiveShadow=!0,he(c,e.data.key),xo.add(c),wo.shadowMap.needsUpdate=!0},we=[],Ce=navigator.hardwareConcurrency-1||3,be=0;be<Ce;be++){var _e=new H.a;_e.onmessage=ye,we.push(_e)}var De=0;we.postMessage=function(e){we[De].postMessage(e),De=De===Ce-1?0:De+1};var Me=new i.a(0,0,0),Pe=[];window.tiles={},window.pngs={};var Se=function(e){xo.remove(e),e.geometry.dispose(),e.geometry=null,e.material.dispose(),e.material=null},Ae=new i.a,Ee=function(e){var t=yo.position;Ae=Ae.set(0,0,-1).applyQuaternion(yo.quaternion);var n=t.clone();if(n=n.add(Ae.multiplyScalar(400*Math.max(1,Math.abs(t.z)/400))),Do.position.set(n.x,n.y,200),U.updatePosition(),t.distanceTo(Me)>10){Me=t.clone();var o,a=Math.min(7,Math.floor(Math.sqrt(Math.abs(t.z))/28)),r=10-a,l=800*Math.pow(2,a),c=Math.round(n.x/l),s=-Math.round(n.y/l),d=t.z>2e3?127:255,u=t.z>2e3?31:63,v=3*l,f=new i.a,p=new i.a,m=new i.a,g=[[r,c,s,d,0,l],[r,c,s+1,d,0,l],[r,c+1,s,d,0,l],[r,c+1,s+1,d,0,l],[r,c-1,s-1,u,0,l],[r,c-1,s-0,u,0,l],[r,c-1,s+1,u,0,l],[r,c-1,s+2,u,0,l],[r,c+2,s-1,u,0,l],[r,c+2,s-0,u,0,l],[r,c+2,s+1,u,0,l],[r,c+2,s+2,u,0,l],[r,c,s-1,u,0,l],[r,c,s+2,u,0,l],[r,c+1,s-1,u,0,l],[r,c+1,s+2,u,0,l],[r,c-2,s-2,15,0,l],[r,c-2,s-1,15,0,l],[r,c-2,s-0,15,0,l],[r,c-2,s+1,15,0,l],[r,c-2,s+2,15,0,l],[r,c-2,s+3,15,0,l],[r,c+3,s-2,15,0,l],[r,c+3,s-1,15,0,l],[r,c+3,s-0,15,0,l],[r,c+3,s+1,15,0,l],[r,c+3,s+2,15,0,l],[r,c+3,s+3,15,0,l],[r,c-1,s-2,15,0,l],[r,c-1,s+3,15,0,l],[r,c,s-2,15,0,l],[r,c,s+3,15,0,l],[r,c+1,s-2,15,0,l],[r,c+1,s+3,15,0,l],[r,c+2,s-2,15,0,l],[r,c+2,s+3,15,0,l]],h=g.map(function(e){return e.toString()}),x=Pe.map(function(e){return e.toString()}),y=h.slice(0,4),w=xo.children.filter(function(e){return y.includes(e.key)}),C=function(e){return f.subVectors(e.position,yo.position).length()};w.sort(function(e,t){return C(e)-C(t)}),yo.userData.terrainKeysUnder=y,yo.userData.terrainTileUnder=w[0];var b=h.filter(function(e){return x.indexOf(e)<0}),_=xo.children.filter(function(e){return e.key}).map(function(e){return e.key});b.forEach(function(e){if(!_.includes(e)){var t=e.split(",").map(function(e){return parseInt(e,10)});(function(e,t,n,o,a,i){we.postMessage([e,t,n,o,a,i])}).apply(void 0,Object(V.a)(t))}}),xo.children.filter(function(e){return e.key}).forEach(function(e){o=f.subVectors(m.set(e.position.x,e.position.y,0),p.set(yo.position.x,yo.position.y,0)).length(),e.userData.distanceToCamera=o,o<v&&h.includes(e.key)?e.visible=!0:window.setTimeout(function(){e.visible=!1},750)}),xo.children.filter(function(e){return e.key}).sort(function(e,t){return e.userData.distanceToCamera-t.userData.distanceToCamera}).slice(128).forEach(function(e){e.markedForDeletion||(window.setTimeout(function(){return Se(e)},750),e.markedForDeletion=!0)}),Pe=g.slice(0)}};Ee.clean=function(){xo.children.filter(function(e){return"terrainTile"===e.name}).forEach(function(e){return Se(e)}),Pe=[],Me=new i.a(0,0,0)};var ze=n(57),Le=n(139),Te=n(172),Re=n.n(Te),Fe=n(173),Ue=n.n(Fe),Ie=(new p.a).setCrossOrigin("anonymous"),ke=Ie.load(n(114)),Ne=Ie.load(n(115)),Ve=Ie.load(n(137)),Ge=Ie.load(n(138));ke.wrapS=ke.wrapT=l.Y,Ne.wrapS=Ne.wrapT=l.Y,Ve.wrapS=Ve.wrapT=l.Y,Ge.wrapS=Ge.wrapT=l.Y;var Oe=0,Be=0,He=-175,Ye=n(174),We=n.n(Ye),Xe=function(e,t){var n=new E.a({uniforms:Object(Y.a)({roughness:{value:.7},metalness:{value:0}},W.a.common,W.a.lights,W.a.envmap,W.a.normalmap,W.a.fog,{rockTexture:{value:ke},rockTextureNormal:{value:Ne}},t),defines:{STANDARD:"",USE_MAP:"",USE_NORMALMAP:""},vertexShader:Re.a,fragmentShader:Ue.a,extensions:{derivatives:!0},wireframe:!1,lights:!0,fog:!0});return n.uniforms.map.value=Ve,n.uniforms.normalMap.value=Ge,n.roughness=.7,n.metalness=0,n.normalScale=new m.a(1,1),n.isShaderMaterial=!1,n.isMeshStandardMaterial=!0,n.uniforms.uvTransform.value=(new X.a).multiplyScalar(20),n.needsUpdate=!0,n}(),Ze=new Set;window.emptyKeys=Ze;for(var je=function(e){var t=[e.data.i,e.data.j,e.data.k];if(e.data.hasGeometry){var n=new Float32Array(e.data.pos1),o=new Float32Array(e.data.normals1),a=new Uint16Array(e.data.index1),i=new G.a;i.addAttribute("position",new O.a(n,3)),i.addAttribute("normal",new O.a(o,3)),i.setIndex(new O.a(a,1));var r=new d.a(i,Xe);r.position.set(500*e.data.i+Oe,500*e.data.j+Be,500*e.data.k+He),r.userData.key=t;var l=new Le.a(r,16776960);r.name="terrainVoxel",l.name="terrainVoxelHelper",xo.add(l),xo.add(r)}else Ze.add(t.toString())},Qe=[],qe=navigator.hardwareConcurrency-1||3,Ke=0;Ke<qe;Ke++){var Je=new We.a;Je.onmessage=je,Qe.push(Je)}var $e=0;Qe.postMessage=function(e){Qe[$e].postMessage(e),$e=$e===qe-1?0:$e+1};var et,tt=new i.a(0,0,0),nt=[];window.currentKeys=nt;var ot=function(e){var t=yo.position;if(t.distanceTo(tt)>10){tt=t.clone();var n=Math.floor(t.x/500+.5),o=Math.floor(t.y/500+.5);console.log("camera centered on tile ",n,o);var a=[];(new ze.a).setFromMatrix((new w.a).multiplyMatrices(yo.projectionMatrix,yo.matrixWorldInverse));for(var r=0;r<3;r++)for(var l=0;l<3;l++)for(var c=0;c<2;c++)a.push([r-Math.floor(1)+n,l-Math.floor(1)+o,c]);a.forEach(function(e){et=e.toString(),Ze.has(et)||nt.includes(et)||(nt.push(et),console.log("build",e),function(e,t,n){Qe.postMessage([e,t,n,2])}.apply(void 0,Object(V.a)(e)))});var s,d=new i.a,u=new i.a,v=new i.a;xo.children.filter(function(e){return e.userData.key}).forEach(function(e){s=d.subVectors(u.set(yo.position.x,yo.position.y,0),v.set(e.position.x,e.position.y,0)).length();var t=500*Math.ceil(1.5)*1.1;e.visible=s<t})}};ot.clean=function(){xo.children.filter(function(e){return["terrainVoxel","terrainVoxelHelper"].includes(e.name)}).forEach(function(e){return function(e){xo.remove(e),e.geometry.dispose(),e.geometry=null,e.material.dispose(),e.material=null}(e)}),nt=[],tt=new i.a(0,0,0)};var at=n(54),it=n.n(at),rt=[Ee,ot],lt=0;it.a.bind("t",function(e){console.log("switch terrain"),rt[lt].clean(),lt=lt===rt.length-1?0:lt+1,console.log("switch terrain done")});var ct=n(141),st=n(117),dt=n(76),ut=n(144),vt=(n(142),n(162)),ft=n(74),pt=n(143),mt=n(163),gt=(new p.a).load(n(256)),ht=new st.a;ht.addElement(new st.b(gt,60,.6)),ht.addElement(new st.b(gt,70,.7)),ht.addElement(new st.b(gt,120,.9)),ht.addElement(new st.b(gt,70,1));var xt=ht,yt={uniforms:{tDepth:{type:"t",value:null},tColor:{type:"t",value:null},velocityFactor:{type:"f",value:1},delta:{type:"f",value:16.67},clipToWorldMatrix:{type:"m4",value:new w.a},previousWorldToClipMatrix:{type:"m4",value:new w.a},cameraMove:{type:"v3",value:new i.a}},vertexShader:"\n  varying vec2 vUv;\n\n  void main() {\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    vUv = uv;\n\n  }",fragmentShader:"\n  varying vec2 vUv;\n\n  uniform sampler2D tDepth;\n  uniform sampler2D tColor;\n\n  uniform mat4 clipToWorldMatrix;\n  uniform mat4 previousWorldToClipMatrix;\n\n  uniform vec3 cameraMove;\n\n  uniform float velocityFactor;\n  uniform float delta;\n\n  void main() {\n\n    float zOverW = texture2D(tDepth, vUv).x;\n\n    // clipPosition is the viewport position at this pixel in the range -1 to 1.\n    vec4 clipPosition = vec4(vUv.x * 2. - 1., vUv.y * 2. - 1., zOverW * 2. - 1., 1.);\n\n    vec4 worldPosition = clipToWorldMatrix * clipPosition;\n    worldPosition /= worldPosition.w;\n\n    vec4 previousClipPosition = worldPosition;\n\n    // Reduce motion blur due to camera translation especially at the screen center.\n    previousClipPosition.xyz -= cameraMove * (\n      1. - smoothstep(.3, 1., clamp(length(clipPosition.xy), 0., 1.))\n    );\n\n    previousClipPosition = previousWorldToClipMatrix * previousClipPosition;\n    previousClipPosition /= previousClipPosition.w;\n\n    vec2 velocity = velocityFactor * (clipPosition - previousClipPosition).xy / delta * 16.67;\n\n    vec4 finalColor = vec4(0.);\n    vec2 offset = vec2(0.);\n    float weight = 0.;\n    const int samples = 20;\n    for(int i = 0; i < samples; i++) {\n          offset = velocity * (float(i) / (float(samples) - 1.) - .5);\n          vec4 c = texture2D(tColor, vUv + offset);\n      finalColor += c;\n    }\n    finalColor /= float(samples);\n    gl_FragColor = vec4(finalColor.rgb, 1.);\n\n    // debug: view velocity values\n    // gl_FragColor = vec4(abs(velocity), 0., 1.);\n\n    // debug: view depth buffer\n    // gl_FragColor = vec4(vec3(zOverW), 1.);\n  }"},wt=(new w.a,new i.a,new i.a,n(113)),Ct=n(22),bt=n.n(Ct),_t=n(146),Dt=n(67),Mt=n(68),Pt=n(112),St=n(110),At=n(111),Et=n(13),zt=n(175),Lt=n.n(zt);var Tt,Rt,Ft,Ut=function(e){var t=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=e.clone(),o=window.innerWidth/2,a=window.innerHeight/2;return n.project(yo),n.x=n.x*o,n.y=-n.y*a,t||(n.x+=o,n.y+=a),n}(e);return{x:Math.min(Math.max(10,t.x),window.innerWidth-10),y:Math.min(Math.max(10,t.y),window.innerHeight-10),z:t.z}},It=function(e,t,n){return Math.min(Math.max(e,t),n)},kt=function(e){function t(){return Object(Dt.a)(this,t),Object(Pt.a)(this,Object(St.a)(t).apply(this,arguments))}return Object(At.a)(t,e),Object(Mt.a)(t,[{key:"render",value:function(){return Et.c.createElement("svg",{x:this.props.x-this.props.size/2,y:this.props.y-this.props.size/2,viewBox:"-10 -10 415 415",width:this.props.size,height:this.props.size},Et.c.createElement("g",this.props,Et.c.createElement("circle",{cx:"202.224",cy:"202.228",r:"26.686"}),Et.c.createElement("path",{d:"M83.807,49.322L50.87,4.891c-9.519-9.527-30.71-3.78-40.236,5.747S-4.64,41.347,4.887,50.874 l44.431,32.937c9.519,9.519,24.963,9.527,34.49,0C93.334,74.284,93.326,58.84,83.807,49.322z"}),Et.c.createElement("path",{d:"M393.823,10.638c-9.527-9.527-30.71-15.274-40.236-5.747l-32.937,44.431 c-9.527,9.527-9.527,24.963,0,34.49c9.527,9.527,24.963,9.519,34.49,0l44.431-32.937 C409.096,41.347,403.349,20.164,393.823,10.638z"}),Et.c.createElement("path",{d:"M355.139,320.645c-9.527-9.527-24.963-9.527-34.49,0c-9.527,9.527-9.527,24.963,0,34.49 l32.937,44.431c9.527,9.519,30.71,3.78,40.236-5.747s15.274-30.71,5.747-40.236L355.139,320.645z"}),Et.c.createElement("path",{d:"M49.318,320.645L4.887,353.582c-9.527,9.527-3.78,30.71,5.747,40.236s30.71,15.274,40.236,5.747 l32.937-44.431c9.527-9.519,9.527-24.963,0-34.49C74.28,311.127,58.844,311.127,49.318,320.645z"})))}}]),t}(Et.b),Nt=new m.a(window.innerWidth/2,window.innerHeight/2);A.subscribe("x.screen.resized",function(e,t){Nt=new m.a(t.width/2,t.height/2)});var Vt={targets:new Set,targetsInSight:new Set,targetsInFront:new Set,gunTarget:null},Gt=function(e){function t(e){var n;return Object(Dt.a)(this,t),(n=Object(Pt.a)(this,Object(St.a)(t).call(this,e))).state={time:0,gunHeat:0,lockLevel:0,pilot:null},n}return Object(At.a)(t,e),Object(Mt.a)(t,[{key:"componentDidMount",value:function(){A.publish("x.hud.mounted")}},{key:"gunHeat",value:function(){if(!Tt||!Tt.gunClock.running)return Math.max(0,this.state.gunHeat-.01);var e=Tt.gunClock.getDelta(),t=this.state.gunHeat+e/1.5;return t>=1&&(A.publish("x.drones.gun.stop",Tt),A.publish("x.camera.shake.stop"),Tt.gunClock.stop()),Math.min(t,1)}},{key:"lockLevel",value:function(){var e=this;if(0===Vt.targetsInSight.size)return Math.max(0,this.state.lockLevel-.02);var t=[];return Vt.targetsInSight.forEach(function(n){var o=n.lockClock.getDelta();t.push(e.state.lockLevel+o/2)}),Math.min(Math.max.apply(Math,t),1)}},{key:"update",value:function(e,t){var n=this.gunHeat(),o=this.lockLevel();this.setState(Object(Y.a)({},t,{time:e,gunHeat:n,lockLevel:o,lock:1===o,pilot:Tt?Tt.userData:null}))}},{key:"render",value:function(){var e=this,t=Array.from(Vt.targets),n=t.map(function(e){return Object.assign(Lt()(e.userData),{id:e.id})});return Et.c.createElement("div",null,Et.c.createElement("div",{id:"limiter"}),Et.c.createElement("div",{id:"pointer"}),Et.c.createElement("div",{id:"focal",style:this.state.focalStyle}),Et.c.createElement("div",{id:"horizon",style:this.state.horizonStyle}),this.state.pilot?Et.c.createElement("div",{id:"messages"},Et.c.createElement("div",null,this.state.pilot.altitude.toFixed(0)," m"),Et.c.createElement("div",null,this.state.pilot.speed.toFixed(0)," m/s")):null,Et.c.createElement("svg",{className:"vector"},Et.c.createElement(kt,{size:"30",x:Nt.x,y:Nt.y,fill:"transparent",stroke:"#0f0",strokeWidth:"17",opacity:"0.8"}),Et.c.createElement("circle",{cx:Nt.x,cy:Nt.y,r:160,stroke:"#666",opacity:.8,strokeWidth:"10",fill:"transparent",strokeDasharray:"140 1000",transform:"rotate(155 ".concat(Nt.x," ").concat(Nt.y,")"),strokeLinecap:"round"}),this.state.lockLevel?Et.c.createElement("circle",{cx:Nt.x,cy:Nt.y,r:160,stroke:"#0f0",opacity:.8,strokeWidth:"10",fill:"transparent",strokeDasharray:"".concat(140*this.state.lockLevel," 1000"),transform:"rotate(155 ".concat(Nt.x," ").concat(Nt.y,")"),strokeLinecap:"round"}):null,Et.c.createElement("circle",{cx:Nt.x,cy:Nt.y,r:160,stroke:"#666",opacity:.8,strokeWidth:"10",fill:"transparent",strokeDasharray:"140 1000",strokeLinecap:"round",transform:"rotate(205 ".concat(Nt.x," ").concat(Nt.y,") translate(").concat(2*Nt.x,", 0) scale(-1, 1)")}),this.state.gunHeat?Et.c.createElement("circle",{cx:Nt.x,cy:Nt.y,r:160,stroke:"orange",opacity:.8,strokeWidth:"10",fill:"transparent",strokeDasharray:"".concat(140*this.state.gunHeat," 1000"),strokeLinecap:"round",transform:"rotate(205 ".concat(Nt.x," ").concat(Nt.y,") translate(").concat(2*Nt.x,", 0) scale(-1, 1)")}):null,t.map(function(t){return t.gunHud?Et.c.createElement("g",{key:t.id},Et.c.createElement("path",{d:"M ".concat(t.hudPosition.x," ").concat(t.hudPosition.y,"\n                    l ").concat(t.direction.x," ").concat(t.direction.y),strokeWidth:"1",stroke:t===e.state.gunTarget?"#0f0":"orange",fill:"transparent"}),t===e.state.gunTarget?Et.c.createElement(kt,{size:"30",x:t.hudPosition.x+t.direction.x,y:t.hudPosition.y+t.direction.y,fill:"#0f0",fillOpacity:"0.6",stroke:"#0f0",strokeWidth:"17",strokeOpacity:"1"}):null):null})),Et.c.createElement("div",{id:"targets"},n.map(function(e){return Et.c.createElement("div",{className:"target",key:e.id,id:"target-"+e.id,style:e.hud.element.style},Et.c.createElement("div",{className:"life",style:{width:e.life/100*20}}),Et.c.createElement("div",{className:"arrow",style:e.hud.arrow.style}),Et.c.createElement("div",{className:"distance"},e.hud.distance.innerHTML),Et.c.createElement("div",{className:"name"},"drone-",e.id))})))}}]),t}(Et.a);A.subscribe("x.hud.register.target",function(e,t){var n,o,a,i,r,l;Vt.targets.add(t),t.userData.hud={element:{style:{}},arrow:{style:{}},distance:{style:{}}};var c=function(e,c){Qt.mounted&&((n=Ut(t.position)).z>1?(n.x=window.innerWidth-n.x,n.y=window.innerHeight-10,t.userData.hud.element.style.borderColor="red",t.userData.hud.arrow.style.borderBottomColor="red"):(t.userData.hud.element.style.borderColor="orange",t.userData.hud.arrow.style.borderBottomColor="orange"),t.hudPosition=n,i=new m.a(n.x,n.y).sub(Nt),t.userData.hudPositionCentered=i,i.length()>400&&i.normalize().multiplyScalar(400),t.userData.hud.arrow.style.opacity=.8*(1-(400-i.length())/50),r=yo.position.clone().sub(t.position),a=r.length(),t.userData.distance=a,t.userData.hud.distance.innerHTML=a.toFixed(0),t.userData.hud.distance.style.color=a<500?"#0f0":"orange",t.userData.hud.element.style.transform="\n      translateX(".concat(i.x+Nt.x,"px)\n      translateY(").concat(i.y+Nt.y,"px)\n      scale(").concat(1.1-Math.min(.2,a/2e3),")\n    "),t.userData.hud.arrow.style.transform="\n      translateY(2px)\n      rotate(".concat(i.angle()/Math.PI*180+90,"deg)\n    "),o=i.length(),!t.destroyed&&"orange"===t.userData.hud.element.style.borderColor&&o<150?(t.userData.hud.arrow.style.borderBottomColor="#0f0",Vt.targetsInSight.add(t),t.lockClock.running||t.lockClock.start()):(Vt.targetsInSight.delete(t),t.lockClock.stop()),!t.destroyed&&o<390?Vt.targetsInFront.add(t):Vt.targetsInFront.delete(t),n.z<=1&&o<320?(l=Ut(t.position.clone().add(t.velocity.clone().multiplyScalar(Math.min(1,(a+r.clone().add(t.velocity).length())/2/500)))),t.gunHud=!0,t.direction={x:l.x-(i.x+Nt.x),y:l.y-(i.y+Nt.y)}):t.gunHud=!1,t.ready=!0)};c.id=t.id;A.subscribe("x.drones.destroy",function(e,n){n.id===t.id&&(xo.remove(n),A.publish("x.loops.remove",c),Vt.targets.delete(n),Vt.targetsInSight.delete(t),Qt.forceUpdate())}),A.publish("x.loops.push",c)});var Ot,Bt,Ht,Yt,Wt,Xt=new i.a,Zt=function(e){Ot=new i.a(1,0,0).applyQuaternion(yo.quaternion),Bt=new i.a(0,1,0).applyQuaternion(yo.quaternion),Ht=Math.PI/2-yo.up.angleTo(Ot)*Math.sign(yo.up.dot(Bt)),yo.rollAngle=Ht,Yt=yo.up.dot(Xt.set(0,0,-1).applyQuaternion(yo.quaternion)),Wt=Ht/Math.PI*180,Rt={transform:"translateX(-50%) translateY(".concat(Yt*window.innerHeight/2,"px) rotate(").concat(Wt,"deg)")},Ft=Qt.state.lock?{boxShadow:"0 0 75px #0f0"}:{boxShadow:""},Vt.gunTarget=jt(),Qt.update(e,{horizonStyle:Rt,focalStyle:Ft,gunTarget:Vt.gunTarget})};A.subscribe("x.hud.mounted",function(){A.publish("x.loops.push",Zt),Qt.mounted=!0}),A.subscribe("x.drones.pilotDrone.loaded",function(e,t){Tt=t.pilotDrone}),A.subscribe("x.drones.missile.start",function(e,t){Qt.setState(function(e){return Object(Y.a)({},e,{lockLevel:0,lock:!1})})});var jt=function(){if(0===Vt.targetsInSight.size)return null;var e=[];return Vt.targetsInSight.forEach(function(t){return e.push([new m.a(t.hudPosition.x,t.hudPosition.y).sub(Nt).add(new m.a(t.direction.x,t.direction.y)).length(),t])}),e.sort(function(e,t){return e[0]>t[0]}),e[0][1]},Qt=Et.c.render(Et.c.createElement(Gt,null),document.getElementById("hud")),qt=new p.a,Kt={texture:{value:qt.load(n(262)),frames:new m.a(8,8),loop:1},depthTest:!0,depthWrite:!1,blending:l.d,scale:600,maxParticleCount:25e3},Jt={texture:{value:qt.load(n(263))},depthTest:!0,depthWrite:!1,blending:l.jb,maxParticleCount:25e3},$t={texture:{value:qt.load(n(264))},depthTest:!0,depthWrite:!1,blending:l.jb,maxParticleCount:25e3},en={texture:{value:qt.load(n(265))},depthTest:!0,depthWrite:!1,blending:l.jb,maxParticleCount:25e3},tn={particleCount:200,type:bt.a.distributions.DISC,position:{radius:5,spread:new i.a(5)},maxAge:{value:2,spread:0},duration:1,activeMultiplier:2e3,velocity:{value:new i.a(40)},rotation:{axis:new i.a(0,0,1),angle:.5*Math.PI,static:!0},size:{value:2},color:{value:[new c.a(.4,.2,.1),new c.a(.2,.2,.2)]},opacity:{value:[.5,.2,0]}},nn={particleCount:100,type:bt.a.distributions.SPHERE,position:{radius:.1},maxAge:{value:2},duration:1,activeMultiplier:40,velocity:{value:new i.a(100)},acceleration:{value:new i.a(0,0,-20),distribution:bt.a.distributions.BOX},wiggle:3,size:{value:2,spread:5},angle:{spread:2*Math.PI},drag:{value:1},color:{value:[new c.a(1,1,1),new c.a(1,1,0),new c.a(1,0,0),new c.a(.4,.2,.1)]},opacity:{value:[1,1,0]}},on={particleCount:20,type:bt.a.distributions.SPHERE,position:{radius:5},maxAge:{value:2},duration:1,activeMultiplier:20,velocity:{value:new i.a(10)},size:{value:[20,100]},color:{value:[new c.a(.5,.1,.05),new c.a(.2,.2,.2)]},opacity:{value:[.5,.35,.1,0]}},an={particleCount:100,position:{spread:new i.a(15,15,15),distribution:bt.a.distributions.SPHERE},maxAge:{value:2},duration:1,activeMultiplier:2e3,velocity:{value:new i.a(8,3,10),distribution:bt.a.distributions.SPHERE},size:{value:40},color:{value:new c.a(.2,.2,.2)},opacity:{value:[0,0,.4,0]}},rn={duration:1,particleCount:50,position:{spread:new i.a(5,5,5)},velocity:{spread:new i.a(30),distribution:bt.a.distributions.SPHERE},size:{value:[40,20,20,20]},maxAge:{value:2},activeMultiplier:2e3,opacity:{value:[1,1,0,0]}},ln={particleCount:1e3,position:{spread:new i.a(1,1,1)},maxAge:{value:10},velocity:{value:new i.a(4,2,5),distribution:bt.a.distributions.SPHERE},size:{value:[20,60]},color:{value:new c.a(.9,.9,.9)},opacity:{value:[.4,.4,.4,0]}},cn={particleCount:1e3,position:{spread:new i.a(1,1,1)},maxAge:{value:5},velocity:{value:new i.a(4,2,5),distribution:bt.a.distributions.SPHERE},size:{value:[5,10]},color:{value:new c.a(1,1,1)},opacity:{value:[.4,.4,.4,0]}},sn={particleCount:35,type:bt.a.distributions.BOX,position:{radius:.1},maxAge:{value:1},duration:null,activeMultiplier:1,velocity:{value:new i.a(100),spread:new i.a(20,20,20)},acceleration:{value:0},size:{value:1},color:{value:[new c.a(1,1,1),new c.a(1,1,0)]},opacity:{value:1}},dn={particleCount:10,type:bt.a.distributions.SPHERE,position:{radius:.1},maxAge:{value:.3},duration:.3,activeMultiplier:1e3,velocity:{value:new i.a(100)},acceleration:{value:0},wiggle:30,size:{value:[3,1,.5]},color:{value:[new c.a(1,1,1),new c.a(1,1,0)]},opacity:{value:1}},un=new bt.a.Group(Kt),vn=new bt.a.Group(Kt),fn=new bt.a.Group($t),pn=new bt.a.Group(Jt),mn=new bt.a.Group(Jt),gn=new bt.a.Group(Jt),hn=new bt.a.Group(Jt),xn=new bt.a.Group(en),yn=new bt.a.Group($t);un.addPool(25,rn,!1),vn.addPool(25,on,!1),fn.addPool(25,nn,!1),pn.addPool(25,tn,!1),mn.addPool(25,an,!1),gn.addPool(25,ln,!1),hn.addPool(25,cn,!1),xn.addPool(25,sn,!1),yn.addPool(25,dn,!1);var wn=[un,vn,fn,pn,mn,gn,hn,xn,yn];wn.forEach(function(e){e.mesh.renderOrder=2}),gn.mesh.renderOrder=1,wn.forEach(function(e){e.mesh.frustumCulled=!1}),window.smokeGroup=gn;var Cn=new i.a,bn=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3?arguments[3]:void 0,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=e.getFromPool();if(null!==r){var l,c,s,d,u,v;r.position.value=a?t.position.clone().add(Cn.set(0,0,-1).applyQuaternion(yo.quaternion).multiplyScalar(5)):t.position.clone(),o&&(r.velocity.value=o());var f=new i.a,p=function(e){return function(t,n,o){var a=Math.floor(o/e);return t[a]||(t[a]=[]),t[a].push(n),t}},m={loop:function(e,n){r.position.value=a?t.position.clone().add(Cn.set(0,0,-1).applyQuaternion(yo.quaternion).multiplyScalar(5)):t.position.clone(),o&&(r.velocity.value=o(),l=r.attributes.position.typedArray.array.slice(3*r.attributeOffset,3*r.activationEnd).reduce(p(3),[]),s=r.attributes.velocity.typedArray.array.slice(3*r.attributeOffset,3*r.activationEnd).reduce(p(3),[]),c=r.paramsArray.slice(4*r.attributeOffset,4*r.activationEnd).reduce(p(4),[]),d=c.map(function(e,t){return e[0]?Object(wt.a)(i.a,Object(V.a)(l[t])).add(Object(wt.a)(i.a,Object(V.a)(s[t])).multiplyScalar(e[1])):null}),u=[],d.forEach(function(e,t){null!==e&&Vt.targetsInFront.forEach(function(o){v=new _t.a(e,e.clone().add(Object(wt.a)(i.a,Object(V.a)(s[t])).multiplyScalar(n/1e3))),v.closestPointToPoint(o.position,!0,f).sub(o.position).length()<10&&u.push([o,e])})}),u.length&&u.forEach(function(e){A.publish("x.sound.impact",e[0]),Dn({position:e[1]}),e[0].userData.life-=5}))},alive:!0,id:t.id};return n&&!t.destroyed&&(A.publish("x.loops.push",m),A.subscribe("x.drones.destroy",function(n,o){o.id===t.id&&(m.alive=!1,r.disable(),e.releaseIntoPool(r))})),r.loop=m,r.enable(),r.duration&&setTimeout(function(){r.disable(),n&&(m.alive=!1),e.releaseIntoPool(r)},1e3*(r.duration+r.maxAge.value+r.maxAge.spread)),r}console.log("SPE.Group pool ran out.")},_n=function(e){bn(un,e),bn(vn,e),bn(fn,e),bn(mn,e)};A.subscribe("x.drones.explode",function(e,t){return _n(t)});A.subscribe("x.drones.smoke.start",function(e,t){var n;(n=t).smoking||(n.smoking=!0,bn(gn,n,!0))});A.subscribe("x.drones.missile.start",function(e,t){return function(e){if(!e.smoking){e.smoking=!0;var t=bn(hn,e,!0);A.subscribe("x.drones.missile.stop",function(e,n){t.loop.alive=!1,t.disable(),hn.releaseIntoPool(t)})}}(t)});var Dn=function(e){bn(yn,e)},Mn=new i.a,Pn=new i.a;A.subscribe("x.drones.gun.start",function(e,t){var n=jt();t.gunEmitter=bn(xn,t,!0,function(){if(null!==n&&n.gunHud)Mn.copy(n.position).sub(t.position),Mn.add(n.velocity.clone().multiplyScalar(Mn.length()/500)),Mn.normalize().multiplyScalar(500),Pn.copy(Mn);else{Pn=Cn.set(0,0,-1).applyQuaternion(yo.quaternion).multiplyScalar(500);var e=new i.a(0,1,0).applyQuaternion(yo.quaternion);Pn=Pn.add(e.multiplyScalar(24))}return Pn},!0)}),A.subscribe("x.drones.gun.stop",function(e,t){t.gunEmitter&&(t.gunEmitter.loop.alive=!1,t.gunEmitter.disable(),xn.releaseIntoPool(t.gunEmitter))});var Sn,An=new ct.a,En=function(){An.load("./assets/drone/scene.gltf",function(e){Sn=e.scene.children[0],A.publish("x.assets.drone.loaded",{mesh:Sn})})},zn=n(75),Ln=n(147),Tn={ready:!1},Rn=function(e,t){(Tn=function(){var e=t.mesh.clone();return e.up.set(0,0,1),e.rotation.x=0,e.scale.set(.1,.1,.1),e.name="drone-".concat(e.id),e}).ready=!0,A.publish("x.drones.factory.ready")};A.subscribe("x.assets.drone.loaded",Rn);A.subscribe("x.drones.factory.ready",function(){var e,t,n,o=Tn();o.gunClock=new zn.a(!1),o.userData.altitude=NaN,o.userData.speed=0,o.userData.lastPosition=o.position.clone(),xo.add(o),window.pilotDrone=o;var a,r=new i.a,l=new Ln.a,c=new i.a(0,0,-1),s=new i.a(0,0,100),d=0;Fo.push(function(u,v){r=r.set(0,0,-1).applyQuaternion(yo.quaternion),t=yo.position.clone().add(r.multiplyScalar(20)),e=new i.a(0,1,0).applyQuaternion(yo.quaternion),n=t.sub(e.multiplyScalar(8)),o.position.copy(n),o.lookAt(t.add(r).add({x:0,y:0,z:60})),o.userData.velocity=o.position.clone().sub(o.userData.lastPosition).multiplyScalar(1e3/v),o.userData.speed=o.userData.velocity.length(),o.userData.lastPosition.copy(o.position),u-d>200&&(d=u,l.set(o.position.clone().add(s),c),(a=l.intersectObjects(yo.userData.terrainTileUnder?[yo.userData.terrainTileUnder]:[])).length>0&&(o.userData.altitude=a[0].distance-s.length(),o.userData.groundNormal=a[0].face.normal),o.userData.altitude<5&&(A.publish("x.drones.explode.pilotDrone",o),A.publish("x.drones.collision.terrain.pilotDrone",o.userData.groundNormal)))}),A.publish("x.drones.pilotDrone.loaded",{pilotDrone:o})});var Fn=function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Tn();n.lockClock=new zn.a(!1),n.userData.life=100,xo.add(n),n.lastPosition=n.position.clone();var o=new i.a,a=function(a,i){if(n){e?n.position.set(300*Math.cos(a/1e3/3+t),300*Math.sin(a/1e3/3+t),300+50*Math.cos(a/1e3+t)):n.position.copy(yo.position.clone().add(o.set(0,0,-1).applyQuaternion(yo.quaternion).multiplyScalar(100))),n.velocity=n.position.clone().sub(n.lastPosition).multiplyScalar(1e3/i),n.lastPosition=n.position.clone(),!n.destroyed&&n.userData.life<=50&&A.publish("x.drones.smoke.start",n),!n.destroyed&&n.userData.life<=0&&(A.publish("x.drones.destroy",n),n.destroyed=!0,_n(n))}};A.subscribe("x.drones.destroy",function(e,t){t.id===n.id&&A.publish("x.loops.remove",a)}),A.publish("x.hud.register.target",n),Fo.push(a)};A.subscribe("x.drones.factory.ready",function(){Fn(!0),Fn(!0,Math.PI/8),Fn(!0,Math.PI/4),Fn(!0,Math.PI/2),Fn(!0,Math.PI)}),A.subscribe("x.drones.destroy",function(){return Fn(!0,2*Math.random()*Math.PI)});var Un=En,In=n(176),kn=n.n(In),Nn=n(177),Vn=n.n(Nn),Gn=n(18);function On(e,t,n,o){var a=this;if(this.object=e,this.domElement=void 0!==t?t:document,t&&this.domElement.setAttribute("tabindex",-1),this.movementSpeed=.1,this.rollSpeed=.001,this.dragToLook=!1,this.autoForward=!1,this.nipple=n,this.nipple&&(this.nipple.on("move",function(e,t){return a.nipplemove(e,t)}),this.nipple.on("end",function(e,t){a.autoForward=!1,a.updateMovementVector()})),this.acceleration=100,this.velocity=new i.a(0,0,0),this.pointer=o,this.pointer){var r=document.getElementById("pointer");this.zone=400,this.pointer.on("attain",function(e){var t=a.getContainerDimensions().size;r.style.left=t[0]/2+"px",r.style.top=t[1]/2+"px";var n=new m.a(0,0);e.on("data",function(e){n.add(new m.a(e.dx,e.dy)),n.length()>a.zone&&n.normalize().multiplyScalar(a.zone),r.style.transform="\n          translateX(".concat(n.x-16,"px)\n          translateY(").concat(n.y-16,"px)\n        "),a.mousemove({pageX:n.x/1.5,pageY:n.y/1.5})}),e.on("close",function(){})})}function l(e,t){return function(){t.apply(e,arguments)}}function c(e){e.preventDefault()}this.nipplemove=function(e,t){var n={pageX:t.distance*Math.cos(t.angle.radian)*1.5,pageY:-t.distance*Math.sin(t.angle.radian)*1.5};this.mousemove(n),this.autoForward=!0,this.updateMovementVector()},this.tmpQuaternion=new Gn.a,this.moveState={up:0,down:0,left:0,right:0,forward:0,back:0,pitchUp:0,pitchDown:0,yawLeft:0,yawRight:0,rollLeft:0,rollRight:0},this.moveVector=new i.a(0,0,0),this.rotationVector=new i.a(0,0,0),this.keydown=function(e){if(!e.altKey){switch(e.keyCode){case 16:this.movementSpeedMultiplier=.1;break;case 87:this.moveState.forward=1;break;case 83:this.moveState.back=1;break;case 65:this.moveState.yawLeft=1;break;case 68:this.moveState.yawRight=1;break;case 82:this.moveState.up=1;break;case 70:this.moveState.down=1;break;case 38:this.moveState.pitchUp=1;break;case 40:this.moveState.pitchDown=1;break;case 37:this.moveState.yawLeft=1;break;case 39:this.moveState.yawRight=1;break;case 81:this.moveState.rollLeft=1;break;case 69:this.moveState.rollRight=1}this.updateMovementVector(),this.updateRotationVector()}},this.keyup=function(e){switch(e.keyCode){case 16:this.movementSpeedMultiplier=1;break;case 87:this.moveState.forward=0;break;case 83:this.moveState.back=0;break;case 65:this.moveState.yawLeft=0;break;case 68:this.moveState.yawRight=0;break;case 82:this.moveState.up=0;break;case 70:this.moveState.down=0;break;case 38:this.moveState.pitchUp=0;break;case 40:this.moveState.pitchDown=0;break;case 37:this.moveState.yawLeft=0;break;case 39:this.moveState.yawRight=0;break;case 81:this.moveState.rollLeft=0;break;case 69:this.moveState.rollRight=0}this.updateMovementVector(),this.updateRotationVector()},this.mousemove=function(e){var t=this.getContainerDimensions(),n=t.size[0]/2,o=t.size[1]/2;this.moveState.yawLeft=-e.pageX/n,this.moveState.rollLeft=this.moveState.yawLeft/2-this.object.rollAngle/5,this.moveState.pitchDown=e.pageY/o},this.deltaVelocity=null,this.deltaPosition=null,this.update=function(e){var t=e*a.rollSpeed;a.deltaVelocity=a.moveVector.clone().multiplyScalar(e/1e3*a.acceleration),a.velocity.sub(a.velocity.clone().multiplyScalar(.01*Math.max(1,a.deltaVelocity.length()?1:100/(a.velocity.length()+1))*e/16.67)).add(a.deltaVelocity),a.deltaPosition=a.velocity.clone().multiplyScalar(e/1e3),a.object.position.add(a.deltaPosition.applyQuaternion(a.object.quaternion)),a.tmpQuaternion.set(a.rotationVector.x*t,a.rotationVector.y*t,a.rotationVector.z*t,1).normalize(),a.object.quaternion.multiply(a.tmpQuaternion),a.object.rotation.setFromQuaternion(a.object.quaternion,a.object.rotation.order),a.updateRotationVector(),a.updateMovementVector()},this.updateMovementVector=function(){var e=this.moveState.forward||this.autoForward&&!this.moveState.back?1:0;this.moveVector.x=-this.moveState.left+this.moveState.right,this.moveVector.y=-this.moveState.down+this.moveState.up,this.moveVector.z=-e+this.moveState.back},this.updateRotationVector=function(){this.rotationVector.x=-this.moveState.pitchDown+this.moveState.pitchUp,this.rotationVector.y=-this.moveState.yawRight+this.moveState.yawLeft,this.rotationVector.z=-this.moveState.rollRight+this.moveState.rollLeft},this.getContainerDimensions=function(){return this.domElement!==document?{size:[this.domElement.offsetWidth,this.domElement.offsetHeight],offset:[this.domElement.offsetLeft,this.domElement.offsetTop]}:{size:[window.innerWidth,window.innerHeight],offset:[0,0]}},this.dispose=function(){this.domElement.removeEventListener("contextmenu",c,!1),window.removeEventListener("keydown",s,!1),window.removeEventListener("keyup",d,!1)};var s=l(this,this.keydown),d=l(this,this.keyup);this.domElement.addEventListener("contextmenu",c,!1),window.addEventListener("keydown",s,!1),window.addEventListener("keyup",d,!1),this.updateMovementVector(),this.updateRotationVector()}var Bn=n(63),Hn=function(){function e(t,n,o){Object(Dt.a)(this,e),this.ship=t,this.controls=n,this.active=o,this.target=null,this.pointerElement=document.getElementById("pointer")}return Object(Mt.a)(e,[{key:"toggle",value:function(){this.active=!this.active}},{key:"update",value:function(e){if(this.active&&(this.state=Object(Y.a)({},Qt.state,Vt),(null===this.target||this.target.destroyed)&&(this.target=Array.from(this.state.targets).filter(function(e){return e.ready&&!e.destroyed}).reduce(function(e,t){return e.userData.distance<t.userData.distance?e:t})),this.target)){var t={x:0,y:0};if(this.target.hudPosition.z>1){var n=100*Math.sign(this.target.userData.hudPositionCentered.x);t.x+=n,t.y+=n*Math.abs(Math.sin(this.ship.rollAngle))}else t.x+=It(-100,this.target.userData.hudPositionCentered.x,100),t.y+=It(-100,this.target.userData.hudPositionCentered.y,100);this.controls.mousemove({pageX:t.x,pageY:t.y}),this.pointerElement.style.transform="\n      translateX(".concat(t.x-16,"px)\n      translateY(").concat(t.y-16,"px)\n    "),this.target.userData.distance>150?this.controls.moveState.forward=1:this.controls.moveState.forward=0}}}]),e}(),Yn={module:null,setAcceleration:function(e){this.module&&e!==this.module.acceleration&&(this.module.acceleration=e,console.log("acceleration set to ",e))}},Wn=function(){var e,t=!1;return e=navigator.userAgent||navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4)))&&(t=!0),t}();A.subscribe("x.drones.pilotDrone.loaded",function(e,t){if(Wn){document.getElementById("touchPane").style.display="block";var n=window.document.getElementsByClassName("touchPaneLeft")[0],o=kn.a.create({zone:n,mode:"static",position:{left:"30%",top:"90%"},color:"white"});Array.from(document.getElementsByClassName("touchButton")).forEach(function(e){e.style.display="block"}),document.getElementById("verbosePane").style.display="none";var a=document.getElementById("buttonX"),i=function(e){e.target.style.opacity=.5,v({button:2}),setTimeout(function(){e.target.style.opacity=.3},250)};a.addEventListener("click",i,!1),a.addEventListener("touchstart",i,!1),Yn.module=new On(yo,n,o)}else{var r=Vn()(wo.domElement);Yn.module=new On(yo,wo.domElement,void 0,r)}Yn.module.update(0);var l=new Hn(yo,Yn.module,!1);it.a.bind("p",function(e){return l.toggle()}),A.publish("x.loops.unshift",function(e,t){l.update(e,t),Yn.module.update(t)});var c=t.pilotDrone;it.a.bind("c",function(e){console.log(yo.position)}),it.a.bind("r",function(e){"OrbitControls"===Yn.module.constructor.name&&(Yn.module.autoRotate=!Yn.module.autoRotate)}),it.a.bind("space",function(e){return A.publish("x.toggle.play")});var s=new d.a(new u.a(1,5,5),new Bn.a({color:1118481})),v=function(e){if(c)if(0===e.button)A.publish("x.drones.gun.start",c),A.publish("x.camera.shake.start",5),c.gunClock.start();else if(2===e.button){var t=function(){if(0===Vt.targetsInSight.size||!Qt.state.lock)return null;var e=[];return Vt.targetsInSight.forEach(function(t){return e.push([yo.position.distanceTo(t.position),t])}),e.sort(function(e,t){return e[0]>t[0]}),e[0][1]}();if(null===t||t.destroyed)return;var n=s.clone();n.position.copy(c.position),xo.add(n),A.publish("x.drones.missile.start",n);var o=new function(){var e=this;this.alive=!0,this.object=n,this.loop=function(o,a){if(e.alive){var i=t.position.clone().sub(n.position);i.length()<10&&(e.alive=!1,_n(t),A.publish("x.drones.missile.stop",n),A.publish("x.drones.explosion",t),t.userData.life-=25,Qt.forceUpdate());var r=i.normalize().multiplyScalar(10*a/16.66);n.position.add(r)}}};A.publish("x.loops.push",o)}};wo.domElement.addEventListener("mousedown",v,!1),wo.domElement.addEventListener("mouseup",function(e){0===e.button&&(A.publish("x.drones.gun.stop",c),A.publish("x.camera.shake.stop"),c.gunClock.stop())},!1)});var Xn=new i.a;A.subscribe("x.drones.collision.terrain.pilotDrone",function(e,t){Yn.setAcceleration(0),Xn.copy(Yn.module.velocity).applyQuaternion(yo.quaternion),Xn.reflect(t),Xn.add(yo.position),Yn.module.velocity=yo.worldToLocal(Xn),setTimeout(function(){Yn.setAcceleration(60)},1e3)});var Zn=Yn,jn=n(153),Qn=n(154),qn=n(155),Kn=n(79),Jn=new jn.a,$n=[{url:n(279)},{url:n(280)},{url:n(281)},{url:n(282)}],eo=[{url:n(283)},{url:n(284)}],to=[{url:n(285)},{url:n(286)}],no=function(e){Jn.load(e.url,function(t){e.buffer=t})},oo=function(){yo.listener=new Qn.a,yo.add(yo.listener),$n.map(no),eo.map(no),to.map(no),A.subscribe("x.sound.impact",function(e,t){var n=Math.floor(Math.random()*$n.length);if($n[n].buffer){var o=new qn.a(yo.listener);o.setBuffer($n[n].buffer),o.setRefDistance(100),t.add(o),o.play()}});var e=function(e,t){var n=Math.floor(Math.random()*to.length);if(to[n].buffer){var o=new qn.a(yo.listener);o.setBuffer(to[n].buffer),o.setRefDistance(500),t.add(o),o.play()}};A.subscribe("x.drones.destroy",e),A.subscribe("x.drones.explosion",e);var t=new Kn.a(yo.listener);A.subscribe("x.drones.gun.start",function(e,n){eo[0].buffer&&(t.setBuffer(eo[0].buffer),t.setLoop(!0),t.play())}),A.subscribe("x.drones.gun.stop",function(e,n){t.stop()});var n=new Kn.a(yo.listener);A.subscribe("x.drones.missile.start",function(e,t){eo[1].buffer&&(n.setBuffer(eo[1].buffer),n.play())}),A.subscribe("x.drones.missile.stop",function(e,t){n.stop()})},ao=n(11),io=n(178),ro=n.n(io),lo=n(179),co=n.n(lo),so=n(180),uo=n.n(so),vo=n(181),fo=n.n(vo),po={uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},surface:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},tDepth:{type:"t",value:null},textureMatrix:{type:"m4",value:null},clipToWorldMatrix:{type:"m4",value:null},config:{type:"v4",value:new ao.a}},vertexShader:co.a,fragmentShader:ro.a},mo={uniforms:{color:{type:"c",value:new c.a(16777215)},reflectivity:{type:"f",value:.75},waterLevel:{type:"f",value:0},tDepth:{type:"t",value:null},tDiffuse:{type:"t",value:null},tReflectionMap:{type:"t",value:null},tReflectionDepth:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},clipToWorldMatrix:{type:"m4",value:null},worldToClipMatrix:{type:"m4",value:new w.a},cameraPosition:{type:"v3",value:null},sunPosition:{type:"v3",value:null},time:{type:"f",value:0}},vertexShader:fo.a,fragmentShader:uo.a};n.d(t,"renderer",function(){return wo}),n.d(t,"scene",function(){return xo}),n.d(t,"camera",function(){return yo}),n.d(t,"drone",function(){return Do}),n.d(t,"sunPosition",function(){return Mo}),n.d(t,"gui",function(){return Co}),n.d(t,"options",function(){return ho}),n.d(t,"loops",function(){return Fo});var go=P.a.parse(window.location.search),ho={PBR:"true"===go.PBR,shadows:"true"===go.shadows,postprocessing:"true"===go.postprocessing};ho.PBR&&(ho.postprocessing=!0);var xo=new o.a,yo=new a.a(75,window.innerWidth/window.innerHeight,1,1e6);yo.up=new i.a(0,0,1),yo.position.set(-70,175,345),yo.lookAt(0,-400,0),yo.rollAngle=0,yo.userData={terrainKeysUnder:[]},yo.updateMatrixWorld(),yo.updateProjectionMatrix(),oo();var wo=new r.a({antialias:!0,alpha:!0,logarithmicDepthBuffer:!1});wo.gammaInput=!0,wo.gammaOutput=!0,wo.shadowMap.enabled=ho.shadows,wo.shadowMap.bias=.001,wo.shadowMap.type=l.sb,wo.shadowMap.autoUpdate=!0,wo.physicallyCorrectLights=!0,wo.toneMapping=l.oc,wo.setSize(window.innerWidth,window.innerHeight),document.body.appendChild(wo.domElement),window.scene=xo,window.renderer=wo,window.camera=yo,window.controls=Zn;var Co=new b.a.GUI({autoPlace:!1});Co.closed=!0,window.document.getElementsByClassName("guiPane")[0].appendChild(Co.domElement),window.gui=Co,A.publish("x.gui.init",{gui:Co});var bo=Co.addFolder("Level of detail"),_o=new function(){this.low=function(){window.location.href=window.location.pathname+"?"+P.a.stringify({PBR:!1,shadows:!1,postprocessing:!1})},this.lowShadow=function(){window.location.href=window.location.pathname+"?"+P.a.stringify({PBR:!1,shadows:!0,postprocessing:!1})},this.lowShadowDoF=function(){window.location.href=window.location.pathname+"?"+P.a.stringify({PBR:!1,shadows:!0,postprocessing:!0})},this.high=function(){window.location.href=window.location.pathname+"?"+P.a.stringify({PBR:!0,shadows:!0,postprocessing:!0})}};bo.add(_o,"low").name("low (default)"),xo.background=new c.a(9546677),xo.fog=new s.a(9546677,5e-4);var Do=new d.a(new u.a(5,5,5),new v.a({color:16777215}));Do.visible=!1,xo.add(Do);var Mo=new i.a;window.sunPosition=Mo,function(e,t,n){var o=new L;o.scale.setScalar(45e4),e.add(o);for(var a=new u.b(1e5,8,8),i=0;i<a.faces.length;i++){var r=a.faces[i],c=r.a;r.a=r.c,r.c=c}var s=new v.a({opacity:0}),f=new d.a(a,s);f.material.side=l.g,e.add(f);var p={turbidity:10,rayleigh:2,mieCoefficient:.005,mieDirectionalG:.8,luminance:1,inclination:.32,azimuth:.2,sun:!1};if(n){var m=function(){var e=o.material.uniforms;e.turbidity.value=p.turbidity,e.rayleigh.value=p.rayleigh,e.luminance.value=p.luminance,e.mieCoefficient.value=p.mieCoefficient,e.mieDirectionalG.value=p.mieDirectionalG;var n=Math.PI*(p.inclination-.5),a=2*Math.PI*(p.azimuth-.5);t.x=g*Math.cos(a),t.z=g*Math.sin(a)*Math.sin(n),t.y=g*Math.sin(a)*Math.cos(n),e.sunPosition.value.copy(t),t.copy(t),U.position.copy(t),U.position.normalize(),U.position.multiplyScalar(2e3)},g=4e5,h=n.addFolder("Sun, sky and ocean");h.add(p,"turbidity",1,20,.1).onChange(m),h.add(p,"rayleigh",0,4,.001).onChange(m),h.add(p,"mieCoefficient",0,.1,.001).onChange(m),h.add(p,"mieDirectionalG",0,1,.001).onChange(m),h.add(p,"luminance",0,2).onChange(m),h.add(p,"inclination",0,1,1e-4).onChange(m),h.add(p,"azimuth",0,1,1e-4).onChange(m),h.add(p,"sun").onChange(m),m()}}(xo,Mo,Co),function(e,t){U.sunPosition=t,U.updatePosition=N,U.updatePosition(),U.up.set(0,0,1),U.name="sunlight",U.castShadow=!0,U.shadow.mapSize.width=U.shadow.mapSize.height=1024;var n=1024;U.shadow.camera.left=-n,U.shadow.camera.right=n,U.shadow.camera.top=n,U.shadow.camera.bottom=-n,U.shadow.camera.far=3200,U.shadow.bias=-1e-4,U.needsUpdate=!0,e.add(U),e.add(I),e.add(k)}(xo,Mo),U.target=Do,xo.add(xt);var Po=2e4,So=new f.a(5*Po,5*Po,10,10),Ao=(new p.a).setCrossOrigin("anonymous"),Eo=new ut.a(So,{textureWidth:512,textureHeight:512,color:16777215,flowDirection:new m.a(1,1),scale:2e4/15,normalMap0:Ao.load(n(157)),normalMap1:Ao.load(n(158)),clipBias:1e-5,reflectivity:.2,shader:po,flowSpeed:.1});window.water=Eo;var zo=new g.a(window.innerWidth,window.innerHeight),Lo=new h.a;zo.depthBuffer=!0,zo.depthTexture=new x.a,Eo.material.uniforms.tDepth.value=zo.depthTexture,Eo.up.set(0,0,1),Eo.position.z=75,Eo.material.uniforms.surface.value=Eo.position.z,Co.__folders["Sun, sky and ocean"].add(Eo.position,"z",0,200,1),Eo.receiveShadow=!0,Eo.userData.isWater=!0,window.water=Eo,xo.add(Eo);var To=new dt.a(So,{textureWidth:512,textureHeight:512,clipBias:1e-5});To.rotation.y=Math.PI,To.up.set(0,0,-1),To.position.copy(Eo.position),To.getRenderTarget().depthBuffer=!0,To.getRenderTarget().depthTexture=new x.a,window.ref=To,To.updateMatrixWorld(),Un(),wn.forEach(function(e){return xo.add(e.mesh)});var Ro=!1;A.subscribe("x.camera.shake.start",function(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Ro=!0}),A.subscribe("x.camera.shake.stop",function(){return Ro=!1});var Fo=[function(){return xt.position.copy(Mo)},function(e){return rt[lt](e)},function(e,t){wn.forEach(function(e){return e.tick(t/1e3)})},function(){Ro?(yo.position.add({x:1*(Math.random()-.5),y:1*(Math.random()-.5),z:1*(Math.random()-.5)}),jo.enabled=!0,Ho.renderToScreen=!1):(jo.enabled=!1,Ho.renderToScreen=!0)},function(){return xo.children.forEach(function(e){e instanceof y.a&&e.update(yo)})},function(e,t){yo.position.z<Eo.position.z?(Vo.enabled=!0,Bo.enabled=!0,Eo.visible=!1,To.onBeforeRender(wo,xo,yo),Vo.material.uniforms.time.value=e/1e3,Bo.material.uniforms.time.value=e/1e3,Zn.setAcceleration(30)):(Vo.enabled=!1,Bo.enabled=!1,Eo.visible=!0,Zn.setAcceleration(100))}];A.subscribe("x.loops.remove",function(e,t){return function(e){Fo=Fo.filter(function(t){return t!==e})}(t)}),A.subscribe("x.loops.push",function(e,t){return Fo.push(t)}),A.subscribe("x.loops.unshift",function(e,t){return Fo.unshift(t)}),window.loops=Fo,A.publish("x.loops.loaded");wo.setPixelRatio(1);var Uo=new D.a;document.body.appendChild(Uo.dom);var Io=new g.a(window.innerWidth,window.innerHeight),ko=new vt.a(wo,Io),No=new pt.a(xo,yo);ko.addPass(No);var Vo=new ft.a(mo);Vo.enabled=!1,Vo.material.uniforms.waterLevel.value=Eo.position.z,Vo.material.uniforms.tDepth.value=zo.depthTexture,Vo.material.uniforms.cameraPosition.value=yo.position,Vo.material.uniforms.sunPosition.value=Mo,Vo.material.uniforms.tReflectionMap.value=To.getRenderTarget().texture,Vo.material.uniforms.tReflectionDepth.value=To.getRenderTarget().depthTexture;var Go=Vo.material.uniforms.tNormalMap0,Oo=Vo.material.uniforms.tNormalMap1;Go.value=Ao.load(n(157)),Oo.value=Ao.load(n(158)),Go.value.wrapS=Go.value.wrapT=l.ac,Oo.value.wrapS=Oo.value.wrapT=l.ac,ko.addPass(Vo),window.upass=Vo;var Bo=new ft.a({uniforms:{tDiffuse:{type:"t",value:null},time:{type:"f",value:0}},vertexShader:"\n    varying vec2 vUv;\n\n    void main() {\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n      vUv = uv;\n\n    }\n  ",fragmentShader:"\n    uniform float time;\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n\n    float frequency = 10.;\n    float amplitude = 0.005;\n\n    void main() {\n      vec2 uv = vUv;\n      float X = vUv.x * frequency + time;\n      float Y = vUv.y * frequency + time;\n      uv.y += cos(X + Y) * amplitude * cos(Y);\n      uv.x += sin(X - Y) * amplitude * sin(Y);\n      gl_FragColor = texture2D(tDiffuse, uv);\n    }\n  "});Bo.enabled=!1,ko.addPass(Bo);var Ho=new ft.a(yt,"tColor");Ho.renderToScreen=!0,Ho.material.uniforms.tDepth.value=zo.depthTexture,Ho.material.uniforms.velocityFactor.value=1,ko.addPass(Ho);var Yo=new w.a,Wo=new w.a,Xo=new i.a,Zo=new w.a,jo=new mt.a;jo.renderToScreen=!0,ko.addPass(jo);var Qo=!0;A.subscribe("x.toggle.play",function(){Qo=!Qo});var qo=0;!function e(t){requestAnimationFrame(e);var n=t-qo;qo=t,Qo&&(Fo.forEach(function(e){e.loop?e.loop(t,n):e(t,n)}),Ho.material.uniforms.delta.value=n,Ho.material.uniforms.clipToWorldMatrix.value.getInverse(yo.matrixWorldInverse).multiply(Zo.getInverse(yo.projectionMatrix)),Ho.material.uniforms.previousWorldToClipMatrix.value.copy(Wo.multiply(Yo)),Ho.material.uniforms.cameraMove.value.copy(yo.position).sub(Xo),xo.overrideMaterial=Lo,Eo.visible=!1,wo.setRenderTarget(zo),wo.render(xo,yo),Eo.visible=!0,xo.overrideMaterial=null,Eo.material.uniforms.clipToWorldMatrix.value=Ho.material.uniforms.clipToWorldMatrix.value,Vo.material.uniforms.clipToWorldMatrix.value=Ho.material.uniforms.clipToWorldMatrix.value,Vo.material.uniforms.worldToClipMatrix.value.copy(yo.projectionMatrix).multiply(yo.matrixWorldInverse),ko.render(n),Yo.copy(yo.matrixWorldInverse),Wo.copy(yo.projectionMatrix),Xo.copy(yo.position)),Fo.forEach(function(e){void 0!==e.alive&&!1===e.alive&&e.object&&xo.remove(e.object)}),Fo=Fo.filter(function(e){return void 0===e.alive||!0===e.alive}),Uo.update()}(0),function(e,t,n){n=n||function(){return{width:window.innerWidth,height:window.innerHeight}};var o=function(){var o=n();e.setSize(o.width,o.height),t.aspect=o.width/o.height,t.updateProjectionMatrix(),A.publish("x.screen.resized",o)};window.addEventListener("resize",o,!1)}(wo,yo)}},[[246,1,2]]]);
//# sourceMappingURL=main.bb6113d3.chunk.js.map